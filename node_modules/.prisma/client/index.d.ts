
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AdminUser
 * 
 */
export type AdminUser = $Result.DefaultSelection<Prisma.$AdminUserPayload>
/**
 * Model EthicalConfig
 * 
 */
export type EthicalConfig = $Result.DefaultSelection<Prisma.$EthicalConfigPayload>
/**
 * Model EthicalConfigVersion
 * 
 */
export type EthicalConfigVersion = $Result.DefaultSelection<Prisma.$EthicalConfigVersionPayload>
/**
 * Model RoleTemplate
 * 
 */
export type RoleTemplate = $Result.DefaultSelection<Prisma.$RoleTemplatePayload>
/**
 * Model CulturalParameter
 * 
 */
export type CulturalParameter = $Result.DefaultSelection<Prisma.$CulturalParameterPayload>
/**
 * Model Relationship
 * 
 */
export type Relationship = $Result.DefaultSelection<Prisma.$RelationshipPayload>
/**
 * Model ConversationMessage
 * 
 */
export type ConversationMessage = $Result.DefaultSelection<Prisma.$ConversationMessagePayload>
/**
 * Model GrowthMetric
 * 
 */
export type GrowthMetric = $Result.DefaultSelection<Prisma.$GrowthMetricPayload>
/**
 * Model VoiceProfile
 * 
 */
export type VoiceProfile = $Result.DefaultSelection<Prisma.$VoiceProfilePayload>
/**
 * Model VoiceSample
 * 
 */
export type VoiceSample = $Result.DefaultSelection<Prisma.$VoiceSamplePayload>
/**
 * Model AvatarProfile
 * 
 */
export type AvatarProfile = $Result.DefaultSelection<Prisma.$AvatarProfilePayload>
/**
 * Model AvatarAsset
 * 
 */
export type AvatarAsset = $Result.DefaultSelection<Prisma.$AvatarAssetPayload>
/**
 * Model Upload
 * 
 */
export type Upload = $Result.DefaultSelection<Prisma.$UploadPayload>
/**
 * Model UsageEvent
 * 
 */
export type UsageEvent = $Result.DefaultSelection<Prisma.$UsageEventPayload>
/**
 * Model SystemMetric
 * 
 */
export type SystemMetric = $Result.DefaultSelection<Prisma.$SystemMetricPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model BackupSnapshot
 * 
 */
export type BackupSnapshot = $Result.DefaultSelection<Prisma.$BackupSnapshotPayload>
/**
 * Model ConfigVersionHistory
 * 
 */
export type ConfigVersionHistory = $Result.DefaultSelection<Prisma.$ConfigVersionHistoryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AdminRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  CONFIG_MANAGER: 'CONFIG_MANAGER',
  VIEWER: 'VIEWER'
};

export type AdminRole = (typeof AdminRole)[keyof typeof AdminRole]


export const AuthProvider: {
  PASSWORD: 'PASSWORD',
  GOOGLE: 'GOOGLE',
  APPLE: 'APPLE',
  GITHUB: 'GITHUB'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const RelationshipRoleTemplateType: {
  FATHER: 'FATHER',
  MOTHER: 'MOTHER',
  SIBLING: 'SIBLING',
  MENTOR: 'MENTOR',
  CUSTOM: 'CUSTOM'
};

export type RelationshipRoleTemplateType = (typeof RelationshipRoleTemplateType)[keyof typeof RelationshipRoleTemplateType]


export const EmotionalTone: {
  POSITIVE: 'POSITIVE',
  NEUTRAL: 'NEUTRAL',
  NEGATIVE: 'NEGATIVE',
  MIXED: 'MIXED'
};

export type EmotionalTone = (typeof EmotionalTone)[keyof typeof EmotionalTone]


export const UsageEventType: {
  MESSAGE: 'MESSAGE',
  LOGIN: 'LOGIN',
  PROFILE_UPDATE: 'PROFILE_UPDATE',
  RELATIONSHIP_CREATED: 'RELATIONSHIP_CREATED',
  CONFIG_CHANGED: 'CONFIG_CHANGED',
  OTHER: 'OTHER'
};

export type UsageEventType = (typeof UsageEventType)[keyof typeof UsageEventType]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  EXPORT: 'EXPORT',
  SYSTEM_EVENT: 'SYSTEM_EVENT'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const AuditEntityType: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  ETHICAL_CONFIG: 'ETHICAL_CONFIG',
  ROLE_TEMPLATE: 'ROLE_TEMPLATE',
  CULTURAL_PARAMETER: 'CULTURAL_PARAMETER',
  RELATIONSHIP: 'RELATIONSHIP',
  CONVERSATION_MESSAGE: 'CONVERSATION_MESSAGE',
  VOICE_PROFILE: 'VOICE_PROFILE',
  AVATAR_PROFILE: 'AVATAR_PROFILE',
  UPLOAD: 'UPLOAD',
  SYSTEM: 'SYSTEM'
};

export type AuditEntityType = (typeof AuditEntityType)[keyof typeof AuditEntityType]


export const MediaType: {
  AUDIO: 'AUDIO',
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  OTHER: 'OTHER'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]

}

export type AdminRole = $Enums.AdminRole

export const AdminRole: typeof $Enums.AdminRole

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type RelationshipRoleTemplateType = $Enums.RelationshipRoleTemplateType

export const RelationshipRoleTemplateType: typeof $Enums.RelationshipRoleTemplateType

export type EmotionalTone = $Enums.EmotionalTone

export const EmotionalTone: typeof $Enums.EmotionalTone

export type UsageEventType = $Enums.UsageEventType

export const UsageEventType: typeof $Enums.UsageEventType

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type AuditEntityType = $Enums.AuditEntityType

export const AuditEntityType: typeof $Enums.AuditEntityType

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminUser`: Exposes CRUD operations for the **AdminUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUsers
    * const adminUsers = await prisma.adminUser.findMany()
    * ```
    */
  get adminUser(): Prisma.AdminUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ethicalConfig`: Exposes CRUD operations for the **EthicalConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EthicalConfigs
    * const ethicalConfigs = await prisma.ethicalConfig.findMany()
    * ```
    */
  get ethicalConfig(): Prisma.EthicalConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ethicalConfigVersion`: Exposes CRUD operations for the **EthicalConfigVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EthicalConfigVersions
    * const ethicalConfigVersions = await prisma.ethicalConfigVersion.findMany()
    * ```
    */
  get ethicalConfigVersion(): Prisma.EthicalConfigVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleTemplate`: Exposes CRUD operations for the **RoleTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleTemplates
    * const roleTemplates = await prisma.roleTemplate.findMany()
    * ```
    */
  get roleTemplate(): Prisma.RoleTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.culturalParameter`: Exposes CRUD operations for the **CulturalParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CulturalParameters
    * const culturalParameters = await prisma.culturalParameter.findMany()
    * ```
    */
  get culturalParameter(): Prisma.CulturalParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.relationship`: Exposes CRUD operations for the **Relationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relationships
    * const relationships = await prisma.relationship.findMany()
    * ```
    */
  get relationship(): Prisma.RelationshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationMessage`: Exposes CRUD operations for the **ConversationMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationMessages
    * const conversationMessages = await prisma.conversationMessage.findMany()
    * ```
    */
  get conversationMessage(): Prisma.ConversationMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.growthMetric`: Exposes CRUD operations for the **GrowthMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GrowthMetrics
    * const growthMetrics = await prisma.growthMetric.findMany()
    * ```
    */
  get growthMetric(): Prisma.GrowthMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voiceProfile`: Exposes CRUD operations for the **VoiceProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoiceProfiles
    * const voiceProfiles = await prisma.voiceProfile.findMany()
    * ```
    */
  get voiceProfile(): Prisma.VoiceProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voiceSample`: Exposes CRUD operations for the **VoiceSample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoiceSamples
    * const voiceSamples = await prisma.voiceSample.findMany()
    * ```
    */
  get voiceSample(): Prisma.VoiceSampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avatarProfile`: Exposes CRUD operations for the **AvatarProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AvatarProfiles
    * const avatarProfiles = await prisma.avatarProfile.findMany()
    * ```
    */
  get avatarProfile(): Prisma.AvatarProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avatarAsset`: Exposes CRUD operations for the **AvatarAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AvatarAssets
    * const avatarAssets = await prisma.avatarAsset.findMany()
    * ```
    */
  get avatarAsset(): Prisma.AvatarAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.upload`: Exposes CRUD operations for the **Upload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Uploads
    * const uploads = await prisma.upload.findMany()
    * ```
    */
  get upload(): Prisma.UploadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageEvent`: Exposes CRUD operations for the **UsageEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageEvents
    * const usageEvents = await prisma.usageEvent.findMany()
    * ```
    */
  get usageEvent(): Prisma.UsageEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemMetric`: Exposes CRUD operations for the **SystemMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemMetrics
    * const systemMetrics = await prisma.systemMetric.findMany()
    * ```
    */
  get systemMetric(): Prisma.SystemMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.backupSnapshot`: Exposes CRUD operations for the **BackupSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BackupSnapshots
    * const backupSnapshots = await prisma.backupSnapshot.findMany()
    * ```
    */
  get backupSnapshot(): Prisma.BackupSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configVersionHistory`: Exposes CRUD operations for the **ConfigVersionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigVersionHistories
    * const configVersionHistories = await prisma.configVersionHistory.findMany()
    * ```
    */
  get configVersionHistory(): Prisma.ConfigVersionHistoryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AdminUser: 'AdminUser',
    EthicalConfig: 'EthicalConfig',
    EthicalConfigVersion: 'EthicalConfigVersion',
    RoleTemplate: 'RoleTemplate',
    CulturalParameter: 'CulturalParameter',
    Relationship: 'Relationship',
    ConversationMessage: 'ConversationMessage',
    GrowthMetric: 'GrowthMetric',
    VoiceProfile: 'VoiceProfile',
    VoiceSample: 'VoiceSample',
    AvatarProfile: 'AvatarProfile',
    AvatarAsset: 'AvatarAsset',
    Upload: 'Upload',
    UsageEvent: 'UsageEvent',
    SystemMetric: 'SystemMetric',
    AuditLog: 'AuditLog',
    BackupSnapshot: 'BackupSnapshot',
    ConfigVersionHistory: 'ConfigVersionHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "adminUser" | "ethicalConfig" | "ethicalConfigVersion" | "roleTemplate" | "culturalParameter" | "relationship" | "conversationMessage" | "growthMetric" | "voiceProfile" | "voiceSample" | "avatarProfile" | "avatarAsset" | "upload" | "usageEvent" | "systemMetric" | "auditLog" | "backupSnapshot" | "configVersionHistory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AdminUser: {
        payload: Prisma.$AdminUserPayload<ExtArgs>
        fields: Prisma.AdminUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findFirst: {
            args: Prisma.AdminUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findMany: {
            args: Prisma.AdminUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          create: {
            args: Prisma.AdminUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          createMany: {
            args: Prisma.AdminUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          delete: {
            args: Prisma.AdminUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          update: {
            args: Prisma.AdminUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          deleteMany: {
            args: Prisma.AdminUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          upsert: {
            args: Prisma.AdminUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          aggregate: {
            args: Prisma.AdminUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUser>
          }
          groupBy: {
            args: Prisma.AdminUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUserCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUserCountAggregateOutputType> | number
          }
        }
      }
      EthicalConfig: {
        payload: Prisma.$EthicalConfigPayload<ExtArgs>
        fields: Prisma.EthicalConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EthicalConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EthicalConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload>
          }
          findFirst: {
            args: Prisma.EthicalConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EthicalConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload>
          }
          findMany: {
            args: Prisma.EthicalConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload>[]
          }
          create: {
            args: Prisma.EthicalConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload>
          }
          createMany: {
            args: Prisma.EthicalConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EthicalConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload>[]
          }
          delete: {
            args: Prisma.EthicalConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload>
          }
          update: {
            args: Prisma.EthicalConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload>
          }
          deleteMany: {
            args: Prisma.EthicalConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EthicalConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EthicalConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload>[]
          }
          upsert: {
            args: Prisma.EthicalConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigPayload>
          }
          aggregate: {
            args: Prisma.EthicalConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEthicalConfig>
          }
          groupBy: {
            args: Prisma.EthicalConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<EthicalConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.EthicalConfigCountArgs<ExtArgs>
            result: $Utils.Optional<EthicalConfigCountAggregateOutputType> | number
          }
        }
      }
      EthicalConfigVersion: {
        payload: Prisma.$EthicalConfigVersionPayload<ExtArgs>
        fields: Prisma.EthicalConfigVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EthicalConfigVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EthicalConfigVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload>
          }
          findFirst: {
            args: Prisma.EthicalConfigVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EthicalConfigVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload>
          }
          findMany: {
            args: Prisma.EthicalConfigVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload>[]
          }
          create: {
            args: Prisma.EthicalConfigVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload>
          }
          createMany: {
            args: Prisma.EthicalConfigVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EthicalConfigVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload>[]
          }
          delete: {
            args: Prisma.EthicalConfigVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload>
          }
          update: {
            args: Prisma.EthicalConfigVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload>
          }
          deleteMany: {
            args: Prisma.EthicalConfigVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EthicalConfigVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EthicalConfigVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload>[]
          }
          upsert: {
            args: Prisma.EthicalConfigVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EthicalConfigVersionPayload>
          }
          aggregate: {
            args: Prisma.EthicalConfigVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEthicalConfigVersion>
          }
          groupBy: {
            args: Prisma.EthicalConfigVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EthicalConfigVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EthicalConfigVersionCountArgs<ExtArgs>
            result: $Utils.Optional<EthicalConfigVersionCountAggregateOutputType> | number
          }
        }
      }
      RoleTemplate: {
        payload: Prisma.$RoleTemplatePayload<ExtArgs>
        fields: Prisma.RoleTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          findFirst: {
            args: Prisma.RoleTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          findMany: {
            args: Prisma.RoleTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>[]
          }
          create: {
            args: Prisma.RoleTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          createMany: {
            args: Prisma.RoleTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>[]
          }
          delete: {
            args: Prisma.RoleTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          update: {
            args: Prisma.RoleTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          deleteMany: {
            args: Prisma.RoleTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>[]
          }
          upsert: {
            args: Prisma.RoleTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          aggregate: {
            args: Prisma.RoleTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleTemplate>
          }
          groupBy: {
            args: Prisma.RoleTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateCountAggregateOutputType> | number
          }
        }
      }
      CulturalParameter: {
        payload: Prisma.$CulturalParameterPayload<ExtArgs>
        fields: Prisma.CulturalParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CulturalParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CulturalParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload>
          }
          findFirst: {
            args: Prisma.CulturalParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CulturalParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload>
          }
          findMany: {
            args: Prisma.CulturalParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload>[]
          }
          create: {
            args: Prisma.CulturalParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload>
          }
          createMany: {
            args: Prisma.CulturalParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CulturalParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload>[]
          }
          delete: {
            args: Prisma.CulturalParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload>
          }
          update: {
            args: Prisma.CulturalParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload>
          }
          deleteMany: {
            args: Prisma.CulturalParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CulturalParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CulturalParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload>[]
          }
          upsert: {
            args: Prisma.CulturalParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CulturalParameterPayload>
          }
          aggregate: {
            args: Prisma.CulturalParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCulturalParameter>
          }
          groupBy: {
            args: Prisma.CulturalParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CulturalParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CulturalParameterCountArgs<ExtArgs>
            result: $Utils.Optional<CulturalParameterCountAggregateOutputType> | number
          }
        }
      }
      Relationship: {
        payload: Prisma.$RelationshipPayload<ExtArgs>
        fields: Prisma.RelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          findFirst: {
            args: Prisma.RelationshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          findMany: {
            args: Prisma.RelationshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>[]
          }
          create: {
            args: Prisma.RelationshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          createMany: {
            args: Prisma.RelationshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelationshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>[]
          }
          delete: {
            args: Prisma.RelationshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          update: {
            args: Prisma.RelationshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          deleteMany: {
            args: Prisma.RelationshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelationshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RelationshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>[]
          }
          upsert: {
            args: Prisma.RelationshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          aggregate: {
            args: Prisma.RelationshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelationship>
          }
          groupBy: {
            args: Prisma.RelationshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationshipCountArgs<ExtArgs>
            result: $Utils.Optional<RelationshipCountAggregateOutputType> | number
          }
        }
      }
      ConversationMessage: {
        payload: Prisma.$ConversationMessagePayload<ExtArgs>
        fields: Prisma.ConversationMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          findFirst: {
            args: Prisma.ConversationMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          findMany: {
            args: Prisma.ConversationMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
          }
          create: {
            args: Prisma.ConversationMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          createMany: {
            args: Prisma.ConversationMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
          }
          delete: {
            args: Prisma.ConversationMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          update: {
            args: Prisma.ConversationMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          deleteMany: {
            args: Prisma.ConversationMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
          }
          upsert: {
            args: Prisma.ConversationMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          aggregate: {
            args: Prisma.ConversationMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationMessage>
          }
          groupBy: {
            args: Prisma.ConversationMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationMessageCountAggregateOutputType> | number
          }
        }
      }
      GrowthMetric: {
        payload: Prisma.$GrowthMetricPayload<ExtArgs>
        fields: Prisma.GrowthMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GrowthMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GrowthMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload>
          }
          findFirst: {
            args: Prisma.GrowthMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GrowthMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload>
          }
          findMany: {
            args: Prisma.GrowthMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload>[]
          }
          create: {
            args: Prisma.GrowthMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload>
          }
          createMany: {
            args: Prisma.GrowthMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GrowthMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload>[]
          }
          delete: {
            args: Prisma.GrowthMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload>
          }
          update: {
            args: Prisma.GrowthMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload>
          }
          deleteMany: {
            args: Prisma.GrowthMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GrowthMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GrowthMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload>[]
          }
          upsert: {
            args: Prisma.GrowthMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthMetricPayload>
          }
          aggregate: {
            args: Prisma.GrowthMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrowthMetric>
          }
          groupBy: {
            args: Prisma.GrowthMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<GrowthMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.GrowthMetricCountArgs<ExtArgs>
            result: $Utils.Optional<GrowthMetricCountAggregateOutputType> | number
          }
        }
      }
      VoiceProfile: {
        payload: Prisma.$VoiceProfilePayload<ExtArgs>
        fields: Prisma.VoiceProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoiceProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoiceProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload>
          }
          findFirst: {
            args: Prisma.VoiceProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoiceProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload>
          }
          findMany: {
            args: Prisma.VoiceProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload>[]
          }
          create: {
            args: Prisma.VoiceProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload>
          }
          createMany: {
            args: Prisma.VoiceProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoiceProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload>[]
          }
          delete: {
            args: Prisma.VoiceProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload>
          }
          update: {
            args: Prisma.VoiceProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload>
          }
          deleteMany: {
            args: Prisma.VoiceProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoiceProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoiceProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload>[]
          }
          upsert: {
            args: Prisma.VoiceProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceProfilePayload>
          }
          aggregate: {
            args: Prisma.VoiceProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoiceProfile>
          }
          groupBy: {
            args: Prisma.VoiceProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoiceProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoiceProfileCountArgs<ExtArgs>
            result: $Utils.Optional<VoiceProfileCountAggregateOutputType> | number
          }
        }
      }
      VoiceSample: {
        payload: Prisma.$VoiceSamplePayload<ExtArgs>
        fields: Prisma.VoiceSampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoiceSampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoiceSampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload>
          }
          findFirst: {
            args: Prisma.VoiceSampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoiceSampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload>
          }
          findMany: {
            args: Prisma.VoiceSampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload>[]
          }
          create: {
            args: Prisma.VoiceSampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload>
          }
          createMany: {
            args: Prisma.VoiceSampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoiceSampleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload>[]
          }
          delete: {
            args: Prisma.VoiceSampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload>
          }
          update: {
            args: Prisma.VoiceSampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload>
          }
          deleteMany: {
            args: Prisma.VoiceSampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoiceSampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoiceSampleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload>[]
          }
          upsert: {
            args: Prisma.VoiceSampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoiceSamplePayload>
          }
          aggregate: {
            args: Prisma.VoiceSampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoiceSample>
          }
          groupBy: {
            args: Prisma.VoiceSampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoiceSampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoiceSampleCountArgs<ExtArgs>
            result: $Utils.Optional<VoiceSampleCountAggregateOutputType> | number
          }
        }
      }
      AvatarProfile: {
        payload: Prisma.$AvatarProfilePayload<ExtArgs>
        fields: Prisma.AvatarProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvatarProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvatarProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          findFirst: {
            args: Prisma.AvatarProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvatarProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          findMany: {
            args: Prisma.AvatarProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>[]
          }
          create: {
            args: Prisma.AvatarProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          createMany: {
            args: Prisma.AvatarProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvatarProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>[]
          }
          delete: {
            args: Prisma.AvatarProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          update: {
            args: Prisma.AvatarProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          deleteMany: {
            args: Prisma.AvatarProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvatarProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvatarProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>[]
          }
          upsert: {
            args: Prisma.AvatarProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarProfilePayload>
          }
          aggregate: {
            args: Prisma.AvatarProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvatarProfile>
          }
          groupBy: {
            args: Prisma.AvatarProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvatarProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvatarProfileCountArgs<ExtArgs>
            result: $Utils.Optional<AvatarProfileCountAggregateOutputType> | number
          }
        }
      }
      AvatarAsset: {
        payload: Prisma.$AvatarAssetPayload<ExtArgs>
        fields: Prisma.AvatarAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvatarAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvatarAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload>
          }
          findFirst: {
            args: Prisma.AvatarAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvatarAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload>
          }
          findMany: {
            args: Prisma.AvatarAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload>[]
          }
          create: {
            args: Prisma.AvatarAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload>
          }
          createMany: {
            args: Prisma.AvatarAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvatarAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload>[]
          }
          delete: {
            args: Prisma.AvatarAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload>
          }
          update: {
            args: Prisma.AvatarAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload>
          }
          deleteMany: {
            args: Prisma.AvatarAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvatarAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvatarAssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload>[]
          }
          upsert: {
            args: Prisma.AvatarAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarAssetPayload>
          }
          aggregate: {
            args: Prisma.AvatarAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvatarAsset>
          }
          groupBy: {
            args: Prisma.AvatarAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvatarAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvatarAssetCountArgs<ExtArgs>
            result: $Utils.Optional<AvatarAssetCountAggregateOutputType> | number
          }
        }
      }
      Upload: {
        payload: Prisma.$UploadPayload<ExtArgs>
        fields: Prisma.UploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          findFirst: {
            args: Prisma.UploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          findMany: {
            args: Prisma.UploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>[]
          }
          create: {
            args: Prisma.UploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          createMany: {
            args: Prisma.UploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UploadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>[]
          }
          delete: {
            args: Prisma.UploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          update: {
            args: Prisma.UploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          deleteMany: {
            args: Prisma.UploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UploadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>[]
          }
          upsert: {
            args: Prisma.UploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadPayload>
          }
          aggregate: {
            args: Prisma.UploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpload>
          }
          groupBy: {
            args: Prisma.UploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<UploadGroupByOutputType>[]
          }
          count: {
            args: Prisma.UploadCountArgs<ExtArgs>
            result: $Utils.Optional<UploadCountAggregateOutputType> | number
          }
        }
      }
      UsageEvent: {
        payload: Prisma.$UsageEventPayload<ExtArgs>
        fields: Prisma.UsageEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload>
          }
          findFirst: {
            args: Prisma.UsageEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload>
          }
          findMany: {
            args: Prisma.UsageEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload>[]
          }
          create: {
            args: Prisma.UsageEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload>
          }
          createMany: {
            args: Prisma.UsageEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload>[]
          }
          delete: {
            args: Prisma.UsageEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload>
          }
          update: {
            args: Prisma.UsageEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload>
          }
          deleteMany: {
            args: Prisma.UsageEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload>[]
          }
          upsert: {
            args: Prisma.UsageEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageEventPayload>
          }
          aggregate: {
            args: Prisma.UsageEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageEvent>
          }
          groupBy: {
            args: Prisma.UsageEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageEventCountArgs<ExtArgs>
            result: $Utils.Optional<UsageEventCountAggregateOutputType> | number
          }
        }
      }
      SystemMetric: {
        payload: Prisma.$SystemMetricPayload<ExtArgs>
        fields: Prisma.SystemMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          findFirst: {
            args: Prisma.SystemMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          findMany: {
            args: Prisma.SystemMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>[]
          }
          create: {
            args: Prisma.SystemMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          createMany: {
            args: Prisma.SystemMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>[]
          }
          delete: {
            args: Prisma.SystemMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          update: {
            args: Prisma.SystemMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          deleteMany: {
            args: Prisma.SystemMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>[]
          }
          upsert: {
            args: Prisma.SystemMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricPayload>
          }
          aggregate: {
            args: Prisma.SystemMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemMetric>
          }
          groupBy: {
            args: Prisma.SystemMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemMetricCountArgs<ExtArgs>
            result: $Utils.Optional<SystemMetricCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      BackupSnapshot: {
        payload: Prisma.$BackupSnapshotPayload<ExtArgs>
        fields: Prisma.BackupSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackupSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackupSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload>
          }
          findFirst: {
            args: Prisma.BackupSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackupSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload>
          }
          findMany: {
            args: Prisma.BackupSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload>[]
          }
          create: {
            args: Prisma.BackupSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload>
          }
          createMany: {
            args: Prisma.BackupSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BackupSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload>[]
          }
          delete: {
            args: Prisma.BackupSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload>
          }
          update: {
            args: Prisma.BackupSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.BackupSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackupSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BackupSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.BackupSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupSnapshotPayload>
          }
          aggregate: {
            args: Prisma.BackupSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackupSnapshot>
          }
          groupBy: {
            args: Prisma.BackupSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackupSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackupSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<BackupSnapshotCountAggregateOutputType> | number
          }
        }
      }
      ConfigVersionHistory: {
        payload: Prisma.$ConfigVersionHistoryPayload<ExtArgs>
        fields: Prisma.ConfigVersionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigVersionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigVersionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload>
          }
          findFirst: {
            args: Prisma.ConfigVersionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigVersionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload>
          }
          findMany: {
            args: Prisma.ConfigVersionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload>[]
          }
          create: {
            args: Prisma.ConfigVersionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload>
          }
          createMany: {
            args: Prisma.ConfigVersionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigVersionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload>[]
          }
          delete: {
            args: Prisma.ConfigVersionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload>
          }
          update: {
            args: Prisma.ConfigVersionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ConfigVersionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigVersionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConfigVersionHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ConfigVersionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigVersionHistoryPayload>
          }
          aggregate: {
            args: Prisma.ConfigVersionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigVersionHistory>
          }
          groupBy: {
            args: Prisma.ConfigVersionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigVersionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigVersionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigVersionHistoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    adminUser?: AdminUserOmit
    ethicalConfig?: EthicalConfigOmit
    ethicalConfigVersion?: EthicalConfigVersionOmit
    roleTemplate?: RoleTemplateOmit
    culturalParameter?: CulturalParameterOmit
    relationship?: RelationshipOmit
    conversationMessage?: ConversationMessageOmit
    growthMetric?: GrowthMetricOmit
    voiceProfile?: VoiceProfileOmit
    voiceSample?: VoiceSampleOmit
    avatarProfile?: AvatarProfileOmit
    avatarAsset?: AvatarAssetOmit
    upload?: UploadOmit
    usageEvent?: UsageEventOmit
    systemMetric?: SystemMetricOmit
    auditLog?: AuditLogOmit
    backupSnapshot?: BackupSnapshotOmit
    configVersionHistory?: ConfigVersionHistoryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    relationships: number
    counterpartRels: number
    uploads: number
    usageEvents: number
    auditLogs: number
    sentMessages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationships?: boolean | UserCountOutputTypeCountRelationshipsArgs
    counterpartRels?: boolean | UserCountOutputTypeCountCounterpartRelsArgs
    uploads?: boolean | UserCountOutputTypeCountUploadsArgs
    usageEvents?: boolean | UserCountOutputTypeCountUsageEventsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCounterpartRelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMessageWhereInput
  }


  /**
   * Count Type EthicalConfigCountOutputType
   */

  export type EthicalConfigCountOutputType = {
    versions: number
    history: number
  }

  export type EthicalConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | EthicalConfigCountOutputTypeCountVersionsArgs
    history?: boolean | EthicalConfigCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * EthicalConfigCountOutputType without action
   */
  export type EthicalConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigCountOutputType
     */
    select?: EthicalConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EthicalConfigCountOutputType without action
   */
  export type EthicalConfigCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EthicalConfigVersionWhereInput
  }

  /**
   * EthicalConfigCountOutputType without action
   */
  export type EthicalConfigCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigVersionHistoryWhereInput
  }


  /**
   * Count Type RoleTemplateCountOutputType
   */

  export type RoleTemplateCountOutputType = {
    relationships: number
  }

  export type RoleTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationships?: boolean | RoleTemplateCountOutputTypeCountRelationshipsArgs
  }

  // Custom InputTypes
  /**
   * RoleTemplateCountOutputType without action
   */
  export type RoleTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateCountOutputType
     */
    select?: RoleTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleTemplateCountOutputType without action
   */
  export type RoleTemplateCountOutputTypeCountRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipWhereInput
  }


  /**
   * Count Type RelationshipCountOutputType
   */

  export type RelationshipCountOutputType = {
    messages: number
    growthMetrics: number
  }

  export type RelationshipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | RelationshipCountOutputTypeCountMessagesArgs
    growthMetrics?: boolean | RelationshipCountOutputTypeCountGrowthMetricsArgs
  }

  // Custom InputTypes
  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipCountOutputType
     */
    select?: RelationshipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMessageWhereInput
  }

  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeCountGrowthMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GrowthMetricWhereInput
  }


  /**
   * Count Type VoiceProfileCountOutputType
   */

  export type VoiceProfileCountOutputType = {
    samples: number
  }

  export type VoiceProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    samples?: boolean | VoiceProfileCountOutputTypeCountSamplesArgs
  }

  // Custom InputTypes
  /**
   * VoiceProfileCountOutputType without action
   */
  export type VoiceProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfileCountOutputType
     */
    select?: VoiceProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoiceProfileCountOutputType without action
   */
  export type VoiceProfileCountOutputTypeCountSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoiceSampleWhereInput
  }


  /**
   * Count Type AvatarProfileCountOutputType
   */

  export type AvatarProfileCountOutputType = {
    assets: number
  }

  export type AvatarProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | AvatarProfileCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * AvatarProfileCountOutputType without action
   */
  export type AvatarProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfileCountOutputType
     */
    select?: AvatarProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AvatarProfileCountOutputType without action
   */
  export type AvatarProfileCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvatarAssetWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authProvider: $Enums.AuthProvider | null
    externalId: string | null
    passwordHash: string | null
    displayName: string | null
    locale: string | null
    timezone: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authProvider: $Enums.AuthProvider | null
    externalId: string | null
    passwordHash: string | null
    displayName: string | null
    locale: string | null
    timezone: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    createdAt: number
    updatedAt: number
    authProvider: number
    externalId: number
    passwordHash: number
    displayName: number
    locale: number
    timezone: number
    preferences: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    authProvider?: true
    externalId?: true
    passwordHash?: true
    displayName?: true
    locale?: true
    timezone?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    authProvider?: true
    externalId?: true
    passwordHash?: true
    displayName?: true
    locale?: true
    timezone?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    authProvider?: true
    externalId?: true
    passwordHash?: true
    displayName?: true
    locale?: true
    timezone?: true
    preferences?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    createdAt: Date
    updatedAt: Date
    authProvider: $Enums.AuthProvider
    externalId: string | null
    passwordHash: string | null
    displayName: string | null
    locale: string | null
    timezone: string | null
    preferences: JsonValue | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProvider?: boolean
    externalId?: boolean
    passwordHash?: boolean
    displayName?: boolean
    locale?: boolean
    timezone?: boolean
    preferences?: boolean
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    relationships?: boolean | User$relationshipsArgs<ExtArgs>
    counterpartRels?: boolean | User$counterpartRelsArgs<ExtArgs>
    voiceProfile?: boolean | User$voiceProfileArgs<ExtArgs>
    avatarProfile?: boolean | User$avatarProfileArgs<ExtArgs>
    uploads?: boolean | User$uploadsArgs<ExtArgs>
    usageEvents?: boolean | User$usageEventsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProvider?: boolean
    externalId?: boolean
    passwordHash?: boolean
    displayName?: boolean
    locale?: boolean
    timezone?: boolean
    preferences?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProvider?: boolean
    externalId?: boolean
    passwordHash?: boolean
    displayName?: boolean
    locale?: boolean
    timezone?: boolean
    preferences?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authProvider?: boolean
    externalId?: boolean
    passwordHash?: boolean
    displayName?: boolean
    locale?: boolean
    timezone?: boolean
    preferences?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "createdAt" | "updatedAt" | "authProvider" | "externalId" | "passwordHash" | "displayName" | "locale" | "timezone" | "preferences", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    relationships?: boolean | User$relationshipsArgs<ExtArgs>
    counterpartRels?: boolean | User$counterpartRelsArgs<ExtArgs>
    voiceProfile?: boolean | User$voiceProfileArgs<ExtArgs>
    avatarProfile?: boolean | User$avatarProfileArgs<ExtArgs>
    uploads?: boolean | User$uploadsArgs<ExtArgs>
    usageEvents?: boolean | User$usageEventsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      adminProfile: Prisma.$AdminUserPayload<ExtArgs> | null
      relationships: Prisma.$RelationshipPayload<ExtArgs>[]
      counterpartRels: Prisma.$RelationshipPayload<ExtArgs>[]
      voiceProfile: Prisma.$VoiceProfilePayload<ExtArgs> | null
      avatarProfile: Prisma.$AvatarProfilePayload<ExtArgs> | null
      uploads: Prisma.$UploadPayload<ExtArgs>[]
      usageEvents: Prisma.$UsageEventPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      sentMessages: Prisma.$ConversationMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      createdAt: Date
      updatedAt: Date
      authProvider: $Enums.AuthProvider
      externalId: string | null
      passwordHash: string | null
      displayName: string | null
      locale: string | null
      timezone: string | null
      preferences: Prisma.JsonValue | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminProfile<T extends User$adminProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$adminProfileArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    relationships<T extends User$relationshipsArgs<ExtArgs> = {}>(args?: Subset<T, User$relationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    counterpartRels<T extends User$counterpartRelsArgs<ExtArgs> = {}>(args?: Subset<T, User$counterpartRelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voiceProfile<T extends User$voiceProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$voiceProfileArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    avatarProfile<T extends User$avatarProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$avatarProfileArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    uploads<T extends User$uploadsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageEvents<T extends User$usageEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$usageEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly authProvider: FieldRef<"User", 'AuthProvider'>
    readonly externalId: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly locale: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly preferences: FieldRef<"User", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.adminProfile
   */
  export type User$adminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    where?: AdminUserWhereInput
  }

  /**
   * User.relationships
   */
  export type User$relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    where?: RelationshipWhereInput
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    cursor?: RelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * User.counterpartRels
   */
  export type User$counterpartRelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    where?: RelationshipWhereInput
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    cursor?: RelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * User.voiceProfile
   */
  export type User$voiceProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    where?: VoiceProfileWhereInput
  }

  /**
   * User.avatarProfile
   */
  export type User$avatarProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    where?: AvatarProfileWhereInput
  }

  /**
   * User.uploads
   */
  export type User$uploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    where?: UploadWhereInput
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    cursor?: UploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * User.usageEvents
   */
  export type User$usageEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    where?: UsageEventWhereInput
    orderBy?: UsageEventOrderByWithRelationInput | UsageEventOrderByWithRelationInput[]
    cursor?: UsageEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageEventScalarFieldEnum | UsageEventScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    where?: ConversationMessageWhereInput
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    cursor?: ConversationMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AdminUser
   */

  export type AggregateAdminUser = {
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  export type AdminUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    role: $Enums.AdminRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    role: $Enums.AdminRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserCountAggregateOutputType = {
    id: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminUserMinAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserMaxAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserCountAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUser to aggregate.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUsers
    **/
    _count?: true | AdminUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUserMaxAggregateInputType
  }

  export type GetAdminUserAggregateType<T extends AdminUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUser[P]>
      : GetScalarType<T[P], AggregateAdminUser[P]>
  }




  export type AdminUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithAggregationInput | AdminUserOrderByWithAggregationInput[]
    by: AdminUserScalarFieldEnum[] | AdminUserScalarFieldEnum
    having?: AdminUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUserCountAggregateInputType | true
    _min?: AdminUserMinAggregateInputType
    _max?: AdminUserMaxAggregateInputType
  }

  export type AdminUserGroupByOutputType = {
    id: string
    userId: string
    role: $Enums.AdminRole
    createdAt: Date
    updatedAt: Date
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  type GetAdminUserGroupByPayload<T extends AdminUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
        }
      >
    >


  export type AdminUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectScalar = {
    id?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["adminUser"]>
  export type AdminUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      role: $Enums.AdminRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminUser"]>
    composites: {}
  }

  type AdminUserGetPayload<S extends boolean | null | undefined | AdminUserDefaultArgs> = $Result.GetResult<Prisma.$AdminUserPayload, S>

  type AdminUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminUserCountAggregateInputType | true
    }

  export interface AdminUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUser'], meta: { name: 'AdminUser' } }
    /**
     * Find zero or one AdminUser that matches the filter.
     * @param {AdminUserFindUniqueArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUserFindUniqueArgs>(args: SelectSubset<T, AdminUserFindUniqueArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminUserFindUniqueOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUserFindFirstArgs>(args?: SelectSubset<T, AdminUserFindFirstArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUsers
     * const adminUsers = await prisma.adminUser.findMany()
     * 
     * // Get first 10 AdminUsers
     * const adminUsers = await prisma.adminUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUserFindManyArgs>(args?: SelectSubset<T, AdminUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminUser.
     * @param {AdminUserCreateArgs} args - Arguments to create a AdminUser.
     * @example
     * // Create one AdminUser
     * const AdminUser = await prisma.adminUser.create({
     *   data: {
     *     // ... data to create a AdminUser
     *   }
     * })
     * 
     */
    create<T extends AdminUserCreateArgs>(args: SelectSubset<T, AdminUserCreateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminUsers.
     * @param {AdminUserCreateManyArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUserCreateManyArgs>(args?: SelectSubset<T, AdminUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminUsers and returns the data saved in the database.
     * @param {AdminUserCreateManyAndReturnArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminUserCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminUser.
     * @param {AdminUserDeleteArgs} args - Arguments to delete one AdminUser.
     * @example
     * // Delete one AdminUser
     * const AdminUser = await prisma.adminUser.delete({
     *   where: {
     *     // ... filter to delete one AdminUser
     *   }
     * })
     * 
     */
    delete<T extends AdminUserDeleteArgs>(args: SelectSubset<T, AdminUserDeleteArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminUser.
     * @param {AdminUserUpdateArgs} args - Arguments to update one AdminUser.
     * @example
     * // Update one AdminUser
     * const adminUser = await prisma.adminUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUserUpdateArgs>(args: SelectSubset<T, AdminUserUpdateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminUsers.
     * @param {AdminUserDeleteManyArgs} args - Arguments to filter AdminUsers to delete.
     * @example
     * // Delete a few AdminUsers
     * const { count } = await prisma.adminUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUserDeleteManyArgs>(args?: SelectSubset<T, AdminUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUserUpdateManyArgs>(args: SelectSubset<T, AdminUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers and returns the data updated in the database.
     * @param {AdminUserUpdateManyAndReturnArgs} args - Arguments to update many AdminUsers.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUserUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminUser.
     * @param {AdminUserUpsertArgs} args - Arguments to update or create a AdminUser.
     * @example
     * // Update or create a AdminUser
     * const adminUser = await prisma.adminUser.upsert({
     *   create: {
     *     // ... data to create a AdminUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUser we want to update
     *   }
     * })
     */
    upsert<T extends AdminUserUpsertArgs>(args: SelectSubset<T, AdminUserUpsertArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserCountArgs} args - Arguments to filter AdminUsers to count.
     * @example
     * // Count the number of AdminUsers
     * const count = await prisma.adminUser.count({
     *   where: {
     *     // ... the filter for the AdminUsers we want to count
     *   }
     * })
    **/
    count<T extends AdminUserCountArgs>(
      args?: Subset<T, AdminUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUserAggregateArgs>(args: Subset<T, AdminUserAggregateArgs>): Prisma.PrismaPromise<GetAdminUserAggregateType<T>>

    /**
     * Group by AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUserGroupByArgs['orderBy'] }
        : { orderBy?: AdminUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUser model
   */
  readonly fields: AdminUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUser model
   */
  interface AdminUserFieldRefs {
    readonly id: FieldRef<"AdminUser", 'String'>
    readonly userId: FieldRef<"AdminUser", 'String'>
    readonly role: FieldRef<"AdminUser", 'AdminRole'>
    readonly createdAt: FieldRef<"AdminUser", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminUser findUnique
   */
  export type AdminUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findUniqueOrThrow
   */
  export type AdminUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findFirst
   */
  export type AdminUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findFirstOrThrow
   */
  export type AdminUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findMany
   */
  export type AdminUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter, which AdminUsers to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser create
   */
  export type AdminUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminUser.
     */
    data: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
  }

  /**
   * AdminUser createMany
   */
  export type AdminUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser createManyAndReturn
   */
  export type AdminUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminUser update
   */
  export type AdminUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminUser.
     */
    data: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
    /**
     * Choose, which AdminUser to update.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser updateMany
   */
  export type AdminUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to update.
     */
    limit?: number
  }

  /**
   * AdminUser updateManyAndReturn
   */
  export type AdminUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminUser upsert
   */
  export type AdminUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminUser to update in case it exists.
     */
    where: AdminUserWhereUniqueInput
    /**
     * In case the AdminUser found by the `where` argument doesn't exist, create a new AdminUser with this data.
     */
    create: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
    /**
     * In case the AdminUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
  }

  /**
   * AdminUser delete
   */
  export type AdminUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
    /**
     * Filter which AdminUser to delete.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser deleteMany
   */
  export type AdminUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUsers to delete
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to delete.
     */
    limit?: number
  }

  /**
   * AdminUser without action
   */
  export type AdminUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminUserInclude<ExtArgs> | null
  }


  /**
   * Model EthicalConfig
   */

  export type AggregateEthicalConfig = {
    _count: EthicalConfigCountAggregateOutputType | null
    _avg: EthicalConfigAvgAggregateOutputType | null
    _sum: EthicalConfigSumAggregateOutputType | null
    _min: EthicalConfigMinAggregateOutputType | null
    _max: EthicalConfigMaxAggregateOutputType | null
  }

  export type EthicalConfigAvgAggregateOutputType = {
    latestVersion: number | null
  }

  export type EthicalConfigSumAggregateOutputType = {
    latestVersion: number | null
  }

  export type EthicalConfigMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    latestVersion: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EthicalConfigMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    latestVersion: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EthicalConfigCountAggregateOutputType = {
    id: number
    name: number
    description: number
    latestVersion: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EthicalConfigAvgAggregateInputType = {
    latestVersion?: true
  }

  export type EthicalConfigSumAggregateInputType = {
    latestVersion?: true
  }

  export type EthicalConfigMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    latestVersion?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EthicalConfigMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    latestVersion?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EthicalConfigCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    latestVersion?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EthicalConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EthicalConfig to aggregate.
     */
    where?: EthicalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EthicalConfigs to fetch.
     */
    orderBy?: EthicalConfigOrderByWithRelationInput | EthicalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EthicalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EthicalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EthicalConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EthicalConfigs
    **/
    _count?: true | EthicalConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EthicalConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EthicalConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EthicalConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EthicalConfigMaxAggregateInputType
  }

  export type GetEthicalConfigAggregateType<T extends EthicalConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateEthicalConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEthicalConfig[P]>
      : GetScalarType<T[P], AggregateEthicalConfig[P]>
  }




  export type EthicalConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EthicalConfigWhereInput
    orderBy?: EthicalConfigOrderByWithAggregationInput | EthicalConfigOrderByWithAggregationInput[]
    by: EthicalConfigScalarFieldEnum[] | EthicalConfigScalarFieldEnum
    having?: EthicalConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EthicalConfigCountAggregateInputType | true
    _avg?: EthicalConfigAvgAggregateInputType
    _sum?: EthicalConfigSumAggregateInputType
    _min?: EthicalConfigMinAggregateInputType
    _max?: EthicalConfigMaxAggregateInputType
  }

  export type EthicalConfigGroupByOutputType = {
    id: string
    name: string
    description: string | null
    latestVersion: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EthicalConfigCountAggregateOutputType | null
    _avg: EthicalConfigAvgAggregateOutputType | null
    _sum: EthicalConfigSumAggregateOutputType | null
    _min: EthicalConfigMinAggregateOutputType | null
    _max: EthicalConfigMaxAggregateOutputType | null
  }

  type GetEthicalConfigGroupByPayload<T extends EthicalConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EthicalConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EthicalConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EthicalConfigGroupByOutputType[P]>
            : GetScalarType<T[P], EthicalConfigGroupByOutputType[P]>
        }
      >
    >


  export type EthicalConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    latestVersion?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    versions?: boolean | EthicalConfig$versionsArgs<ExtArgs>
    history?: boolean | EthicalConfig$historyArgs<ExtArgs>
    _count?: boolean | EthicalConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ethicalConfig"]>

  export type EthicalConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    latestVersion?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ethicalConfig"]>

  export type EthicalConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    latestVersion?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ethicalConfig"]>

  export type EthicalConfigSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    latestVersion?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EthicalConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "latestVersion" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["ethicalConfig"]>
  export type EthicalConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | EthicalConfig$versionsArgs<ExtArgs>
    history?: boolean | EthicalConfig$historyArgs<ExtArgs>
    _count?: boolean | EthicalConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EthicalConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EthicalConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EthicalConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EthicalConfig"
    objects: {
      versions: Prisma.$EthicalConfigVersionPayload<ExtArgs>[]
      history: Prisma.$ConfigVersionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      latestVersion: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ethicalConfig"]>
    composites: {}
  }

  type EthicalConfigGetPayload<S extends boolean | null | undefined | EthicalConfigDefaultArgs> = $Result.GetResult<Prisma.$EthicalConfigPayload, S>

  type EthicalConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EthicalConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EthicalConfigCountAggregateInputType | true
    }

  export interface EthicalConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EthicalConfig'], meta: { name: 'EthicalConfig' } }
    /**
     * Find zero or one EthicalConfig that matches the filter.
     * @param {EthicalConfigFindUniqueArgs} args - Arguments to find a EthicalConfig
     * @example
     * // Get one EthicalConfig
     * const ethicalConfig = await prisma.ethicalConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EthicalConfigFindUniqueArgs>(args: SelectSubset<T, EthicalConfigFindUniqueArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EthicalConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EthicalConfigFindUniqueOrThrowArgs} args - Arguments to find a EthicalConfig
     * @example
     * // Get one EthicalConfig
     * const ethicalConfig = await prisma.ethicalConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EthicalConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, EthicalConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EthicalConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigFindFirstArgs} args - Arguments to find a EthicalConfig
     * @example
     * // Get one EthicalConfig
     * const ethicalConfig = await prisma.ethicalConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EthicalConfigFindFirstArgs>(args?: SelectSubset<T, EthicalConfigFindFirstArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EthicalConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigFindFirstOrThrowArgs} args - Arguments to find a EthicalConfig
     * @example
     * // Get one EthicalConfig
     * const ethicalConfig = await prisma.ethicalConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EthicalConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, EthicalConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EthicalConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EthicalConfigs
     * const ethicalConfigs = await prisma.ethicalConfig.findMany()
     * 
     * // Get first 10 EthicalConfigs
     * const ethicalConfigs = await prisma.ethicalConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ethicalConfigWithIdOnly = await prisma.ethicalConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EthicalConfigFindManyArgs>(args?: SelectSubset<T, EthicalConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EthicalConfig.
     * @param {EthicalConfigCreateArgs} args - Arguments to create a EthicalConfig.
     * @example
     * // Create one EthicalConfig
     * const EthicalConfig = await prisma.ethicalConfig.create({
     *   data: {
     *     // ... data to create a EthicalConfig
     *   }
     * })
     * 
     */
    create<T extends EthicalConfigCreateArgs>(args: SelectSubset<T, EthicalConfigCreateArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EthicalConfigs.
     * @param {EthicalConfigCreateManyArgs} args - Arguments to create many EthicalConfigs.
     * @example
     * // Create many EthicalConfigs
     * const ethicalConfig = await prisma.ethicalConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EthicalConfigCreateManyArgs>(args?: SelectSubset<T, EthicalConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EthicalConfigs and returns the data saved in the database.
     * @param {EthicalConfigCreateManyAndReturnArgs} args - Arguments to create many EthicalConfigs.
     * @example
     * // Create many EthicalConfigs
     * const ethicalConfig = await prisma.ethicalConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EthicalConfigs and only return the `id`
     * const ethicalConfigWithIdOnly = await prisma.ethicalConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EthicalConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, EthicalConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EthicalConfig.
     * @param {EthicalConfigDeleteArgs} args - Arguments to delete one EthicalConfig.
     * @example
     * // Delete one EthicalConfig
     * const EthicalConfig = await prisma.ethicalConfig.delete({
     *   where: {
     *     // ... filter to delete one EthicalConfig
     *   }
     * })
     * 
     */
    delete<T extends EthicalConfigDeleteArgs>(args: SelectSubset<T, EthicalConfigDeleteArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EthicalConfig.
     * @param {EthicalConfigUpdateArgs} args - Arguments to update one EthicalConfig.
     * @example
     * // Update one EthicalConfig
     * const ethicalConfig = await prisma.ethicalConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EthicalConfigUpdateArgs>(args: SelectSubset<T, EthicalConfigUpdateArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EthicalConfigs.
     * @param {EthicalConfigDeleteManyArgs} args - Arguments to filter EthicalConfigs to delete.
     * @example
     * // Delete a few EthicalConfigs
     * const { count } = await prisma.ethicalConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EthicalConfigDeleteManyArgs>(args?: SelectSubset<T, EthicalConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EthicalConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EthicalConfigs
     * const ethicalConfig = await prisma.ethicalConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EthicalConfigUpdateManyArgs>(args: SelectSubset<T, EthicalConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EthicalConfigs and returns the data updated in the database.
     * @param {EthicalConfigUpdateManyAndReturnArgs} args - Arguments to update many EthicalConfigs.
     * @example
     * // Update many EthicalConfigs
     * const ethicalConfig = await prisma.ethicalConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EthicalConfigs and only return the `id`
     * const ethicalConfigWithIdOnly = await prisma.ethicalConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EthicalConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, EthicalConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EthicalConfig.
     * @param {EthicalConfigUpsertArgs} args - Arguments to update or create a EthicalConfig.
     * @example
     * // Update or create a EthicalConfig
     * const ethicalConfig = await prisma.ethicalConfig.upsert({
     *   create: {
     *     // ... data to create a EthicalConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EthicalConfig we want to update
     *   }
     * })
     */
    upsert<T extends EthicalConfigUpsertArgs>(args: SelectSubset<T, EthicalConfigUpsertArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EthicalConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigCountArgs} args - Arguments to filter EthicalConfigs to count.
     * @example
     * // Count the number of EthicalConfigs
     * const count = await prisma.ethicalConfig.count({
     *   where: {
     *     // ... the filter for the EthicalConfigs we want to count
     *   }
     * })
    **/
    count<T extends EthicalConfigCountArgs>(
      args?: Subset<T, EthicalConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EthicalConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EthicalConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EthicalConfigAggregateArgs>(args: Subset<T, EthicalConfigAggregateArgs>): Prisma.PrismaPromise<GetEthicalConfigAggregateType<T>>

    /**
     * Group by EthicalConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EthicalConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EthicalConfigGroupByArgs['orderBy'] }
        : { orderBy?: EthicalConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EthicalConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEthicalConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EthicalConfig model
   */
  readonly fields: EthicalConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EthicalConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EthicalConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    versions<T extends EthicalConfig$versionsArgs<ExtArgs> = {}>(args?: Subset<T, EthicalConfig$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends EthicalConfig$historyArgs<ExtArgs> = {}>(args?: Subset<T, EthicalConfig$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EthicalConfig model
   */
  interface EthicalConfigFieldRefs {
    readonly id: FieldRef<"EthicalConfig", 'String'>
    readonly name: FieldRef<"EthicalConfig", 'String'>
    readonly description: FieldRef<"EthicalConfig", 'String'>
    readonly latestVersion: FieldRef<"EthicalConfig", 'Int'>
    readonly isActive: FieldRef<"EthicalConfig", 'Boolean'>
    readonly createdAt: FieldRef<"EthicalConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"EthicalConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EthicalConfig findUnique
   */
  export type EthicalConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfig to fetch.
     */
    where: EthicalConfigWhereUniqueInput
  }

  /**
   * EthicalConfig findUniqueOrThrow
   */
  export type EthicalConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfig to fetch.
     */
    where: EthicalConfigWhereUniqueInput
  }

  /**
   * EthicalConfig findFirst
   */
  export type EthicalConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfig to fetch.
     */
    where?: EthicalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EthicalConfigs to fetch.
     */
    orderBy?: EthicalConfigOrderByWithRelationInput | EthicalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EthicalConfigs.
     */
    cursor?: EthicalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EthicalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EthicalConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EthicalConfigs.
     */
    distinct?: EthicalConfigScalarFieldEnum | EthicalConfigScalarFieldEnum[]
  }

  /**
   * EthicalConfig findFirstOrThrow
   */
  export type EthicalConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfig to fetch.
     */
    where?: EthicalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EthicalConfigs to fetch.
     */
    orderBy?: EthicalConfigOrderByWithRelationInput | EthicalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EthicalConfigs.
     */
    cursor?: EthicalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EthicalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EthicalConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EthicalConfigs.
     */
    distinct?: EthicalConfigScalarFieldEnum | EthicalConfigScalarFieldEnum[]
  }

  /**
   * EthicalConfig findMany
   */
  export type EthicalConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfigs to fetch.
     */
    where?: EthicalConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EthicalConfigs to fetch.
     */
    orderBy?: EthicalConfigOrderByWithRelationInput | EthicalConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EthicalConfigs.
     */
    cursor?: EthicalConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EthicalConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EthicalConfigs.
     */
    skip?: number
    distinct?: EthicalConfigScalarFieldEnum | EthicalConfigScalarFieldEnum[]
  }

  /**
   * EthicalConfig create
   */
  export type EthicalConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a EthicalConfig.
     */
    data: XOR<EthicalConfigCreateInput, EthicalConfigUncheckedCreateInput>
  }

  /**
   * EthicalConfig createMany
   */
  export type EthicalConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EthicalConfigs.
     */
    data: EthicalConfigCreateManyInput | EthicalConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EthicalConfig createManyAndReturn
   */
  export type EthicalConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * The data used to create many EthicalConfigs.
     */
    data: EthicalConfigCreateManyInput | EthicalConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EthicalConfig update
   */
  export type EthicalConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a EthicalConfig.
     */
    data: XOR<EthicalConfigUpdateInput, EthicalConfigUncheckedUpdateInput>
    /**
     * Choose, which EthicalConfig to update.
     */
    where: EthicalConfigWhereUniqueInput
  }

  /**
   * EthicalConfig updateMany
   */
  export type EthicalConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EthicalConfigs.
     */
    data: XOR<EthicalConfigUpdateManyMutationInput, EthicalConfigUncheckedUpdateManyInput>
    /**
     * Filter which EthicalConfigs to update
     */
    where?: EthicalConfigWhereInput
    /**
     * Limit how many EthicalConfigs to update.
     */
    limit?: number
  }

  /**
   * EthicalConfig updateManyAndReturn
   */
  export type EthicalConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * The data used to update EthicalConfigs.
     */
    data: XOR<EthicalConfigUpdateManyMutationInput, EthicalConfigUncheckedUpdateManyInput>
    /**
     * Filter which EthicalConfigs to update
     */
    where?: EthicalConfigWhereInput
    /**
     * Limit how many EthicalConfigs to update.
     */
    limit?: number
  }

  /**
   * EthicalConfig upsert
   */
  export type EthicalConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the EthicalConfig to update in case it exists.
     */
    where: EthicalConfigWhereUniqueInput
    /**
     * In case the EthicalConfig found by the `where` argument doesn't exist, create a new EthicalConfig with this data.
     */
    create: XOR<EthicalConfigCreateInput, EthicalConfigUncheckedCreateInput>
    /**
     * In case the EthicalConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EthicalConfigUpdateInput, EthicalConfigUncheckedUpdateInput>
  }

  /**
   * EthicalConfig delete
   */
  export type EthicalConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
    /**
     * Filter which EthicalConfig to delete.
     */
    where: EthicalConfigWhereUniqueInput
  }

  /**
   * EthicalConfig deleteMany
   */
  export type EthicalConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EthicalConfigs to delete
     */
    where?: EthicalConfigWhereInput
    /**
     * Limit how many EthicalConfigs to delete.
     */
    limit?: number
  }

  /**
   * EthicalConfig.versions
   */
  export type EthicalConfig$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    where?: EthicalConfigVersionWhereInput
    orderBy?: EthicalConfigVersionOrderByWithRelationInput | EthicalConfigVersionOrderByWithRelationInput[]
    cursor?: EthicalConfigVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EthicalConfigVersionScalarFieldEnum | EthicalConfigVersionScalarFieldEnum[]
  }

  /**
   * EthicalConfig.history
   */
  export type EthicalConfig$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    where?: ConfigVersionHistoryWhereInput
    orderBy?: ConfigVersionHistoryOrderByWithRelationInput | ConfigVersionHistoryOrderByWithRelationInput[]
    cursor?: ConfigVersionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigVersionHistoryScalarFieldEnum | ConfigVersionHistoryScalarFieldEnum[]
  }

  /**
   * EthicalConfig without action
   */
  export type EthicalConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfig
     */
    select?: EthicalConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfig
     */
    omit?: EthicalConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigInclude<ExtArgs> | null
  }


  /**
   * Model EthicalConfigVersion
   */

  export type AggregateEthicalConfigVersion = {
    _count: EthicalConfigVersionCountAggregateOutputType | null
    _avg: EthicalConfigVersionAvgAggregateOutputType | null
    _sum: EthicalConfigVersionSumAggregateOutputType | null
    _min: EthicalConfigVersionMinAggregateOutputType | null
    _max: EthicalConfigVersionMaxAggregateOutputType | null
  }

  export type EthicalConfigVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type EthicalConfigVersionSumAggregateOutputType = {
    version: number | null
  }

  export type EthicalConfigVersionMinAggregateOutputType = {
    id: string | null
    configId: string | null
    version: number | null
    createdAt: Date | null
    createdById: string | null
  }

  export type EthicalConfigVersionMaxAggregateOutputType = {
    id: string | null
    configId: string | null
    version: number | null
    createdAt: Date | null
    createdById: string | null
  }

  export type EthicalConfigVersionCountAggregateOutputType = {
    id: number
    configId: number
    version: number
    data: number
    createdAt: number
    createdById: number
    _all: number
  }


  export type EthicalConfigVersionAvgAggregateInputType = {
    version?: true
  }

  export type EthicalConfigVersionSumAggregateInputType = {
    version?: true
  }

  export type EthicalConfigVersionMinAggregateInputType = {
    id?: true
    configId?: true
    version?: true
    createdAt?: true
    createdById?: true
  }

  export type EthicalConfigVersionMaxAggregateInputType = {
    id?: true
    configId?: true
    version?: true
    createdAt?: true
    createdById?: true
  }

  export type EthicalConfigVersionCountAggregateInputType = {
    id?: true
    configId?: true
    version?: true
    data?: true
    createdAt?: true
    createdById?: true
    _all?: true
  }

  export type EthicalConfigVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EthicalConfigVersion to aggregate.
     */
    where?: EthicalConfigVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EthicalConfigVersions to fetch.
     */
    orderBy?: EthicalConfigVersionOrderByWithRelationInput | EthicalConfigVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EthicalConfigVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EthicalConfigVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EthicalConfigVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EthicalConfigVersions
    **/
    _count?: true | EthicalConfigVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EthicalConfigVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EthicalConfigVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EthicalConfigVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EthicalConfigVersionMaxAggregateInputType
  }

  export type GetEthicalConfigVersionAggregateType<T extends EthicalConfigVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateEthicalConfigVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEthicalConfigVersion[P]>
      : GetScalarType<T[P], AggregateEthicalConfigVersion[P]>
  }




  export type EthicalConfigVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EthicalConfigVersionWhereInput
    orderBy?: EthicalConfigVersionOrderByWithAggregationInput | EthicalConfigVersionOrderByWithAggregationInput[]
    by: EthicalConfigVersionScalarFieldEnum[] | EthicalConfigVersionScalarFieldEnum
    having?: EthicalConfigVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EthicalConfigVersionCountAggregateInputType | true
    _avg?: EthicalConfigVersionAvgAggregateInputType
    _sum?: EthicalConfigVersionSumAggregateInputType
    _min?: EthicalConfigVersionMinAggregateInputType
    _max?: EthicalConfigVersionMaxAggregateInputType
  }

  export type EthicalConfigVersionGroupByOutputType = {
    id: string
    configId: string
    version: number
    data: JsonValue
    createdAt: Date
    createdById: string | null
    _count: EthicalConfigVersionCountAggregateOutputType | null
    _avg: EthicalConfigVersionAvgAggregateOutputType | null
    _sum: EthicalConfigVersionSumAggregateOutputType | null
    _min: EthicalConfigVersionMinAggregateOutputType | null
    _max: EthicalConfigVersionMaxAggregateOutputType | null
  }

  type GetEthicalConfigVersionGroupByPayload<T extends EthicalConfigVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EthicalConfigVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EthicalConfigVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EthicalConfigVersionGroupByOutputType[P]>
            : GetScalarType<T[P], EthicalConfigVersionGroupByOutputType[P]>
        }
      >
    >


  export type EthicalConfigVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configId?: boolean
    version?: boolean
    data?: boolean
    createdAt?: boolean
    createdById?: boolean
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ethicalConfigVersion"]>

  export type EthicalConfigVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configId?: boolean
    version?: boolean
    data?: boolean
    createdAt?: boolean
    createdById?: boolean
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ethicalConfigVersion"]>

  export type EthicalConfigVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configId?: boolean
    version?: boolean
    data?: boolean
    createdAt?: boolean
    createdById?: boolean
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ethicalConfigVersion"]>

  export type EthicalConfigVersionSelectScalar = {
    id?: boolean
    configId?: boolean
    version?: boolean
    data?: boolean
    createdAt?: boolean
    createdById?: boolean
  }

  export type EthicalConfigVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "configId" | "version" | "data" | "createdAt" | "createdById", ExtArgs["result"]["ethicalConfigVersion"]>
  export type EthicalConfigVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }
  export type EthicalConfigVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }
  export type EthicalConfigVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }

  export type $EthicalConfigVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EthicalConfigVersion"
    objects: {
      config: Prisma.$EthicalConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      configId: string
      version: number
      data: Prisma.JsonValue
      createdAt: Date
      createdById: string | null
    }, ExtArgs["result"]["ethicalConfigVersion"]>
    composites: {}
  }

  type EthicalConfigVersionGetPayload<S extends boolean | null | undefined | EthicalConfigVersionDefaultArgs> = $Result.GetResult<Prisma.$EthicalConfigVersionPayload, S>

  type EthicalConfigVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EthicalConfigVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EthicalConfigVersionCountAggregateInputType | true
    }

  export interface EthicalConfigVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EthicalConfigVersion'], meta: { name: 'EthicalConfigVersion' } }
    /**
     * Find zero or one EthicalConfigVersion that matches the filter.
     * @param {EthicalConfigVersionFindUniqueArgs} args - Arguments to find a EthicalConfigVersion
     * @example
     * // Get one EthicalConfigVersion
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EthicalConfigVersionFindUniqueArgs>(args: SelectSubset<T, EthicalConfigVersionFindUniqueArgs<ExtArgs>>): Prisma__EthicalConfigVersionClient<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EthicalConfigVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EthicalConfigVersionFindUniqueOrThrowArgs} args - Arguments to find a EthicalConfigVersion
     * @example
     * // Get one EthicalConfigVersion
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EthicalConfigVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, EthicalConfigVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EthicalConfigVersionClient<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EthicalConfigVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigVersionFindFirstArgs} args - Arguments to find a EthicalConfigVersion
     * @example
     * // Get one EthicalConfigVersion
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EthicalConfigVersionFindFirstArgs>(args?: SelectSubset<T, EthicalConfigVersionFindFirstArgs<ExtArgs>>): Prisma__EthicalConfigVersionClient<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EthicalConfigVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigVersionFindFirstOrThrowArgs} args - Arguments to find a EthicalConfigVersion
     * @example
     * // Get one EthicalConfigVersion
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EthicalConfigVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, EthicalConfigVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EthicalConfigVersionClient<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EthicalConfigVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EthicalConfigVersions
     * const ethicalConfigVersions = await prisma.ethicalConfigVersion.findMany()
     * 
     * // Get first 10 EthicalConfigVersions
     * const ethicalConfigVersions = await prisma.ethicalConfigVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ethicalConfigVersionWithIdOnly = await prisma.ethicalConfigVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EthicalConfigVersionFindManyArgs>(args?: SelectSubset<T, EthicalConfigVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EthicalConfigVersion.
     * @param {EthicalConfigVersionCreateArgs} args - Arguments to create a EthicalConfigVersion.
     * @example
     * // Create one EthicalConfigVersion
     * const EthicalConfigVersion = await prisma.ethicalConfigVersion.create({
     *   data: {
     *     // ... data to create a EthicalConfigVersion
     *   }
     * })
     * 
     */
    create<T extends EthicalConfigVersionCreateArgs>(args: SelectSubset<T, EthicalConfigVersionCreateArgs<ExtArgs>>): Prisma__EthicalConfigVersionClient<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EthicalConfigVersions.
     * @param {EthicalConfigVersionCreateManyArgs} args - Arguments to create many EthicalConfigVersions.
     * @example
     * // Create many EthicalConfigVersions
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EthicalConfigVersionCreateManyArgs>(args?: SelectSubset<T, EthicalConfigVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EthicalConfigVersions and returns the data saved in the database.
     * @param {EthicalConfigVersionCreateManyAndReturnArgs} args - Arguments to create many EthicalConfigVersions.
     * @example
     * // Create many EthicalConfigVersions
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EthicalConfigVersions and only return the `id`
     * const ethicalConfigVersionWithIdOnly = await prisma.ethicalConfigVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EthicalConfigVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, EthicalConfigVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EthicalConfigVersion.
     * @param {EthicalConfigVersionDeleteArgs} args - Arguments to delete one EthicalConfigVersion.
     * @example
     * // Delete one EthicalConfigVersion
     * const EthicalConfigVersion = await prisma.ethicalConfigVersion.delete({
     *   where: {
     *     // ... filter to delete one EthicalConfigVersion
     *   }
     * })
     * 
     */
    delete<T extends EthicalConfigVersionDeleteArgs>(args: SelectSubset<T, EthicalConfigVersionDeleteArgs<ExtArgs>>): Prisma__EthicalConfigVersionClient<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EthicalConfigVersion.
     * @param {EthicalConfigVersionUpdateArgs} args - Arguments to update one EthicalConfigVersion.
     * @example
     * // Update one EthicalConfigVersion
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EthicalConfigVersionUpdateArgs>(args: SelectSubset<T, EthicalConfigVersionUpdateArgs<ExtArgs>>): Prisma__EthicalConfigVersionClient<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EthicalConfigVersions.
     * @param {EthicalConfigVersionDeleteManyArgs} args - Arguments to filter EthicalConfigVersions to delete.
     * @example
     * // Delete a few EthicalConfigVersions
     * const { count } = await prisma.ethicalConfigVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EthicalConfigVersionDeleteManyArgs>(args?: SelectSubset<T, EthicalConfigVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EthicalConfigVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EthicalConfigVersions
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EthicalConfigVersionUpdateManyArgs>(args: SelectSubset<T, EthicalConfigVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EthicalConfigVersions and returns the data updated in the database.
     * @param {EthicalConfigVersionUpdateManyAndReturnArgs} args - Arguments to update many EthicalConfigVersions.
     * @example
     * // Update many EthicalConfigVersions
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EthicalConfigVersions and only return the `id`
     * const ethicalConfigVersionWithIdOnly = await prisma.ethicalConfigVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EthicalConfigVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, EthicalConfigVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EthicalConfigVersion.
     * @param {EthicalConfigVersionUpsertArgs} args - Arguments to update or create a EthicalConfigVersion.
     * @example
     * // Update or create a EthicalConfigVersion
     * const ethicalConfigVersion = await prisma.ethicalConfigVersion.upsert({
     *   create: {
     *     // ... data to create a EthicalConfigVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EthicalConfigVersion we want to update
     *   }
     * })
     */
    upsert<T extends EthicalConfigVersionUpsertArgs>(args: SelectSubset<T, EthicalConfigVersionUpsertArgs<ExtArgs>>): Prisma__EthicalConfigVersionClient<$Result.GetResult<Prisma.$EthicalConfigVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EthicalConfigVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigVersionCountArgs} args - Arguments to filter EthicalConfigVersions to count.
     * @example
     * // Count the number of EthicalConfigVersions
     * const count = await prisma.ethicalConfigVersion.count({
     *   where: {
     *     // ... the filter for the EthicalConfigVersions we want to count
     *   }
     * })
    **/
    count<T extends EthicalConfigVersionCountArgs>(
      args?: Subset<T, EthicalConfigVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EthicalConfigVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EthicalConfigVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EthicalConfigVersionAggregateArgs>(args: Subset<T, EthicalConfigVersionAggregateArgs>): Prisma.PrismaPromise<GetEthicalConfigVersionAggregateType<T>>

    /**
     * Group by EthicalConfigVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EthicalConfigVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EthicalConfigVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EthicalConfigVersionGroupByArgs['orderBy'] }
        : { orderBy?: EthicalConfigVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EthicalConfigVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEthicalConfigVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EthicalConfigVersion model
   */
  readonly fields: EthicalConfigVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EthicalConfigVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EthicalConfigVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    config<T extends EthicalConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EthicalConfigDefaultArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EthicalConfigVersion model
   */
  interface EthicalConfigVersionFieldRefs {
    readonly id: FieldRef<"EthicalConfigVersion", 'String'>
    readonly configId: FieldRef<"EthicalConfigVersion", 'String'>
    readonly version: FieldRef<"EthicalConfigVersion", 'Int'>
    readonly data: FieldRef<"EthicalConfigVersion", 'Json'>
    readonly createdAt: FieldRef<"EthicalConfigVersion", 'DateTime'>
    readonly createdById: FieldRef<"EthicalConfigVersion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EthicalConfigVersion findUnique
   */
  export type EthicalConfigVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfigVersion to fetch.
     */
    where: EthicalConfigVersionWhereUniqueInput
  }

  /**
   * EthicalConfigVersion findUniqueOrThrow
   */
  export type EthicalConfigVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfigVersion to fetch.
     */
    where: EthicalConfigVersionWhereUniqueInput
  }

  /**
   * EthicalConfigVersion findFirst
   */
  export type EthicalConfigVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfigVersion to fetch.
     */
    where?: EthicalConfigVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EthicalConfigVersions to fetch.
     */
    orderBy?: EthicalConfigVersionOrderByWithRelationInput | EthicalConfigVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EthicalConfigVersions.
     */
    cursor?: EthicalConfigVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EthicalConfigVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EthicalConfigVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EthicalConfigVersions.
     */
    distinct?: EthicalConfigVersionScalarFieldEnum | EthicalConfigVersionScalarFieldEnum[]
  }

  /**
   * EthicalConfigVersion findFirstOrThrow
   */
  export type EthicalConfigVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfigVersion to fetch.
     */
    where?: EthicalConfigVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EthicalConfigVersions to fetch.
     */
    orderBy?: EthicalConfigVersionOrderByWithRelationInput | EthicalConfigVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EthicalConfigVersions.
     */
    cursor?: EthicalConfigVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EthicalConfigVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EthicalConfigVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EthicalConfigVersions.
     */
    distinct?: EthicalConfigVersionScalarFieldEnum | EthicalConfigVersionScalarFieldEnum[]
  }

  /**
   * EthicalConfigVersion findMany
   */
  export type EthicalConfigVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    /**
     * Filter, which EthicalConfigVersions to fetch.
     */
    where?: EthicalConfigVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EthicalConfigVersions to fetch.
     */
    orderBy?: EthicalConfigVersionOrderByWithRelationInput | EthicalConfigVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EthicalConfigVersions.
     */
    cursor?: EthicalConfigVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EthicalConfigVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EthicalConfigVersions.
     */
    skip?: number
    distinct?: EthicalConfigVersionScalarFieldEnum | EthicalConfigVersionScalarFieldEnum[]
  }

  /**
   * EthicalConfigVersion create
   */
  export type EthicalConfigVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a EthicalConfigVersion.
     */
    data: XOR<EthicalConfigVersionCreateInput, EthicalConfigVersionUncheckedCreateInput>
  }

  /**
   * EthicalConfigVersion createMany
   */
  export type EthicalConfigVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EthicalConfigVersions.
     */
    data: EthicalConfigVersionCreateManyInput | EthicalConfigVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EthicalConfigVersion createManyAndReturn
   */
  export type EthicalConfigVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * The data used to create many EthicalConfigVersions.
     */
    data: EthicalConfigVersionCreateManyInput | EthicalConfigVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EthicalConfigVersion update
   */
  export type EthicalConfigVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a EthicalConfigVersion.
     */
    data: XOR<EthicalConfigVersionUpdateInput, EthicalConfigVersionUncheckedUpdateInput>
    /**
     * Choose, which EthicalConfigVersion to update.
     */
    where: EthicalConfigVersionWhereUniqueInput
  }

  /**
   * EthicalConfigVersion updateMany
   */
  export type EthicalConfigVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EthicalConfigVersions.
     */
    data: XOR<EthicalConfigVersionUpdateManyMutationInput, EthicalConfigVersionUncheckedUpdateManyInput>
    /**
     * Filter which EthicalConfigVersions to update
     */
    where?: EthicalConfigVersionWhereInput
    /**
     * Limit how many EthicalConfigVersions to update.
     */
    limit?: number
  }

  /**
   * EthicalConfigVersion updateManyAndReturn
   */
  export type EthicalConfigVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * The data used to update EthicalConfigVersions.
     */
    data: XOR<EthicalConfigVersionUpdateManyMutationInput, EthicalConfigVersionUncheckedUpdateManyInput>
    /**
     * Filter which EthicalConfigVersions to update
     */
    where?: EthicalConfigVersionWhereInput
    /**
     * Limit how many EthicalConfigVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EthicalConfigVersion upsert
   */
  export type EthicalConfigVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the EthicalConfigVersion to update in case it exists.
     */
    where: EthicalConfigVersionWhereUniqueInput
    /**
     * In case the EthicalConfigVersion found by the `where` argument doesn't exist, create a new EthicalConfigVersion with this data.
     */
    create: XOR<EthicalConfigVersionCreateInput, EthicalConfigVersionUncheckedCreateInput>
    /**
     * In case the EthicalConfigVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EthicalConfigVersionUpdateInput, EthicalConfigVersionUncheckedUpdateInput>
  }

  /**
   * EthicalConfigVersion delete
   */
  export type EthicalConfigVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
    /**
     * Filter which EthicalConfigVersion to delete.
     */
    where: EthicalConfigVersionWhereUniqueInput
  }

  /**
   * EthicalConfigVersion deleteMany
   */
  export type EthicalConfigVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EthicalConfigVersions to delete
     */
    where?: EthicalConfigVersionWhereInput
    /**
     * Limit how many EthicalConfigVersions to delete.
     */
    limit?: number
  }

  /**
   * EthicalConfigVersion without action
   */
  export type EthicalConfigVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EthicalConfigVersion
     */
    select?: EthicalConfigVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EthicalConfigVersion
     */
    omit?: EthicalConfigVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EthicalConfigVersionInclude<ExtArgs> | null
  }


  /**
   * Model RoleTemplate
   */

  export type AggregateRoleTemplate = {
    _count: RoleTemplateCountAggregateOutputType | null
    _min: RoleTemplateMinAggregateOutputType | null
    _max: RoleTemplateMaxAggregateOutputType | null
  }

  export type RoleTemplateMinAggregateOutputType = {
    id: string | null
    type: $Enums.RelationshipRoleTemplateType | null
    key: string | null
    displayName: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateMaxAggregateOutputType = {
    id: string | null
    type: $Enums.RelationshipRoleTemplateType | null
    key: string | null
    displayName: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateCountAggregateOutputType = {
    id: number
    type: number
    key: number
    displayName: number
    description: number
    defaultSettings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleTemplateMinAggregateInputType = {
    id?: true
    type?: true
    key?: true
    displayName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateMaxAggregateInputType = {
    id?: true
    type?: true
    key?: true
    displayName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateCountAggregateInputType = {
    id?: true
    type?: true
    key?: true
    displayName?: true
    description?: true
    defaultSettings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplate to aggregate.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleTemplates
    **/
    _count?: true | RoleTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleTemplateMaxAggregateInputType
  }

  export type GetRoleTemplateAggregateType<T extends RoleTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleTemplate[P]>
      : GetScalarType<T[P], AggregateRoleTemplate[P]>
  }




  export type RoleTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplateWhereInput
    orderBy?: RoleTemplateOrderByWithAggregationInput | RoleTemplateOrderByWithAggregationInput[]
    by: RoleTemplateScalarFieldEnum[] | RoleTemplateScalarFieldEnum
    having?: RoleTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleTemplateCountAggregateInputType | true
    _min?: RoleTemplateMinAggregateInputType
    _max?: RoleTemplateMaxAggregateInputType
  }

  export type RoleTemplateGroupByOutputType = {
    id: string
    type: $Enums.RelationshipRoleTemplateType
    key: string
    displayName: string
    description: string | null
    defaultSettings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RoleTemplateCountAggregateOutputType | null
    _min: RoleTemplateMinAggregateOutputType | null
    _max: RoleTemplateMaxAggregateOutputType | null
  }

  type GetRoleTemplateGroupByPayload<T extends RoleTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], RoleTemplateGroupByOutputType[P]>
        }
      >
    >


  export type RoleTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    key?: boolean
    displayName?: boolean
    description?: boolean
    defaultSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationships?: boolean | RoleTemplate$relationshipsArgs<ExtArgs>
    _count?: boolean | RoleTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplate"]>

  export type RoleTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    key?: boolean
    displayName?: boolean
    description?: boolean
    defaultSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["roleTemplate"]>

  export type RoleTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    key?: boolean
    displayName?: boolean
    description?: boolean
    defaultSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["roleTemplate"]>

  export type RoleTemplateSelectScalar = {
    id?: boolean
    type?: boolean
    key?: boolean
    displayName?: boolean
    description?: boolean
    defaultSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "key" | "displayName" | "description" | "defaultSettings" | "createdAt" | "updatedAt", ExtArgs["result"]["roleTemplate"]>
  export type RoleTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationships?: boolean | RoleTemplate$relationshipsArgs<ExtArgs>
    _count?: boolean | RoleTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoleTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleTemplate"
    objects: {
      relationships: Prisma.$RelationshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.RelationshipRoleTemplateType
      key: string
      displayName: string
      description: string | null
      defaultSettings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleTemplate"]>
    composites: {}
  }

  type RoleTemplateGetPayload<S extends boolean | null | undefined | RoleTemplateDefaultArgs> = $Result.GetResult<Prisma.$RoleTemplatePayload, S>

  type RoleTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleTemplateCountAggregateInputType | true
    }

  export interface RoleTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleTemplate'], meta: { name: 'RoleTemplate' } }
    /**
     * Find zero or one RoleTemplate that matches the filter.
     * @param {RoleTemplateFindUniqueArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleTemplateFindUniqueArgs>(args: SelectSubset<T, RoleTemplateFindUniqueArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleTemplateFindUniqueOrThrowArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateFindFirstArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleTemplateFindFirstArgs>(args?: SelectSubset<T, RoleTemplateFindFirstArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateFindFirstOrThrowArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleTemplates
     * const roleTemplates = await prisma.roleTemplate.findMany()
     * 
     * // Get first 10 RoleTemplates
     * const roleTemplates = await prisma.roleTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleTemplateWithIdOnly = await prisma.roleTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleTemplateFindManyArgs>(args?: SelectSubset<T, RoleTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleTemplate.
     * @param {RoleTemplateCreateArgs} args - Arguments to create a RoleTemplate.
     * @example
     * // Create one RoleTemplate
     * const RoleTemplate = await prisma.roleTemplate.create({
     *   data: {
     *     // ... data to create a RoleTemplate
     *   }
     * })
     * 
     */
    create<T extends RoleTemplateCreateArgs>(args: SelectSubset<T, RoleTemplateCreateArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleTemplates.
     * @param {RoleTemplateCreateManyArgs} args - Arguments to create many RoleTemplates.
     * @example
     * // Create many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleTemplateCreateManyArgs>(args?: SelectSubset<T, RoleTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleTemplates and returns the data saved in the database.
     * @param {RoleTemplateCreateManyAndReturnArgs} args - Arguments to create many RoleTemplates.
     * @example
     * // Create many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleTemplates and only return the `id`
     * const roleTemplateWithIdOnly = await prisma.roleTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoleTemplate.
     * @param {RoleTemplateDeleteArgs} args - Arguments to delete one RoleTemplate.
     * @example
     * // Delete one RoleTemplate
     * const RoleTemplate = await prisma.roleTemplate.delete({
     *   where: {
     *     // ... filter to delete one RoleTemplate
     *   }
     * })
     * 
     */
    delete<T extends RoleTemplateDeleteArgs>(args: SelectSubset<T, RoleTemplateDeleteArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleTemplate.
     * @param {RoleTemplateUpdateArgs} args - Arguments to update one RoleTemplate.
     * @example
     * // Update one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleTemplateUpdateArgs>(args: SelectSubset<T, RoleTemplateUpdateArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleTemplates.
     * @param {RoleTemplateDeleteManyArgs} args - Arguments to filter RoleTemplates to delete.
     * @example
     * // Delete a few RoleTemplates
     * const { count } = await prisma.roleTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleTemplateDeleteManyArgs>(args?: SelectSubset<T, RoleTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleTemplateUpdateManyArgs>(args: SelectSubset<T, RoleTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleTemplates and returns the data updated in the database.
     * @param {RoleTemplateUpdateManyAndReturnArgs} args - Arguments to update many RoleTemplates.
     * @example
     * // Update many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoleTemplates and only return the `id`
     * const roleTemplateWithIdOnly = await prisma.roleTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoleTemplate.
     * @param {RoleTemplateUpsertArgs} args - Arguments to update or create a RoleTemplate.
     * @example
     * // Update or create a RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.upsert({
     *   create: {
     *     // ... data to create a RoleTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleTemplate we want to update
     *   }
     * })
     */
    upsert<T extends RoleTemplateUpsertArgs>(args: SelectSubset<T, RoleTemplateUpsertArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateCountArgs} args - Arguments to filter RoleTemplates to count.
     * @example
     * // Count the number of RoleTemplates
     * const count = await prisma.roleTemplate.count({
     *   where: {
     *     // ... the filter for the RoleTemplates we want to count
     *   }
     * })
    **/
    count<T extends RoleTemplateCountArgs>(
      args?: Subset<T, RoleTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleTemplateAggregateArgs>(args: Subset<T, RoleTemplateAggregateArgs>): Prisma.PrismaPromise<GetRoleTemplateAggregateType<T>>

    /**
     * Group by RoleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleTemplateGroupByArgs['orderBy'] }
        : { orderBy?: RoleTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleTemplate model
   */
  readonly fields: RoleTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationships<T extends RoleTemplate$relationshipsArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplate$relationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleTemplate model
   */
  interface RoleTemplateFieldRefs {
    readonly id: FieldRef<"RoleTemplate", 'String'>
    readonly type: FieldRef<"RoleTemplate", 'RelationshipRoleTemplateType'>
    readonly key: FieldRef<"RoleTemplate", 'String'>
    readonly displayName: FieldRef<"RoleTemplate", 'String'>
    readonly description: FieldRef<"RoleTemplate", 'String'>
    readonly defaultSettings: FieldRef<"RoleTemplate", 'Json'>
    readonly createdAt: FieldRef<"RoleTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleTemplate findUnique
   */
  export type RoleTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate findUniqueOrThrow
   */
  export type RoleTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate findFirst
   */
  export type RoleTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplates.
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplates.
     */
    distinct?: RoleTemplateScalarFieldEnum | RoleTemplateScalarFieldEnum[]
  }

  /**
   * RoleTemplate findFirstOrThrow
   */
  export type RoleTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplates.
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplates.
     */
    distinct?: RoleTemplateScalarFieldEnum | RoleTemplateScalarFieldEnum[]
  }

  /**
   * RoleTemplate findMany
   */
  export type RoleTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplates to fetch.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleTemplates.
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    distinct?: RoleTemplateScalarFieldEnum | RoleTemplateScalarFieldEnum[]
  }

  /**
   * RoleTemplate create
   */
  export type RoleTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleTemplate.
     */
    data: XOR<RoleTemplateCreateInput, RoleTemplateUncheckedCreateInput>
  }

  /**
   * RoleTemplate createMany
   */
  export type RoleTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleTemplates.
     */
    data: RoleTemplateCreateManyInput | RoleTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplate createManyAndReturn
   */
  export type RoleTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many RoleTemplates.
     */
    data: RoleTemplateCreateManyInput | RoleTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplate update
   */
  export type RoleTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleTemplate.
     */
    data: XOR<RoleTemplateUpdateInput, RoleTemplateUncheckedUpdateInput>
    /**
     * Choose, which RoleTemplate to update.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate updateMany
   */
  export type RoleTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleTemplates.
     */
    data: XOR<RoleTemplateUpdateManyMutationInput, RoleTemplateUncheckedUpdateManyInput>
    /**
     * Filter which RoleTemplates to update
     */
    where?: RoleTemplateWhereInput
    /**
     * Limit how many RoleTemplates to update.
     */
    limit?: number
  }

  /**
   * RoleTemplate updateManyAndReturn
   */
  export type RoleTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * The data used to update RoleTemplates.
     */
    data: XOR<RoleTemplateUpdateManyMutationInput, RoleTemplateUncheckedUpdateManyInput>
    /**
     * Filter which RoleTemplates to update
     */
    where?: RoleTemplateWhereInput
    /**
     * Limit how many RoleTemplates to update.
     */
    limit?: number
  }

  /**
   * RoleTemplate upsert
   */
  export type RoleTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleTemplate to update in case it exists.
     */
    where: RoleTemplateWhereUniqueInput
    /**
     * In case the RoleTemplate found by the `where` argument doesn't exist, create a new RoleTemplate with this data.
     */
    create: XOR<RoleTemplateCreateInput, RoleTemplateUncheckedCreateInput>
    /**
     * In case the RoleTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleTemplateUpdateInput, RoleTemplateUncheckedUpdateInput>
  }

  /**
   * RoleTemplate delete
   */
  export type RoleTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter which RoleTemplate to delete.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate deleteMany
   */
  export type RoleTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplates to delete
     */
    where?: RoleTemplateWhereInput
    /**
     * Limit how many RoleTemplates to delete.
     */
    limit?: number
  }

  /**
   * RoleTemplate.relationships
   */
  export type RoleTemplate$relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    where?: RelationshipWhereInput
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    cursor?: RelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * RoleTemplate without action
   */
  export type RoleTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
  }


  /**
   * Model CulturalParameter
   */

  export type AggregateCulturalParameter = {
    _count: CulturalParameterCountAggregateOutputType | null
    _min: CulturalParameterMinAggregateOutputType | null
    _max: CulturalParameterMaxAggregateOutputType | null
  }

  export type CulturalParameterMinAggregateOutputType = {
    id: string | null
    regionCode: string | null
    cultureKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CulturalParameterMaxAggregateOutputType = {
    id: string | null
    regionCode: string | null
    cultureKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CulturalParameterCountAggregateOutputType = {
    id: number
    regionCode: number
    cultureKey: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CulturalParameterMinAggregateInputType = {
    id?: true
    regionCode?: true
    cultureKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CulturalParameterMaxAggregateInputType = {
    id?: true
    regionCode?: true
    cultureKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CulturalParameterCountAggregateInputType = {
    id?: true
    regionCode?: true
    cultureKey?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CulturalParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CulturalParameter to aggregate.
     */
    where?: CulturalParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CulturalParameters to fetch.
     */
    orderBy?: CulturalParameterOrderByWithRelationInput | CulturalParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CulturalParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CulturalParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CulturalParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CulturalParameters
    **/
    _count?: true | CulturalParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CulturalParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CulturalParameterMaxAggregateInputType
  }

  export type GetCulturalParameterAggregateType<T extends CulturalParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateCulturalParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCulturalParameter[P]>
      : GetScalarType<T[P], AggregateCulturalParameter[P]>
  }




  export type CulturalParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CulturalParameterWhereInput
    orderBy?: CulturalParameterOrderByWithAggregationInput | CulturalParameterOrderByWithAggregationInput[]
    by: CulturalParameterScalarFieldEnum[] | CulturalParameterScalarFieldEnum
    having?: CulturalParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CulturalParameterCountAggregateInputType | true
    _min?: CulturalParameterMinAggregateInputType
    _max?: CulturalParameterMaxAggregateInputType
  }

  export type CulturalParameterGroupByOutputType = {
    id: string
    regionCode: string
    cultureKey: string
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CulturalParameterCountAggregateOutputType | null
    _min: CulturalParameterMinAggregateOutputType | null
    _max: CulturalParameterMaxAggregateOutputType | null
  }

  type GetCulturalParameterGroupByPayload<T extends CulturalParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CulturalParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CulturalParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CulturalParameterGroupByOutputType[P]>
            : GetScalarType<T[P], CulturalParameterGroupByOutputType[P]>
        }
      >
    >


  export type CulturalParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionCode?: boolean
    cultureKey?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["culturalParameter"]>

  export type CulturalParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionCode?: boolean
    cultureKey?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["culturalParameter"]>

  export type CulturalParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionCode?: boolean
    cultureKey?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["culturalParameter"]>

  export type CulturalParameterSelectScalar = {
    id?: boolean
    regionCode?: boolean
    cultureKey?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CulturalParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionCode" | "cultureKey" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["culturalParameter"]>

  export type $CulturalParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CulturalParameter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      regionCode: string
      cultureKey: string
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["culturalParameter"]>
    composites: {}
  }

  type CulturalParameterGetPayload<S extends boolean | null | undefined | CulturalParameterDefaultArgs> = $Result.GetResult<Prisma.$CulturalParameterPayload, S>

  type CulturalParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CulturalParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CulturalParameterCountAggregateInputType | true
    }

  export interface CulturalParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CulturalParameter'], meta: { name: 'CulturalParameter' } }
    /**
     * Find zero or one CulturalParameter that matches the filter.
     * @param {CulturalParameterFindUniqueArgs} args - Arguments to find a CulturalParameter
     * @example
     * // Get one CulturalParameter
     * const culturalParameter = await prisma.culturalParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CulturalParameterFindUniqueArgs>(args: SelectSubset<T, CulturalParameterFindUniqueArgs<ExtArgs>>): Prisma__CulturalParameterClient<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CulturalParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CulturalParameterFindUniqueOrThrowArgs} args - Arguments to find a CulturalParameter
     * @example
     * // Get one CulturalParameter
     * const culturalParameter = await prisma.culturalParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CulturalParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, CulturalParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CulturalParameterClient<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CulturalParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CulturalParameterFindFirstArgs} args - Arguments to find a CulturalParameter
     * @example
     * // Get one CulturalParameter
     * const culturalParameter = await prisma.culturalParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CulturalParameterFindFirstArgs>(args?: SelectSubset<T, CulturalParameterFindFirstArgs<ExtArgs>>): Prisma__CulturalParameterClient<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CulturalParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CulturalParameterFindFirstOrThrowArgs} args - Arguments to find a CulturalParameter
     * @example
     * // Get one CulturalParameter
     * const culturalParameter = await prisma.culturalParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CulturalParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, CulturalParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CulturalParameterClient<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CulturalParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CulturalParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CulturalParameters
     * const culturalParameters = await prisma.culturalParameter.findMany()
     * 
     * // Get first 10 CulturalParameters
     * const culturalParameters = await prisma.culturalParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const culturalParameterWithIdOnly = await prisma.culturalParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CulturalParameterFindManyArgs>(args?: SelectSubset<T, CulturalParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CulturalParameter.
     * @param {CulturalParameterCreateArgs} args - Arguments to create a CulturalParameter.
     * @example
     * // Create one CulturalParameter
     * const CulturalParameter = await prisma.culturalParameter.create({
     *   data: {
     *     // ... data to create a CulturalParameter
     *   }
     * })
     * 
     */
    create<T extends CulturalParameterCreateArgs>(args: SelectSubset<T, CulturalParameterCreateArgs<ExtArgs>>): Prisma__CulturalParameterClient<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CulturalParameters.
     * @param {CulturalParameterCreateManyArgs} args - Arguments to create many CulturalParameters.
     * @example
     * // Create many CulturalParameters
     * const culturalParameter = await prisma.culturalParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CulturalParameterCreateManyArgs>(args?: SelectSubset<T, CulturalParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CulturalParameters and returns the data saved in the database.
     * @param {CulturalParameterCreateManyAndReturnArgs} args - Arguments to create many CulturalParameters.
     * @example
     * // Create many CulturalParameters
     * const culturalParameter = await prisma.culturalParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CulturalParameters and only return the `id`
     * const culturalParameterWithIdOnly = await prisma.culturalParameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CulturalParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, CulturalParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CulturalParameter.
     * @param {CulturalParameterDeleteArgs} args - Arguments to delete one CulturalParameter.
     * @example
     * // Delete one CulturalParameter
     * const CulturalParameter = await prisma.culturalParameter.delete({
     *   where: {
     *     // ... filter to delete one CulturalParameter
     *   }
     * })
     * 
     */
    delete<T extends CulturalParameterDeleteArgs>(args: SelectSubset<T, CulturalParameterDeleteArgs<ExtArgs>>): Prisma__CulturalParameterClient<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CulturalParameter.
     * @param {CulturalParameterUpdateArgs} args - Arguments to update one CulturalParameter.
     * @example
     * // Update one CulturalParameter
     * const culturalParameter = await prisma.culturalParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CulturalParameterUpdateArgs>(args: SelectSubset<T, CulturalParameterUpdateArgs<ExtArgs>>): Prisma__CulturalParameterClient<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CulturalParameters.
     * @param {CulturalParameterDeleteManyArgs} args - Arguments to filter CulturalParameters to delete.
     * @example
     * // Delete a few CulturalParameters
     * const { count } = await prisma.culturalParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CulturalParameterDeleteManyArgs>(args?: SelectSubset<T, CulturalParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CulturalParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CulturalParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CulturalParameters
     * const culturalParameter = await prisma.culturalParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CulturalParameterUpdateManyArgs>(args: SelectSubset<T, CulturalParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CulturalParameters and returns the data updated in the database.
     * @param {CulturalParameterUpdateManyAndReturnArgs} args - Arguments to update many CulturalParameters.
     * @example
     * // Update many CulturalParameters
     * const culturalParameter = await prisma.culturalParameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CulturalParameters and only return the `id`
     * const culturalParameterWithIdOnly = await prisma.culturalParameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CulturalParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, CulturalParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CulturalParameter.
     * @param {CulturalParameterUpsertArgs} args - Arguments to update or create a CulturalParameter.
     * @example
     * // Update or create a CulturalParameter
     * const culturalParameter = await prisma.culturalParameter.upsert({
     *   create: {
     *     // ... data to create a CulturalParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CulturalParameter we want to update
     *   }
     * })
     */
    upsert<T extends CulturalParameterUpsertArgs>(args: SelectSubset<T, CulturalParameterUpsertArgs<ExtArgs>>): Prisma__CulturalParameterClient<$Result.GetResult<Prisma.$CulturalParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CulturalParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CulturalParameterCountArgs} args - Arguments to filter CulturalParameters to count.
     * @example
     * // Count the number of CulturalParameters
     * const count = await prisma.culturalParameter.count({
     *   where: {
     *     // ... the filter for the CulturalParameters we want to count
     *   }
     * })
    **/
    count<T extends CulturalParameterCountArgs>(
      args?: Subset<T, CulturalParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CulturalParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CulturalParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CulturalParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CulturalParameterAggregateArgs>(args: Subset<T, CulturalParameterAggregateArgs>): Prisma.PrismaPromise<GetCulturalParameterAggregateType<T>>

    /**
     * Group by CulturalParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CulturalParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CulturalParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CulturalParameterGroupByArgs['orderBy'] }
        : { orderBy?: CulturalParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CulturalParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCulturalParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CulturalParameter model
   */
  readonly fields: CulturalParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CulturalParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CulturalParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CulturalParameter model
   */
  interface CulturalParameterFieldRefs {
    readonly id: FieldRef<"CulturalParameter", 'String'>
    readonly regionCode: FieldRef<"CulturalParameter", 'String'>
    readonly cultureKey: FieldRef<"CulturalParameter", 'String'>
    readonly settings: FieldRef<"CulturalParameter", 'Json'>
    readonly createdAt: FieldRef<"CulturalParameter", 'DateTime'>
    readonly updatedAt: FieldRef<"CulturalParameter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CulturalParameter findUnique
   */
  export type CulturalParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * Filter, which CulturalParameter to fetch.
     */
    where: CulturalParameterWhereUniqueInput
  }

  /**
   * CulturalParameter findUniqueOrThrow
   */
  export type CulturalParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * Filter, which CulturalParameter to fetch.
     */
    where: CulturalParameterWhereUniqueInput
  }

  /**
   * CulturalParameter findFirst
   */
  export type CulturalParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * Filter, which CulturalParameter to fetch.
     */
    where?: CulturalParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CulturalParameters to fetch.
     */
    orderBy?: CulturalParameterOrderByWithRelationInput | CulturalParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CulturalParameters.
     */
    cursor?: CulturalParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CulturalParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CulturalParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CulturalParameters.
     */
    distinct?: CulturalParameterScalarFieldEnum | CulturalParameterScalarFieldEnum[]
  }

  /**
   * CulturalParameter findFirstOrThrow
   */
  export type CulturalParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * Filter, which CulturalParameter to fetch.
     */
    where?: CulturalParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CulturalParameters to fetch.
     */
    orderBy?: CulturalParameterOrderByWithRelationInput | CulturalParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CulturalParameters.
     */
    cursor?: CulturalParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CulturalParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CulturalParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CulturalParameters.
     */
    distinct?: CulturalParameterScalarFieldEnum | CulturalParameterScalarFieldEnum[]
  }

  /**
   * CulturalParameter findMany
   */
  export type CulturalParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * Filter, which CulturalParameters to fetch.
     */
    where?: CulturalParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CulturalParameters to fetch.
     */
    orderBy?: CulturalParameterOrderByWithRelationInput | CulturalParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CulturalParameters.
     */
    cursor?: CulturalParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CulturalParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CulturalParameters.
     */
    skip?: number
    distinct?: CulturalParameterScalarFieldEnum | CulturalParameterScalarFieldEnum[]
  }

  /**
   * CulturalParameter create
   */
  export type CulturalParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * The data needed to create a CulturalParameter.
     */
    data: XOR<CulturalParameterCreateInput, CulturalParameterUncheckedCreateInput>
  }

  /**
   * CulturalParameter createMany
   */
  export type CulturalParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CulturalParameters.
     */
    data: CulturalParameterCreateManyInput | CulturalParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CulturalParameter createManyAndReturn
   */
  export type CulturalParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * The data used to create many CulturalParameters.
     */
    data: CulturalParameterCreateManyInput | CulturalParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CulturalParameter update
   */
  export type CulturalParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * The data needed to update a CulturalParameter.
     */
    data: XOR<CulturalParameterUpdateInput, CulturalParameterUncheckedUpdateInput>
    /**
     * Choose, which CulturalParameter to update.
     */
    where: CulturalParameterWhereUniqueInput
  }

  /**
   * CulturalParameter updateMany
   */
  export type CulturalParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CulturalParameters.
     */
    data: XOR<CulturalParameterUpdateManyMutationInput, CulturalParameterUncheckedUpdateManyInput>
    /**
     * Filter which CulturalParameters to update
     */
    where?: CulturalParameterWhereInput
    /**
     * Limit how many CulturalParameters to update.
     */
    limit?: number
  }

  /**
   * CulturalParameter updateManyAndReturn
   */
  export type CulturalParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * The data used to update CulturalParameters.
     */
    data: XOR<CulturalParameterUpdateManyMutationInput, CulturalParameterUncheckedUpdateManyInput>
    /**
     * Filter which CulturalParameters to update
     */
    where?: CulturalParameterWhereInput
    /**
     * Limit how many CulturalParameters to update.
     */
    limit?: number
  }

  /**
   * CulturalParameter upsert
   */
  export type CulturalParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * The filter to search for the CulturalParameter to update in case it exists.
     */
    where: CulturalParameterWhereUniqueInput
    /**
     * In case the CulturalParameter found by the `where` argument doesn't exist, create a new CulturalParameter with this data.
     */
    create: XOR<CulturalParameterCreateInput, CulturalParameterUncheckedCreateInput>
    /**
     * In case the CulturalParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CulturalParameterUpdateInput, CulturalParameterUncheckedUpdateInput>
  }

  /**
   * CulturalParameter delete
   */
  export type CulturalParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
    /**
     * Filter which CulturalParameter to delete.
     */
    where: CulturalParameterWhereUniqueInput
  }

  /**
   * CulturalParameter deleteMany
   */
  export type CulturalParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CulturalParameters to delete
     */
    where?: CulturalParameterWhereInput
    /**
     * Limit how many CulturalParameters to delete.
     */
    limit?: number
  }

  /**
   * CulturalParameter without action
   */
  export type CulturalParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CulturalParameter
     */
    select?: CulturalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CulturalParameter
     */
    omit?: CulturalParameterOmit<ExtArgs> | null
  }


  /**
   * Model Relationship
   */

  export type AggregateRelationship = {
    _count: RelationshipCountAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  export type RelationshipMinAggregateOutputType = {
    id: string | null
    userId: string | null
    counterpartUserId: string | null
    roleTemplateId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type RelationshipMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    counterpartUserId: string | null
    roleTemplateId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type RelationshipCountAggregateOutputType = {
    id: number
    userId: number
    counterpartUserId: number
    roleTemplateId: number
    title: number
    metadata: number
    createdAt: number
    updatedAt: number
    isActive: number
    _all: number
  }


  export type RelationshipMinAggregateInputType = {
    id?: true
    userId?: true
    counterpartUserId?: true
    roleTemplateId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type RelationshipMaxAggregateInputType = {
    id?: true
    userId?: true
    counterpartUserId?: true
    roleTemplateId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type RelationshipCountAggregateInputType = {
    id?: true
    userId?: true
    counterpartUserId?: true
    roleTemplateId?: true
    title?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    _all?: true
  }

  export type RelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relationship to aggregate.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Relationships
    **/
    _count?: true | RelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationshipMaxAggregateInputType
  }

  export type GetRelationshipAggregateType<T extends RelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationship[P]>
      : GetScalarType<T[P], AggregateRelationship[P]>
  }




  export type RelationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipWhereInput
    orderBy?: RelationshipOrderByWithAggregationInput | RelationshipOrderByWithAggregationInput[]
    by: RelationshipScalarFieldEnum[] | RelationshipScalarFieldEnum
    having?: RelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationshipCountAggregateInputType | true
    _min?: RelationshipMinAggregateInputType
    _max?: RelationshipMaxAggregateInputType
  }

  export type RelationshipGroupByOutputType = {
    id: string
    userId: string
    counterpartUserId: string | null
    roleTemplateId: string | null
    title: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    _count: RelationshipCountAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  type GetRelationshipGroupByPayload<T extends RelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
        }
      >
    >


  export type RelationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    counterpartUserId?: boolean
    roleTemplateId?: boolean
    title?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    counterpartUser?: boolean | Relationship$counterpartUserArgs<ExtArgs>
    roleTemplate?: boolean | Relationship$roleTemplateArgs<ExtArgs>
    messages?: boolean | Relationship$messagesArgs<ExtArgs>
    growthMetrics?: boolean | Relationship$growthMetricsArgs<ExtArgs>
    _count?: boolean | RelationshipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relationship"]>

  export type RelationshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    counterpartUserId?: boolean
    roleTemplateId?: boolean
    title?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    counterpartUser?: boolean | Relationship$counterpartUserArgs<ExtArgs>
    roleTemplate?: boolean | Relationship$roleTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["relationship"]>

  export type RelationshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    counterpartUserId?: boolean
    roleTemplateId?: boolean
    title?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    counterpartUser?: boolean | Relationship$counterpartUserArgs<ExtArgs>
    roleTemplate?: boolean | Relationship$roleTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["relationship"]>

  export type RelationshipSelectScalar = {
    id?: boolean
    userId?: boolean
    counterpartUserId?: boolean
    roleTemplateId?: boolean
    title?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }

  export type RelationshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "counterpartUserId" | "roleTemplateId" | "title" | "metadata" | "createdAt" | "updatedAt" | "isActive", ExtArgs["result"]["relationship"]>
  export type RelationshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    counterpartUser?: boolean | Relationship$counterpartUserArgs<ExtArgs>
    roleTemplate?: boolean | Relationship$roleTemplateArgs<ExtArgs>
    messages?: boolean | Relationship$messagesArgs<ExtArgs>
    growthMetrics?: boolean | Relationship$growthMetricsArgs<ExtArgs>
    _count?: boolean | RelationshipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RelationshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    counterpartUser?: boolean | Relationship$counterpartUserArgs<ExtArgs>
    roleTemplate?: boolean | Relationship$roleTemplateArgs<ExtArgs>
  }
  export type RelationshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    counterpartUser?: boolean | Relationship$counterpartUserArgs<ExtArgs>
    roleTemplate?: boolean | Relationship$roleTemplateArgs<ExtArgs>
  }

  export type $RelationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Relationship"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      counterpartUser: Prisma.$UserPayload<ExtArgs> | null
      roleTemplate: Prisma.$RoleTemplatePayload<ExtArgs> | null
      messages: Prisma.$ConversationMessagePayload<ExtArgs>[]
      growthMetrics: Prisma.$GrowthMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      counterpartUserId: string | null
      roleTemplateId: string | null
      title: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["relationship"]>
    composites: {}
  }

  type RelationshipGetPayload<S extends boolean | null | undefined | RelationshipDefaultArgs> = $Result.GetResult<Prisma.$RelationshipPayload, S>

  type RelationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RelationshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RelationshipCountAggregateInputType | true
    }

  export interface RelationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Relationship'], meta: { name: 'Relationship' } }
    /**
     * Find zero or one Relationship that matches the filter.
     * @param {RelationshipFindUniqueArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelationshipFindUniqueArgs>(args: SelectSubset<T, RelationshipFindUniqueArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Relationship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RelationshipFindUniqueOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelationshipFindUniqueOrThrowArgs>(args: SelectSubset<T, RelationshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Relationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindFirstArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelationshipFindFirstArgs>(args?: SelectSubset<T, RelationshipFindFirstArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Relationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindFirstOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelationshipFindFirstOrThrowArgs>(args?: SelectSubset<T, RelationshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Relationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relationships
     * const relationships = await prisma.relationship.findMany()
     * 
     * // Get first 10 Relationships
     * const relationships = await prisma.relationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationshipWithIdOnly = await prisma.relationship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelationshipFindManyArgs>(args?: SelectSubset<T, RelationshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Relationship.
     * @param {RelationshipCreateArgs} args - Arguments to create a Relationship.
     * @example
     * // Create one Relationship
     * const Relationship = await prisma.relationship.create({
     *   data: {
     *     // ... data to create a Relationship
     *   }
     * })
     * 
     */
    create<T extends RelationshipCreateArgs>(args: SelectSubset<T, RelationshipCreateArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Relationships.
     * @param {RelationshipCreateManyArgs} args - Arguments to create many Relationships.
     * @example
     * // Create many Relationships
     * const relationship = await prisma.relationship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelationshipCreateManyArgs>(args?: SelectSubset<T, RelationshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Relationships and returns the data saved in the database.
     * @param {RelationshipCreateManyAndReturnArgs} args - Arguments to create many Relationships.
     * @example
     * // Create many Relationships
     * const relationship = await prisma.relationship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Relationships and only return the `id`
     * const relationshipWithIdOnly = await prisma.relationship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelationshipCreateManyAndReturnArgs>(args?: SelectSubset<T, RelationshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Relationship.
     * @param {RelationshipDeleteArgs} args - Arguments to delete one Relationship.
     * @example
     * // Delete one Relationship
     * const Relationship = await prisma.relationship.delete({
     *   where: {
     *     // ... filter to delete one Relationship
     *   }
     * })
     * 
     */
    delete<T extends RelationshipDeleteArgs>(args: SelectSubset<T, RelationshipDeleteArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Relationship.
     * @param {RelationshipUpdateArgs} args - Arguments to update one Relationship.
     * @example
     * // Update one Relationship
     * const relationship = await prisma.relationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelationshipUpdateArgs>(args: SelectSubset<T, RelationshipUpdateArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Relationships.
     * @param {RelationshipDeleteManyArgs} args - Arguments to filter Relationships to delete.
     * @example
     * // Delete a few Relationships
     * const { count } = await prisma.relationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelationshipDeleteManyArgs>(args?: SelectSubset<T, RelationshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relationships
     * const relationship = await prisma.relationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelationshipUpdateManyArgs>(args: SelectSubset<T, RelationshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relationships and returns the data updated in the database.
     * @param {RelationshipUpdateManyAndReturnArgs} args - Arguments to update many Relationships.
     * @example
     * // Update many Relationships
     * const relationship = await prisma.relationship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Relationships and only return the `id`
     * const relationshipWithIdOnly = await prisma.relationship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RelationshipUpdateManyAndReturnArgs>(args: SelectSubset<T, RelationshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Relationship.
     * @param {RelationshipUpsertArgs} args - Arguments to update or create a Relationship.
     * @example
     * // Update or create a Relationship
     * const relationship = await prisma.relationship.upsert({
     *   create: {
     *     // ... data to create a Relationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relationship we want to update
     *   }
     * })
     */
    upsert<T extends RelationshipUpsertArgs>(args: SelectSubset<T, RelationshipUpsertArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipCountArgs} args - Arguments to filter Relationships to count.
     * @example
     * // Count the number of Relationships
     * const count = await prisma.relationship.count({
     *   where: {
     *     // ... the filter for the Relationships we want to count
     *   }
     * })
    **/
    count<T extends RelationshipCountArgs>(
      args?: Subset<T, RelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationshipAggregateArgs>(args: Subset<T, RelationshipAggregateArgs>): Prisma.PrismaPromise<GetRelationshipAggregateType<T>>

    /**
     * Group by Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationshipGroupByArgs['orderBy'] }
        : { orderBy?: RelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Relationship model
   */
  readonly fields: RelationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Relationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    counterpartUser<T extends Relationship$counterpartUserArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$counterpartUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roleTemplate<T extends Relationship$roleTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$roleTemplateArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends Relationship$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    growthMetrics<T extends Relationship$growthMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$growthMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Relationship model
   */
  interface RelationshipFieldRefs {
    readonly id: FieldRef<"Relationship", 'String'>
    readonly userId: FieldRef<"Relationship", 'String'>
    readonly counterpartUserId: FieldRef<"Relationship", 'String'>
    readonly roleTemplateId: FieldRef<"Relationship", 'String'>
    readonly title: FieldRef<"Relationship", 'String'>
    readonly metadata: FieldRef<"Relationship", 'Json'>
    readonly createdAt: FieldRef<"Relationship", 'DateTime'>
    readonly updatedAt: FieldRef<"Relationship", 'DateTime'>
    readonly isActive: FieldRef<"Relationship", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Relationship findUnique
   */
  export type RelationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where: RelationshipWhereUniqueInput
  }

  /**
   * Relationship findUniqueOrThrow
   */
  export type RelationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where: RelationshipWhereUniqueInput
  }

  /**
   * Relationship findFirst
   */
  export type RelationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * Relationship findFirstOrThrow
   */
  export type RelationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * Relationship findMany
   */
  export type RelationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationships to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * Relationship create
   */
  export type RelationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Relationship.
     */
    data: XOR<RelationshipCreateInput, RelationshipUncheckedCreateInput>
  }

  /**
   * Relationship createMany
   */
  export type RelationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Relationships.
     */
    data: RelationshipCreateManyInput | RelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Relationship createManyAndReturn
   */
  export type RelationshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * The data used to create many Relationships.
     */
    data: RelationshipCreateManyInput | RelationshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Relationship update
   */
  export type RelationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Relationship.
     */
    data: XOR<RelationshipUpdateInput, RelationshipUncheckedUpdateInput>
    /**
     * Choose, which Relationship to update.
     */
    where: RelationshipWhereUniqueInput
  }

  /**
   * Relationship updateMany
   */
  export type RelationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Relationships.
     */
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyInput>
    /**
     * Filter which Relationships to update
     */
    where?: RelationshipWhereInput
    /**
     * Limit how many Relationships to update.
     */
    limit?: number
  }

  /**
   * Relationship updateManyAndReturn
   */
  export type RelationshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * The data used to update Relationships.
     */
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyInput>
    /**
     * Filter which Relationships to update
     */
    where?: RelationshipWhereInput
    /**
     * Limit how many Relationships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Relationship upsert
   */
  export type RelationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Relationship to update in case it exists.
     */
    where: RelationshipWhereUniqueInput
    /**
     * In case the Relationship found by the `where` argument doesn't exist, create a new Relationship with this data.
     */
    create: XOR<RelationshipCreateInput, RelationshipUncheckedCreateInput>
    /**
     * In case the Relationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationshipUpdateInput, RelationshipUncheckedUpdateInput>
  }

  /**
   * Relationship delete
   */
  export type RelationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter which Relationship to delete.
     */
    where: RelationshipWhereUniqueInput
  }

  /**
   * Relationship deleteMany
   */
  export type RelationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relationships to delete
     */
    where?: RelationshipWhereInput
    /**
     * Limit how many Relationships to delete.
     */
    limit?: number
  }

  /**
   * Relationship.counterpartUser
   */
  export type Relationship$counterpartUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Relationship.roleTemplate
   */
  export type Relationship$roleTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleTemplate
     */
    omit?: RoleTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    where?: RoleTemplateWhereInput
  }

  /**
   * Relationship.messages
   */
  export type Relationship$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    where?: ConversationMessageWhereInput
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    cursor?: ConversationMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * Relationship.growthMetrics
   */
  export type Relationship$growthMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    where?: GrowthMetricWhereInput
    orderBy?: GrowthMetricOrderByWithRelationInput | GrowthMetricOrderByWithRelationInput[]
    cursor?: GrowthMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GrowthMetricScalarFieldEnum | GrowthMetricScalarFieldEnum[]
  }

  /**
   * Relationship without action
   */
  export type RelationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Relationship
     */
    omit?: RelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
  }


  /**
   * Model ConversationMessage
   */

  export type AggregateConversationMessage = {
    _count: ConversationMessageCountAggregateOutputType | null
    _min: ConversationMessageMinAggregateOutputType | null
    _max: ConversationMessageMaxAggregateOutputType | null
  }

  export type ConversationMessageMinAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    senderId: string | null
    content: string | null
    emotionalTone: $Enums.EmotionalTone | null
    createdAt: Date | null
  }

  export type ConversationMessageMaxAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    senderId: string | null
    content: string | null
    emotionalTone: $Enums.EmotionalTone | null
    createdAt: Date | null
  }

  export type ConversationMessageCountAggregateOutputType = {
    id: number
    relationshipId: number
    senderId: number
    content: number
    emotionalTone: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ConversationMessageMinAggregateInputType = {
    id?: true
    relationshipId?: true
    senderId?: true
    content?: true
    emotionalTone?: true
    createdAt?: true
  }

  export type ConversationMessageMaxAggregateInputType = {
    id?: true
    relationshipId?: true
    senderId?: true
    content?: true
    emotionalTone?: true
    createdAt?: true
  }

  export type ConversationMessageCountAggregateInputType = {
    id?: true
    relationshipId?: true
    senderId?: true
    content?: true
    emotionalTone?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ConversationMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMessage to aggregate.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationMessages
    **/
    _count?: true | ConversationMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMessageMaxAggregateInputType
  }

  export type GetConversationMessageAggregateType<T extends ConversationMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationMessage[P]>
      : GetScalarType<T[P], AggregateConversationMessage[P]>
  }




  export type ConversationMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMessageWhereInput
    orderBy?: ConversationMessageOrderByWithAggregationInput | ConversationMessageOrderByWithAggregationInput[]
    by: ConversationMessageScalarFieldEnum[] | ConversationMessageScalarFieldEnum
    having?: ConversationMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationMessageCountAggregateInputType | true
    _min?: ConversationMessageMinAggregateInputType
    _max?: ConversationMessageMaxAggregateInputType
  }

  export type ConversationMessageGroupByOutputType = {
    id: string
    relationshipId: string
    senderId: string | null
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata: JsonValue | null
    createdAt: Date
    _count: ConversationMessageCountAggregateOutputType | null
    _min: ConversationMessageMinAggregateOutputType | null
    _max: ConversationMessageMaxAggregateOutputType | null
  }

  type GetConversationMessageGroupByPayload<T extends ConversationMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationMessageGroupByOutputType[P]>
        }
      >
    >


  export type ConversationMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    senderId?: boolean
    content?: boolean
    emotionalTone?: boolean
    metadata?: boolean
    createdAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | ConversationMessage$senderArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMessage"]>

  export type ConversationMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    senderId?: boolean
    content?: boolean
    emotionalTone?: boolean
    metadata?: boolean
    createdAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | ConversationMessage$senderArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMessage"]>

  export type ConversationMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    senderId?: boolean
    content?: boolean
    emotionalTone?: boolean
    metadata?: boolean
    createdAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | ConversationMessage$senderArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMessage"]>

  export type ConversationMessageSelectScalar = {
    id?: boolean
    relationshipId?: boolean
    senderId?: boolean
    content?: boolean
    emotionalTone?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ConversationMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "relationshipId" | "senderId" | "content" | "emotionalTone" | "metadata" | "createdAt", ExtArgs["result"]["conversationMessage"]>
  export type ConversationMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | ConversationMessage$senderArgs<ExtArgs>
  }
  export type ConversationMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | ConversationMessage$senderArgs<ExtArgs>
  }
  export type ConversationMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | ConversationMessage$senderArgs<ExtArgs>
  }

  export type $ConversationMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationMessage"
    objects: {
      relationship: Prisma.$RelationshipPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationshipId: string
      senderId: string | null
      content: string
      emotionalTone: $Enums.EmotionalTone
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["conversationMessage"]>
    composites: {}
  }

  type ConversationMessageGetPayload<S extends boolean | null | undefined | ConversationMessageDefaultArgs> = $Result.GetResult<Prisma.$ConversationMessagePayload, S>

  type ConversationMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationMessageCountAggregateInputType | true
    }

  export interface ConversationMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationMessage'], meta: { name: 'ConversationMessage' } }
    /**
     * Find zero or one ConversationMessage that matches the filter.
     * @param {ConversationMessageFindUniqueArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationMessageFindUniqueArgs>(args: SelectSubset<T, ConversationMessageFindUniqueArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationMessageFindUniqueOrThrowArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindFirstArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationMessageFindFirstArgs>(args?: SelectSubset<T, ConversationMessageFindFirstArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindFirstOrThrowArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationMessages
     * const conversationMessages = await prisma.conversationMessage.findMany()
     * 
     * // Get first 10 ConversationMessages
     * const conversationMessages = await prisma.conversationMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationMessageFindManyArgs>(args?: SelectSubset<T, ConversationMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationMessage.
     * @param {ConversationMessageCreateArgs} args - Arguments to create a ConversationMessage.
     * @example
     * // Create one ConversationMessage
     * const ConversationMessage = await prisma.conversationMessage.create({
     *   data: {
     *     // ... data to create a ConversationMessage
     *   }
     * })
     * 
     */
    create<T extends ConversationMessageCreateArgs>(args: SelectSubset<T, ConversationMessageCreateArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationMessages.
     * @param {ConversationMessageCreateManyArgs} args - Arguments to create many ConversationMessages.
     * @example
     * // Create many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationMessageCreateManyArgs>(args?: SelectSubset<T, ConversationMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationMessages and returns the data saved in the database.
     * @param {ConversationMessageCreateManyAndReturnArgs} args - Arguments to create many ConversationMessages.
     * @example
     * // Create many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationMessages and only return the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationMessage.
     * @param {ConversationMessageDeleteArgs} args - Arguments to delete one ConversationMessage.
     * @example
     * // Delete one ConversationMessage
     * const ConversationMessage = await prisma.conversationMessage.delete({
     *   where: {
     *     // ... filter to delete one ConversationMessage
     *   }
     * })
     * 
     */
    delete<T extends ConversationMessageDeleteArgs>(args: SelectSubset<T, ConversationMessageDeleteArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationMessage.
     * @param {ConversationMessageUpdateArgs} args - Arguments to update one ConversationMessage.
     * @example
     * // Update one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationMessageUpdateArgs>(args: SelectSubset<T, ConversationMessageUpdateArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationMessages.
     * @param {ConversationMessageDeleteManyArgs} args - Arguments to filter ConversationMessages to delete.
     * @example
     * // Delete a few ConversationMessages
     * const { count } = await prisma.conversationMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationMessageDeleteManyArgs>(args?: SelectSubset<T, ConversationMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationMessageUpdateManyArgs>(args: SelectSubset<T, ConversationMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMessages and returns the data updated in the database.
     * @param {ConversationMessageUpdateManyAndReturnArgs} args - Arguments to update many ConversationMessages.
     * @example
     * // Update many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationMessages and only return the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationMessage.
     * @param {ConversationMessageUpsertArgs} args - Arguments to update or create a ConversationMessage.
     * @example
     * // Update or create a ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.upsert({
     *   create: {
     *     // ... data to create a ConversationMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationMessage we want to update
     *   }
     * })
     */
    upsert<T extends ConversationMessageUpsertArgs>(args: SelectSubset<T, ConversationMessageUpsertArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageCountArgs} args - Arguments to filter ConversationMessages to count.
     * @example
     * // Count the number of ConversationMessages
     * const count = await prisma.conversationMessage.count({
     *   where: {
     *     // ... the filter for the ConversationMessages we want to count
     *   }
     * })
    **/
    count<T extends ConversationMessageCountArgs>(
      args?: Subset<T, ConversationMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationMessageAggregateArgs>(args: Subset<T, ConversationMessageAggregateArgs>): Prisma.PrismaPromise<GetConversationMessageAggregateType<T>>

    /**
     * Group by ConversationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationMessageGroupByArgs['orderBy'] }
        : { orderBy?: ConversationMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationMessage model
   */
  readonly fields: ConversationMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends RelationshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipDefaultArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends ConversationMessage$senderArgs<ExtArgs> = {}>(args?: Subset<T, ConversationMessage$senderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationMessage model
   */
  interface ConversationMessageFieldRefs {
    readonly id: FieldRef<"ConversationMessage", 'String'>
    readonly relationshipId: FieldRef<"ConversationMessage", 'String'>
    readonly senderId: FieldRef<"ConversationMessage", 'String'>
    readonly content: FieldRef<"ConversationMessage", 'String'>
    readonly emotionalTone: FieldRef<"ConversationMessage", 'EmotionalTone'>
    readonly metadata: FieldRef<"ConversationMessage", 'Json'>
    readonly createdAt: FieldRef<"ConversationMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationMessage findUnique
   */
  export type ConversationMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage findUniqueOrThrow
   */
  export type ConversationMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage findFirst
   */
  export type ConversationMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMessages.
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMessages.
     */
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * ConversationMessage findFirstOrThrow
   */
  export type ConversationMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMessages.
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMessages.
     */
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * ConversationMessage findMany
   */
  export type ConversationMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessages to fetch.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationMessages.
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * ConversationMessage create
   */
  export type ConversationMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationMessage.
     */
    data: XOR<ConversationMessageCreateInput, ConversationMessageUncheckedCreateInput>
  }

  /**
   * ConversationMessage createMany
   */
  export type ConversationMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationMessages.
     */
    data: ConversationMessageCreateManyInput | ConversationMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationMessage createManyAndReturn
   */
  export type ConversationMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationMessages.
     */
    data: ConversationMessageCreateManyInput | ConversationMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMessage update
   */
  export type ConversationMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationMessage.
     */
    data: XOR<ConversationMessageUpdateInput, ConversationMessageUncheckedUpdateInput>
    /**
     * Choose, which ConversationMessage to update.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage updateMany
   */
  export type ConversationMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationMessages.
     */
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMessages to update
     */
    where?: ConversationMessageWhereInput
    /**
     * Limit how many ConversationMessages to update.
     */
    limit?: number
  }

  /**
   * ConversationMessage updateManyAndReturn
   */
  export type ConversationMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * The data used to update ConversationMessages.
     */
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMessages to update
     */
    where?: ConversationMessageWhereInput
    /**
     * Limit how many ConversationMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMessage upsert
   */
  export type ConversationMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationMessage to update in case it exists.
     */
    where: ConversationMessageWhereUniqueInput
    /**
     * In case the ConversationMessage found by the `where` argument doesn't exist, create a new ConversationMessage with this data.
     */
    create: XOR<ConversationMessageCreateInput, ConversationMessageUncheckedCreateInput>
    /**
     * In case the ConversationMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationMessageUpdateInput, ConversationMessageUncheckedUpdateInput>
  }

  /**
   * ConversationMessage delete
   */
  export type ConversationMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter which ConversationMessage to delete.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage deleteMany
   */
  export type ConversationMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMessages to delete
     */
    where?: ConversationMessageWhereInput
    /**
     * Limit how many ConversationMessages to delete.
     */
    limit?: number
  }

  /**
   * ConversationMessage.sender
   */
  export type ConversationMessage$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ConversationMessage without action
   */
  export type ConversationMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
  }


  /**
   * Model GrowthMetric
   */

  export type AggregateGrowthMetric = {
    _count: GrowthMetricCountAggregateOutputType | null
    _avg: GrowthMetricAvgAggregateOutputType | null
    _sum: GrowthMetricSumAggregateOutputType | null
    _min: GrowthMetricMinAggregateOutputType | null
    _max: GrowthMetricMaxAggregateOutputType | null
  }

  export type GrowthMetricAvgAggregateOutputType = {
    messagesCount: number | null
    positiveCount: number | null
    neutralCount: number | null
    negativeCount: number | null
  }

  export type GrowthMetricSumAggregateOutputType = {
    messagesCount: number | null
    positiveCount: number | null
    neutralCount: number | null
    negativeCount: number | null
  }

  export type GrowthMetricMinAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    bucketDate: Date | null
    messagesCount: number | null
    positiveCount: number | null
    neutralCount: number | null
    negativeCount: number | null
  }

  export type GrowthMetricMaxAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    bucketDate: Date | null
    messagesCount: number | null
    positiveCount: number | null
    neutralCount: number | null
    negativeCount: number | null
  }

  export type GrowthMetricCountAggregateOutputType = {
    id: number
    relationshipId: number
    bucketDate: number
    messagesCount: number
    positiveCount: number
    neutralCount: number
    negativeCount: number
    metrics: number
    _all: number
  }


  export type GrowthMetricAvgAggregateInputType = {
    messagesCount?: true
    positiveCount?: true
    neutralCount?: true
    negativeCount?: true
  }

  export type GrowthMetricSumAggregateInputType = {
    messagesCount?: true
    positiveCount?: true
    neutralCount?: true
    negativeCount?: true
  }

  export type GrowthMetricMinAggregateInputType = {
    id?: true
    relationshipId?: true
    bucketDate?: true
    messagesCount?: true
    positiveCount?: true
    neutralCount?: true
    negativeCount?: true
  }

  export type GrowthMetricMaxAggregateInputType = {
    id?: true
    relationshipId?: true
    bucketDate?: true
    messagesCount?: true
    positiveCount?: true
    neutralCount?: true
    negativeCount?: true
  }

  export type GrowthMetricCountAggregateInputType = {
    id?: true
    relationshipId?: true
    bucketDate?: true
    messagesCount?: true
    positiveCount?: true
    neutralCount?: true
    negativeCount?: true
    metrics?: true
    _all?: true
  }

  export type GrowthMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GrowthMetric to aggregate.
     */
    where?: GrowthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GrowthMetrics to fetch.
     */
    orderBy?: GrowthMetricOrderByWithRelationInput | GrowthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GrowthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GrowthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GrowthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GrowthMetrics
    **/
    _count?: true | GrowthMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GrowthMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GrowthMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrowthMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrowthMetricMaxAggregateInputType
  }

  export type GetGrowthMetricAggregateType<T extends GrowthMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateGrowthMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrowthMetric[P]>
      : GetScalarType<T[P], AggregateGrowthMetric[P]>
  }




  export type GrowthMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GrowthMetricWhereInput
    orderBy?: GrowthMetricOrderByWithAggregationInput | GrowthMetricOrderByWithAggregationInput[]
    by: GrowthMetricScalarFieldEnum[] | GrowthMetricScalarFieldEnum
    having?: GrowthMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrowthMetricCountAggregateInputType | true
    _avg?: GrowthMetricAvgAggregateInputType
    _sum?: GrowthMetricSumAggregateInputType
    _min?: GrowthMetricMinAggregateInputType
    _max?: GrowthMetricMaxAggregateInputType
  }

  export type GrowthMetricGroupByOutputType = {
    id: string
    relationshipId: string
    bucketDate: Date
    messagesCount: number
    positiveCount: number
    neutralCount: number
    negativeCount: number
    metrics: JsonValue | null
    _count: GrowthMetricCountAggregateOutputType | null
    _avg: GrowthMetricAvgAggregateOutputType | null
    _sum: GrowthMetricSumAggregateOutputType | null
    _min: GrowthMetricMinAggregateOutputType | null
    _max: GrowthMetricMaxAggregateOutputType | null
  }

  type GetGrowthMetricGroupByPayload<T extends GrowthMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GrowthMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrowthMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrowthMetricGroupByOutputType[P]>
            : GetScalarType<T[P], GrowthMetricGroupByOutputType[P]>
        }
      >
    >


  export type GrowthMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    bucketDate?: boolean
    messagesCount?: boolean
    positiveCount?: boolean
    neutralCount?: boolean
    negativeCount?: boolean
    metrics?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["growthMetric"]>

  export type GrowthMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    bucketDate?: boolean
    messagesCount?: boolean
    positiveCount?: boolean
    neutralCount?: boolean
    negativeCount?: boolean
    metrics?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["growthMetric"]>

  export type GrowthMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    bucketDate?: boolean
    messagesCount?: boolean
    positiveCount?: boolean
    neutralCount?: boolean
    negativeCount?: boolean
    metrics?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["growthMetric"]>

  export type GrowthMetricSelectScalar = {
    id?: boolean
    relationshipId?: boolean
    bucketDate?: boolean
    messagesCount?: boolean
    positiveCount?: boolean
    neutralCount?: boolean
    negativeCount?: boolean
    metrics?: boolean
  }

  export type GrowthMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "relationshipId" | "bucketDate" | "messagesCount" | "positiveCount" | "neutralCount" | "negativeCount" | "metrics", ExtArgs["result"]["growthMetric"]>
  export type GrowthMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }
  export type GrowthMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }
  export type GrowthMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }

  export type $GrowthMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GrowthMetric"
    objects: {
      relationship: Prisma.$RelationshipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationshipId: string
      bucketDate: Date
      messagesCount: number
      positiveCount: number
      neutralCount: number
      negativeCount: number
      metrics: Prisma.JsonValue | null
    }, ExtArgs["result"]["growthMetric"]>
    composites: {}
  }

  type GrowthMetricGetPayload<S extends boolean | null | undefined | GrowthMetricDefaultArgs> = $Result.GetResult<Prisma.$GrowthMetricPayload, S>

  type GrowthMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GrowthMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GrowthMetricCountAggregateInputType | true
    }

  export interface GrowthMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GrowthMetric'], meta: { name: 'GrowthMetric' } }
    /**
     * Find zero or one GrowthMetric that matches the filter.
     * @param {GrowthMetricFindUniqueArgs} args - Arguments to find a GrowthMetric
     * @example
     * // Get one GrowthMetric
     * const growthMetric = await prisma.growthMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GrowthMetricFindUniqueArgs>(args: SelectSubset<T, GrowthMetricFindUniqueArgs<ExtArgs>>): Prisma__GrowthMetricClient<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GrowthMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GrowthMetricFindUniqueOrThrowArgs} args - Arguments to find a GrowthMetric
     * @example
     * // Get one GrowthMetric
     * const growthMetric = await prisma.growthMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GrowthMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, GrowthMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GrowthMetricClient<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GrowthMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthMetricFindFirstArgs} args - Arguments to find a GrowthMetric
     * @example
     * // Get one GrowthMetric
     * const growthMetric = await prisma.growthMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GrowthMetricFindFirstArgs>(args?: SelectSubset<T, GrowthMetricFindFirstArgs<ExtArgs>>): Prisma__GrowthMetricClient<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GrowthMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthMetricFindFirstOrThrowArgs} args - Arguments to find a GrowthMetric
     * @example
     * // Get one GrowthMetric
     * const growthMetric = await prisma.growthMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GrowthMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, GrowthMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__GrowthMetricClient<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GrowthMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GrowthMetrics
     * const growthMetrics = await prisma.growthMetric.findMany()
     * 
     * // Get first 10 GrowthMetrics
     * const growthMetrics = await prisma.growthMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const growthMetricWithIdOnly = await prisma.growthMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GrowthMetricFindManyArgs>(args?: SelectSubset<T, GrowthMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GrowthMetric.
     * @param {GrowthMetricCreateArgs} args - Arguments to create a GrowthMetric.
     * @example
     * // Create one GrowthMetric
     * const GrowthMetric = await prisma.growthMetric.create({
     *   data: {
     *     // ... data to create a GrowthMetric
     *   }
     * })
     * 
     */
    create<T extends GrowthMetricCreateArgs>(args: SelectSubset<T, GrowthMetricCreateArgs<ExtArgs>>): Prisma__GrowthMetricClient<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GrowthMetrics.
     * @param {GrowthMetricCreateManyArgs} args - Arguments to create many GrowthMetrics.
     * @example
     * // Create many GrowthMetrics
     * const growthMetric = await prisma.growthMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GrowthMetricCreateManyArgs>(args?: SelectSubset<T, GrowthMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GrowthMetrics and returns the data saved in the database.
     * @param {GrowthMetricCreateManyAndReturnArgs} args - Arguments to create many GrowthMetrics.
     * @example
     * // Create many GrowthMetrics
     * const growthMetric = await prisma.growthMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GrowthMetrics and only return the `id`
     * const growthMetricWithIdOnly = await prisma.growthMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GrowthMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, GrowthMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GrowthMetric.
     * @param {GrowthMetricDeleteArgs} args - Arguments to delete one GrowthMetric.
     * @example
     * // Delete one GrowthMetric
     * const GrowthMetric = await prisma.growthMetric.delete({
     *   where: {
     *     // ... filter to delete one GrowthMetric
     *   }
     * })
     * 
     */
    delete<T extends GrowthMetricDeleteArgs>(args: SelectSubset<T, GrowthMetricDeleteArgs<ExtArgs>>): Prisma__GrowthMetricClient<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GrowthMetric.
     * @param {GrowthMetricUpdateArgs} args - Arguments to update one GrowthMetric.
     * @example
     * // Update one GrowthMetric
     * const growthMetric = await prisma.growthMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GrowthMetricUpdateArgs>(args: SelectSubset<T, GrowthMetricUpdateArgs<ExtArgs>>): Prisma__GrowthMetricClient<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GrowthMetrics.
     * @param {GrowthMetricDeleteManyArgs} args - Arguments to filter GrowthMetrics to delete.
     * @example
     * // Delete a few GrowthMetrics
     * const { count } = await prisma.growthMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GrowthMetricDeleteManyArgs>(args?: SelectSubset<T, GrowthMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GrowthMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GrowthMetrics
     * const growthMetric = await prisma.growthMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GrowthMetricUpdateManyArgs>(args: SelectSubset<T, GrowthMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GrowthMetrics and returns the data updated in the database.
     * @param {GrowthMetricUpdateManyAndReturnArgs} args - Arguments to update many GrowthMetrics.
     * @example
     * // Update many GrowthMetrics
     * const growthMetric = await prisma.growthMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GrowthMetrics and only return the `id`
     * const growthMetricWithIdOnly = await prisma.growthMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GrowthMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, GrowthMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GrowthMetric.
     * @param {GrowthMetricUpsertArgs} args - Arguments to update or create a GrowthMetric.
     * @example
     * // Update or create a GrowthMetric
     * const growthMetric = await prisma.growthMetric.upsert({
     *   create: {
     *     // ... data to create a GrowthMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GrowthMetric we want to update
     *   }
     * })
     */
    upsert<T extends GrowthMetricUpsertArgs>(args: SelectSubset<T, GrowthMetricUpsertArgs<ExtArgs>>): Prisma__GrowthMetricClient<$Result.GetResult<Prisma.$GrowthMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GrowthMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthMetricCountArgs} args - Arguments to filter GrowthMetrics to count.
     * @example
     * // Count the number of GrowthMetrics
     * const count = await prisma.growthMetric.count({
     *   where: {
     *     // ... the filter for the GrowthMetrics we want to count
     *   }
     * })
    **/
    count<T extends GrowthMetricCountArgs>(
      args?: Subset<T, GrowthMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrowthMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GrowthMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrowthMetricAggregateArgs>(args: Subset<T, GrowthMetricAggregateArgs>): Prisma.PrismaPromise<GetGrowthMetricAggregateType<T>>

    /**
     * Group by GrowthMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GrowthMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GrowthMetricGroupByArgs['orderBy'] }
        : { orderBy?: GrowthMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GrowthMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrowthMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GrowthMetric model
   */
  readonly fields: GrowthMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GrowthMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GrowthMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends RelationshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipDefaultArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GrowthMetric model
   */
  interface GrowthMetricFieldRefs {
    readonly id: FieldRef<"GrowthMetric", 'String'>
    readonly relationshipId: FieldRef<"GrowthMetric", 'String'>
    readonly bucketDate: FieldRef<"GrowthMetric", 'DateTime'>
    readonly messagesCount: FieldRef<"GrowthMetric", 'Int'>
    readonly positiveCount: FieldRef<"GrowthMetric", 'Int'>
    readonly neutralCount: FieldRef<"GrowthMetric", 'Int'>
    readonly negativeCount: FieldRef<"GrowthMetric", 'Int'>
    readonly metrics: FieldRef<"GrowthMetric", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * GrowthMetric findUnique
   */
  export type GrowthMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    /**
     * Filter, which GrowthMetric to fetch.
     */
    where: GrowthMetricWhereUniqueInput
  }

  /**
   * GrowthMetric findUniqueOrThrow
   */
  export type GrowthMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    /**
     * Filter, which GrowthMetric to fetch.
     */
    where: GrowthMetricWhereUniqueInput
  }

  /**
   * GrowthMetric findFirst
   */
  export type GrowthMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    /**
     * Filter, which GrowthMetric to fetch.
     */
    where?: GrowthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GrowthMetrics to fetch.
     */
    orderBy?: GrowthMetricOrderByWithRelationInput | GrowthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GrowthMetrics.
     */
    cursor?: GrowthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GrowthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GrowthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GrowthMetrics.
     */
    distinct?: GrowthMetricScalarFieldEnum | GrowthMetricScalarFieldEnum[]
  }

  /**
   * GrowthMetric findFirstOrThrow
   */
  export type GrowthMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    /**
     * Filter, which GrowthMetric to fetch.
     */
    where?: GrowthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GrowthMetrics to fetch.
     */
    orderBy?: GrowthMetricOrderByWithRelationInput | GrowthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GrowthMetrics.
     */
    cursor?: GrowthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GrowthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GrowthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GrowthMetrics.
     */
    distinct?: GrowthMetricScalarFieldEnum | GrowthMetricScalarFieldEnum[]
  }

  /**
   * GrowthMetric findMany
   */
  export type GrowthMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    /**
     * Filter, which GrowthMetrics to fetch.
     */
    where?: GrowthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GrowthMetrics to fetch.
     */
    orderBy?: GrowthMetricOrderByWithRelationInput | GrowthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GrowthMetrics.
     */
    cursor?: GrowthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GrowthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GrowthMetrics.
     */
    skip?: number
    distinct?: GrowthMetricScalarFieldEnum | GrowthMetricScalarFieldEnum[]
  }

  /**
   * GrowthMetric create
   */
  export type GrowthMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a GrowthMetric.
     */
    data: XOR<GrowthMetricCreateInput, GrowthMetricUncheckedCreateInput>
  }

  /**
   * GrowthMetric createMany
   */
  export type GrowthMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GrowthMetrics.
     */
    data: GrowthMetricCreateManyInput | GrowthMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GrowthMetric createManyAndReturn
   */
  export type GrowthMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * The data used to create many GrowthMetrics.
     */
    data: GrowthMetricCreateManyInput | GrowthMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GrowthMetric update
   */
  export type GrowthMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a GrowthMetric.
     */
    data: XOR<GrowthMetricUpdateInput, GrowthMetricUncheckedUpdateInput>
    /**
     * Choose, which GrowthMetric to update.
     */
    where: GrowthMetricWhereUniqueInput
  }

  /**
   * GrowthMetric updateMany
   */
  export type GrowthMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GrowthMetrics.
     */
    data: XOR<GrowthMetricUpdateManyMutationInput, GrowthMetricUncheckedUpdateManyInput>
    /**
     * Filter which GrowthMetrics to update
     */
    where?: GrowthMetricWhereInput
    /**
     * Limit how many GrowthMetrics to update.
     */
    limit?: number
  }

  /**
   * GrowthMetric updateManyAndReturn
   */
  export type GrowthMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * The data used to update GrowthMetrics.
     */
    data: XOR<GrowthMetricUpdateManyMutationInput, GrowthMetricUncheckedUpdateManyInput>
    /**
     * Filter which GrowthMetrics to update
     */
    where?: GrowthMetricWhereInput
    /**
     * Limit how many GrowthMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GrowthMetric upsert
   */
  export type GrowthMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the GrowthMetric to update in case it exists.
     */
    where: GrowthMetricWhereUniqueInput
    /**
     * In case the GrowthMetric found by the `where` argument doesn't exist, create a new GrowthMetric with this data.
     */
    create: XOR<GrowthMetricCreateInput, GrowthMetricUncheckedCreateInput>
    /**
     * In case the GrowthMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GrowthMetricUpdateInput, GrowthMetricUncheckedUpdateInput>
  }

  /**
   * GrowthMetric delete
   */
  export type GrowthMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
    /**
     * Filter which GrowthMetric to delete.
     */
    where: GrowthMetricWhereUniqueInput
  }

  /**
   * GrowthMetric deleteMany
   */
  export type GrowthMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GrowthMetrics to delete
     */
    where?: GrowthMetricWhereInput
    /**
     * Limit how many GrowthMetrics to delete.
     */
    limit?: number
  }

  /**
   * GrowthMetric without action
   */
  export type GrowthMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthMetric
     */
    select?: GrowthMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthMetric
     */
    omit?: GrowthMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthMetricInclude<ExtArgs> | null
  }


  /**
   * Model VoiceProfile
   */

  export type AggregateVoiceProfile = {
    _count: VoiceProfileCountAggregateOutputType | null
    _min: VoiceProfileMinAggregateOutputType | null
    _max: VoiceProfileMaxAggregateOutputType | null
  }

  export type VoiceProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sampleUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoiceProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sampleUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoiceProfileCountAggregateOutputType = {
    id: number
    userId: number
    settings: number
    sampleUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoiceProfileMinAggregateInputType = {
    id?: true
    userId?: true
    sampleUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoiceProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    sampleUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoiceProfileCountAggregateInputType = {
    id?: true
    userId?: true
    settings?: true
    sampleUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoiceProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoiceProfile to aggregate.
     */
    where?: VoiceProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceProfiles to fetch.
     */
    orderBy?: VoiceProfileOrderByWithRelationInput | VoiceProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoiceProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoiceProfiles
    **/
    _count?: true | VoiceProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoiceProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoiceProfileMaxAggregateInputType
  }

  export type GetVoiceProfileAggregateType<T extends VoiceProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateVoiceProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoiceProfile[P]>
      : GetScalarType<T[P], AggregateVoiceProfile[P]>
  }




  export type VoiceProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoiceProfileWhereInput
    orderBy?: VoiceProfileOrderByWithAggregationInput | VoiceProfileOrderByWithAggregationInput[]
    by: VoiceProfileScalarFieldEnum[] | VoiceProfileScalarFieldEnum
    having?: VoiceProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoiceProfileCountAggregateInputType | true
    _min?: VoiceProfileMinAggregateInputType
    _max?: VoiceProfileMaxAggregateInputType
  }

  export type VoiceProfileGroupByOutputType = {
    id: string
    userId: string
    settings: JsonValue | null
    sampleUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: VoiceProfileCountAggregateOutputType | null
    _min: VoiceProfileMinAggregateOutputType | null
    _max: VoiceProfileMaxAggregateOutputType | null
  }

  type GetVoiceProfileGroupByPayload<T extends VoiceProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoiceProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoiceProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoiceProfileGroupByOutputType[P]>
            : GetScalarType<T[P], VoiceProfileGroupByOutputType[P]>
        }
      >
    >


  export type VoiceProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    settings?: boolean
    sampleUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    samples?: boolean | VoiceProfile$samplesArgs<ExtArgs>
    _count?: boolean | VoiceProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceProfile"]>

  export type VoiceProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    settings?: boolean
    sampleUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceProfile"]>

  export type VoiceProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    settings?: boolean
    sampleUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceProfile"]>

  export type VoiceProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    settings?: boolean
    sampleUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoiceProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "settings" | "sampleUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["voiceProfile"]>
  export type VoiceProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    samples?: boolean | VoiceProfile$samplesArgs<ExtArgs>
    _count?: boolean | VoiceProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoiceProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoiceProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VoiceProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoiceProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      samples: Prisma.$VoiceSamplePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      settings: Prisma.JsonValue | null
      sampleUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["voiceProfile"]>
    composites: {}
  }

  type VoiceProfileGetPayload<S extends boolean | null | undefined | VoiceProfileDefaultArgs> = $Result.GetResult<Prisma.$VoiceProfilePayload, S>

  type VoiceProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoiceProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoiceProfileCountAggregateInputType | true
    }

  export interface VoiceProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoiceProfile'], meta: { name: 'VoiceProfile' } }
    /**
     * Find zero or one VoiceProfile that matches the filter.
     * @param {VoiceProfileFindUniqueArgs} args - Arguments to find a VoiceProfile
     * @example
     * // Get one VoiceProfile
     * const voiceProfile = await prisma.voiceProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoiceProfileFindUniqueArgs>(args: SelectSubset<T, VoiceProfileFindUniqueArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoiceProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoiceProfileFindUniqueOrThrowArgs} args - Arguments to find a VoiceProfile
     * @example
     * // Get one VoiceProfile
     * const voiceProfile = await prisma.voiceProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoiceProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, VoiceProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoiceProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceProfileFindFirstArgs} args - Arguments to find a VoiceProfile
     * @example
     * // Get one VoiceProfile
     * const voiceProfile = await prisma.voiceProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoiceProfileFindFirstArgs>(args?: SelectSubset<T, VoiceProfileFindFirstArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoiceProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceProfileFindFirstOrThrowArgs} args - Arguments to find a VoiceProfile
     * @example
     * // Get one VoiceProfile
     * const voiceProfile = await prisma.voiceProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoiceProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, VoiceProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoiceProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoiceProfiles
     * const voiceProfiles = await prisma.voiceProfile.findMany()
     * 
     * // Get first 10 VoiceProfiles
     * const voiceProfiles = await prisma.voiceProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voiceProfileWithIdOnly = await prisma.voiceProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoiceProfileFindManyArgs>(args?: SelectSubset<T, VoiceProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoiceProfile.
     * @param {VoiceProfileCreateArgs} args - Arguments to create a VoiceProfile.
     * @example
     * // Create one VoiceProfile
     * const VoiceProfile = await prisma.voiceProfile.create({
     *   data: {
     *     // ... data to create a VoiceProfile
     *   }
     * })
     * 
     */
    create<T extends VoiceProfileCreateArgs>(args: SelectSubset<T, VoiceProfileCreateArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoiceProfiles.
     * @param {VoiceProfileCreateManyArgs} args - Arguments to create many VoiceProfiles.
     * @example
     * // Create many VoiceProfiles
     * const voiceProfile = await prisma.voiceProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoiceProfileCreateManyArgs>(args?: SelectSubset<T, VoiceProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoiceProfiles and returns the data saved in the database.
     * @param {VoiceProfileCreateManyAndReturnArgs} args - Arguments to create many VoiceProfiles.
     * @example
     * // Create many VoiceProfiles
     * const voiceProfile = await prisma.voiceProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoiceProfiles and only return the `id`
     * const voiceProfileWithIdOnly = await prisma.voiceProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoiceProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, VoiceProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoiceProfile.
     * @param {VoiceProfileDeleteArgs} args - Arguments to delete one VoiceProfile.
     * @example
     * // Delete one VoiceProfile
     * const VoiceProfile = await prisma.voiceProfile.delete({
     *   where: {
     *     // ... filter to delete one VoiceProfile
     *   }
     * })
     * 
     */
    delete<T extends VoiceProfileDeleteArgs>(args: SelectSubset<T, VoiceProfileDeleteArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoiceProfile.
     * @param {VoiceProfileUpdateArgs} args - Arguments to update one VoiceProfile.
     * @example
     * // Update one VoiceProfile
     * const voiceProfile = await prisma.voiceProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoiceProfileUpdateArgs>(args: SelectSubset<T, VoiceProfileUpdateArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoiceProfiles.
     * @param {VoiceProfileDeleteManyArgs} args - Arguments to filter VoiceProfiles to delete.
     * @example
     * // Delete a few VoiceProfiles
     * const { count } = await prisma.voiceProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoiceProfileDeleteManyArgs>(args?: SelectSubset<T, VoiceProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoiceProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoiceProfiles
     * const voiceProfile = await prisma.voiceProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoiceProfileUpdateManyArgs>(args: SelectSubset<T, VoiceProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoiceProfiles and returns the data updated in the database.
     * @param {VoiceProfileUpdateManyAndReturnArgs} args - Arguments to update many VoiceProfiles.
     * @example
     * // Update many VoiceProfiles
     * const voiceProfile = await prisma.voiceProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoiceProfiles and only return the `id`
     * const voiceProfileWithIdOnly = await prisma.voiceProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoiceProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, VoiceProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoiceProfile.
     * @param {VoiceProfileUpsertArgs} args - Arguments to update or create a VoiceProfile.
     * @example
     * // Update or create a VoiceProfile
     * const voiceProfile = await prisma.voiceProfile.upsert({
     *   create: {
     *     // ... data to create a VoiceProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoiceProfile we want to update
     *   }
     * })
     */
    upsert<T extends VoiceProfileUpsertArgs>(args: SelectSubset<T, VoiceProfileUpsertArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoiceProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceProfileCountArgs} args - Arguments to filter VoiceProfiles to count.
     * @example
     * // Count the number of VoiceProfiles
     * const count = await prisma.voiceProfile.count({
     *   where: {
     *     // ... the filter for the VoiceProfiles we want to count
     *   }
     * })
    **/
    count<T extends VoiceProfileCountArgs>(
      args?: Subset<T, VoiceProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoiceProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoiceProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoiceProfileAggregateArgs>(args: Subset<T, VoiceProfileAggregateArgs>): Prisma.PrismaPromise<GetVoiceProfileAggregateType<T>>

    /**
     * Group by VoiceProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoiceProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoiceProfileGroupByArgs['orderBy'] }
        : { orderBy?: VoiceProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoiceProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoiceProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoiceProfile model
   */
  readonly fields: VoiceProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoiceProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoiceProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    samples<T extends VoiceProfile$samplesArgs<ExtArgs> = {}>(args?: Subset<T, VoiceProfile$samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoiceProfile model
   */
  interface VoiceProfileFieldRefs {
    readonly id: FieldRef<"VoiceProfile", 'String'>
    readonly userId: FieldRef<"VoiceProfile", 'String'>
    readonly settings: FieldRef<"VoiceProfile", 'Json'>
    readonly sampleUrl: FieldRef<"VoiceProfile", 'String'>
    readonly createdAt: FieldRef<"VoiceProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"VoiceProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VoiceProfile findUnique
   */
  export type VoiceProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    /**
     * Filter, which VoiceProfile to fetch.
     */
    where: VoiceProfileWhereUniqueInput
  }

  /**
   * VoiceProfile findUniqueOrThrow
   */
  export type VoiceProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    /**
     * Filter, which VoiceProfile to fetch.
     */
    where: VoiceProfileWhereUniqueInput
  }

  /**
   * VoiceProfile findFirst
   */
  export type VoiceProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    /**
     * Filter, which VoiceProfile to fetch.
     */
    where?: VoiceProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceProfiles to fetch.
     */
    orderBy?: VoiceProfileOrderByWithRelationInput | VoiceProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceProfiles.
     */
    cursor?: VoiceProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceProfiles.
     */
    distinct?: VoiceProfileScalarFieldEnum | VoiceProfileScalarFieldEnum[]
  }

  /**
   * VoiceProfile findFirstOrThrow
   */
  export type VoiceProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    /**
     * Filter, which VoiceProfile to fetch.
     */
    where?: VoiceProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceProfiles to fetch.
     */
    orderBy?: VoiceProfileOrderByWithRelationInput | VoiceProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceProfiles.
     */
    cursor?: VoiceProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceProfiles.
     */
    distinct?: VoiceProfileScalarFieldEnum | VoiceProfileScalarFieldEnum[]
  }

  /**
   * VoiceProfile findMany
   */
  export type VoiceProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    /**
     * Filter, which VoiceProfiles to fetch.
     */
    where?: VoiceProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceProfiles to fetch.
     */
    orderBy?: VoiceProfileOrderByWithRelationInput | VoiceProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoiceProfiles.
     */
    cursor?: VoiceProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceProfiles.
     */
    skip?: number
    distinct?: VoiceProfileScalarFieldEnum | VoiceProfileScalarFieldEnum[]
  }

  /**
   * VoiceProfile create
   */
  export type VoiceProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a VoiceProfile.
     */
    data: XOR<VoiceProfileCreateInput, VoiceProfileUncheckedCreateInput>
  }

  /**
   * VoiceProfile createMany
   */
  export type VoiceProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoiceProfiles.
     */
    data: VoiceProfileCreateManyInput | VoiceProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoiceProfile createManyAndReturn
   */
  export type VoiceProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * The data used to create many VoiceProfiles.
     */
    data: VoiceProfileCreateManyInput | VoiceProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoiceProfile update
   */
  export type VoiceProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a VoiceProfile.
     */
    data: XOR<VoiceProfileUpdateInput, VoiceProfileUncheckedUpdateInput>
    /**
     * Choose, which VoiceProfile to update.
     */
    where: VoiceProfileWhereUniqueInput
  }

  /**
   * VoiceProfile updateMany
   */
  export type VoiceProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoiceProfiles.
     */
    data: XOR<VoiceProfileUpdateManyMutationInput, VoiceProfileUncheckedUpdateManyInput>
    /**
     * Filter which VoiceProfiles to update
     */
    where?: VoiceProfileWhereInput
    /**
     * Limit how many VoiceProfiles to update.
     */
    limit?: number
  }

  /**
   * VoiceProfile updateManyAndReturn
   */
  export type VoiceProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * The data used to update VoiceProfiles.
     */
    data: XOR<VoiceProfileUpdateManyMutationInput, VoiceProfileUncheckedUpdateManyInput>
    /**
     * Filter which VoiceProfiles to update
     */
    where?: VoiceProfileWhereInput
    /**
     * Limit how many VoiceProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoiceProfile upsert
   */
  export type VoiceProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the VoiceProfile to update in case it exists.
     */
    where: VoiceProfileWhereUniqueInput
    /**
     * In case the VoiceProfile found by the `where` argument doesn't exist, create a new VoiceProfile with this data.
     */
    create: XOR<VoiceProfileCreateInput, VoiceProfileUncheckedCreateInput>
    /**
     * In case the VoiceProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoiceProfileUpdateInput, VoiceProfileUncheckedUpdateInput>
  }

  /**
   * VoiceProfile delete
   */
  export type VoiceProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
    /**
     * Filter which VoiceProfile to delete.
     */
    where: VoiceProfileWhereUniqueInput
  }

  /**
   * VoiceProfile deleteMany
   */
  export type VoiceProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoiceProfiles to delete
     */
    where?: VoiceProfileWhereInput
    /**
     * Limit how many VoiceProfiles to delete.
     */
    limit?: number
  }

  /**
   * VoiceProfile.samples
   */
  export type VoiceProfile$samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    where?: VoiceSampleWhereInput
    orderBy?: VoiceSampleOrderByWithRelationInput | VoiceSampleOrderByWithRelationInput[]
    cursor?: VoiceSampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoiceSampleScalarFieldEnum | VoiceSampleScalarFieldEnum[]
  }

  /**
   * VoiceProfile without action
   */
  export type VoiceProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceProfile
     */
    select?: VoiceProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceProfile
     */
    omit?: VoiceProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceProfileInclude<ExtArgs> | null
  }


  /**
   * Model VoiceSample
   */

  export type AggregateVoiceSample = {
    _count: VoiceSampleCountAggregateOutputType | null
    _avg: VoiceSampleAvgAggregateOutputType | null
    _sum: VoiceSampleSumAggregateOutputType | null
    _min: VoiceSampleMinAggregateOutputType | null
    _max: VoiceSampleMaxAggregateOutputType | null
  }

  export type VoiceSampleAvgAggregateOutputType = {
    durationMs: number | null
  }

  export type VoiceSampleSumAggregateOutputType = {
    durationMs: number | null
  }

  export type VoiceSampleMinAggregateOutputType = {
    id: string | null
    voiceProfileId: string | null
    url: string | null
    durationMs: number | null
    createdAt: Date | null
  }

  export type VoiceSampleMaxAggregateOutputType = {
    id: string | null
    voiceProfileId: string | null
    url: string | null
    durationMs: number | null
    createdAt: Date | null
  }

  export type VoiceSampleCountAggregateOutputType = {
    id: number
    voiceProfileId: number
    url: number
    durationMs: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type VoiceSampleAvgAggregateInputType = {
    durationMs?: true
  }

  export type VoiceSampleSumAggregateInputType = {
    durationMs?: true
  }

  export type VoiceSampleMinAggregateInputType = {
    id?: true
    voiceProfileId?: true
    url?: true
    durationMs?: true
    createdAt?: true
  }

  export type VoiceSampleMaxAggregateInputType = {
    id?: true
    voiceProfileId?: true
    url?: true
    durationMs?: true
    createdAt?: true
  }

  export type VoiceSampleCountAggregateInputType = {
    id?: true
    voiceProfileId?: true
    url?: true
    durationMs?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type VoiceSampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoiceSample to aggregate.
     */
    where?: VoiceSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceSamples to fetch.
     */
    orderBy?: VoiceSampleOrderByWithRelationInput | VoiceSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoiceSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoiceSamples
    **/
    _count?: true | VoiceSampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoiceSampleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoiceSampleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoiceSampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoiceSampleMaxAggregateInputType
  }

  export type GetVoiceSampleAggregateType<T extends VoiceSampleAggregateArgs> = {
        [P in keyof T & keyof AggregateVoiceSample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoiceSample[P]>
      : GetScalarType<T[P], AggregateVoiceSample[P]>
  }




  export type VoiceSampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoiceSampleWhereInput
    orderBy?: VoiceSampleOrderByWithAggregationInput | VoiceSampleOrderByWithAggregationInput[]
    by: VoiceSampleScalarFieldEnum[] | VoiceSampleScalarFieldEnum
    having?: VoiceSampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoiceSampleCountAggregateInputType | true
    _avg?: VoiceSampleAvgAggregateInputType
    _sum?: VoiceSampleSumAggregateInputType
    _min?: VoiceSampleMinAggregateInputType
    _max?: VoiceSampleMaxAggregateInputType
  }

  export type VoiceSampleGroupByOutputType = {
    id: string
    voiceProfileId: string
    url: string
    durationMs: number | null
    metadata: JsonValue | null
    createdAt: Date
    _count: VoiceSampleCountAggregateOutputType | null
    _avg: VoiceSampleAvgAggregateOutputType | null
    _sum: VoiceSampleSumAggregateOutputType | null
    _min: VoiceSampleMinAggregateOutputType | null
    _max: VoiceSampleMaxAggregateOutputType | null
  }

  type GetVoiceSampleGroupByPayload<T extends VoiceSampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoiceSampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoiceSampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoiceSampleGroupByOutputType[P]>
            : GetScalarType<T[P], VoiceSampleGroupByOutputType[P]>
        }
      >
    >


  export type VoiceSampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voiceProfileId?: boolean
    url?: boolean
    durationMs?: boolean
    metadata?: boolean
    createdAt?: boolean
    voiceProfile?: boolean | VoiceProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceSample"]>

  export type VoiceSampleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voiceProfileId?: boolean
    url?: boolean
    durationMs?: boolean
    metadata?: boolean
    createdAt?: boolean
    voiceProfile?: boolean | VoiceProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceSample"]>

  export type VoiceSampleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voiceProfileId?: boolean
    url?: boolean
    durationMs?: boolean
    metadata?: boolean
    createdAt?: boolean
    voiceProfile?: boolean | VoiceProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voiceSample"]>

  export type VoiceSampleSelectScalar = {
    id?: boolean
    voiceProfileId?: boolean
    url?: boolean
    durationMs?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type VoiceSampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voiceProfileId" | "url" | "durationMs" | "metadata" | "createdAt", ExtArgs["result"]["voiceSample"]>
  export type VoiceSampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voiceProfile?: boolean | VoiceProfileDefaultArgs<ExtArgs>
  }
  export type VoiceSampleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voiceProfile?: boolean | VoiceProfileDefaultArgs<ExtArgs>
  }
  export type VoiceSampleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    voiceProfile?: boolean | VoiceProfileDefaultArgs<ExtArgs>
  }

  export type $VoiceSamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoiceSample"
    objects: {
      voiceProfile: Prisma.$VoiceProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      voiceProfileId: string
      url: string
      durationMs: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["voiceSample"]>
    composites: {}
  }

  type VoiceSampleGetPayload<S extends boolean | null | undefined | VoiceSampleDefaultArgs> = $Result.GetResult<Prisma.$VoiceSamplePayload, S>

  type VoiceSampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoiceSampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoiceSampleCountAggregateInputType | true
    }

  export interface VoiceSampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoiceSample'], meta: { name: 'VoiceSample' } }
    /**
     * Find zero or one VoiceSample that matches the filter.
     * @param {VoiceSampleFindUniqueArgs} args - Arguments to find a VoiceSample
     * @example
     * // Get one VoiceSample
     * const voiceSample = await prisma.voiceSample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoiceSampleFindUniqueArgs>(args: SelectSubset<T, VoiceSampleFindUniqueArgs<ExtArgs>>): Prisma__VoiceSampleClient<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoiceSample that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoiceSampleFindUniqueOrThrowArgs} args - Arguments to find a VoiceSample
     * @example
     * // Get one VoiceSample
     * const voiceSample = await prisma.voiceSample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoiceSampleFindUniqueOrThrowArgs>(args: SelectSubset<T, VoiceSampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoiceSampleClient<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoiceSample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSampleFindFirstArgs} args - Arguments to find a VoiceSample
     * @example
     * // Get one VoiceSample
     * const voiceSample = await prisma.voiceSample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoiceSampleFindFirstArgs>(args?: SelectSubset<T, VoiceSampleFindFirstArgs<ExtArgs>>): Prisma__VoiceSampleClient<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoiceSample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSampleFindFirstOrThrowArgs} args - Arguments to find a VoiceSample
     * @example
     * // Get one VoiceSample
     * const voiceSample = await prisma.voiceSample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoiceSampleFindFirstOrThrowArgs>(args?: SelectSubset<T, VoiceSampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoiceSampleClient<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoiceSamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoiceSamples
     * const voiceSamples = await prisma.voiceSample.findMany()
     * 
     * // Get first 10 VoiceSamples
     * const voiceSamples = await prisma.voiceSample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voiceSampleWithIdOnly = await prisma.voiceSample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoiceSampleFindManyArgs>(args?: SelectSubset<T, VoiceSampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoiceSample.
     * @param {VoiceSampleCreateArgs} args - Arguments to create a VoiceSample.
     * @example
     * // Create one VoiceSample
     * const VoiceSample = await prisma.voiceSample.create({
     *   data: {
     *     // ... data to create a VoiceSample
     *   }
     * })
     * 
     */
    create<T extends VoiceSampleCreateArgs>(args: SelectSubset<T, VoiceSampleCreateArgs<ExtArgs>>): Prisma__VoiceSampleClient<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoiceSamples.
     * @param {VoiceSampleCreateManyArgs} args - Arguments to create many VoiceSamples.
     * @example
     * // Create many VoiceSamples
     * const voiceSample = await prisma.voiceSample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoiceSampleCreateManyArgs>(args?: SelectSubset<T, VoiceSampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoiceSamples and returns the data saved in the database.
     * @param {VoiceSampleCreateManyAndReturnArgs} args - Arguments to create many VoiceSamples.
     * @example
     * // Create many VoiceSamples
     * const voiceSample = await prisma.voiceSample.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoiceSamples and only return the `id`
     * const voiceSampleWithIdOnly = await prisma.voiceSample.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoiceSampleCreateManyAndReturnArgs>(args?: SelectSubset<T, VoiceSampleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoiceSample.
     * @param {VoiceSampleDeleteArgs} args - Arguments to delete one VoiceSample.
     * @example
     * // Delete one VoiceSample
     * const VoiceSample = await prisma.voiceSample.delete({
     *   where: {
     *     // ... filter to delete one VoiceSample
     *   }
     * })
     * 
     */
    delete<T extends VoiceSampleDeleteArgs>(args: SelectSubset<T, VoiceSampleDeleteArgs<ExtArgs>>): Prisma__VoiceSampleClient<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoiceSample.
     * @param {VoiceSampleUpdateArgs} args - Arguments to update one VoiceSample.
     * @example
     * // Update one VoiceSample
     * const voiceSample = await prisma.voiceSample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoiceSampleUpdateArgs>(args: SelectSubset<T, VoiceSampleUpdateArgs<ExtArgs>>): Prisma__VoiceSampleClient<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoiceSamples.
     * @param {VoiceSampleDeleteManyArgs} args - Arguments to filter VoiceSamples to delete.
     * @example
     * // Delete a few VoiceSamples
     * const { count } = await prisma.voiceSample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoiceSampleDeleteManyArgs>(args?: SelectSubset<T, VoiceSampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoiceSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoiceSamples
     * const voiceSample = await prisma.voiceSample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoiceSampleUpdateManyArgs>(args: SelectSubset<T, VoiceSampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoiceSamples and returns the data updated in the database.
     * @param {VoiceSampleUpdateManyAndReturnArgs} args - Arguments to update many VoiceSamples.
     * @example
     * // Update many VoiceSamples
     * const voiceSample = await prisma.voiceSample.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoiceSamples and only return the `id`
     * const voiceSampleWithIdOnly = await prisma.voiceSample.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoiceSampleUpdateManyAndReturnArgs>(args: SelectSubset<T, VoiceSampleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoiceSample.
     * @param {VoiceSampleUpsertArgs} args - Arguments to update or create a VoiceSample.
     * @example
     * // Update or create a VoiceSample
     * const voiceSample = await prisma.voiceSample.upsert({
     *   create: {
     *     // ... data to create a VoiceSample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoiceSample we want to update
     *   }
     * })
     */
    upsert<T extends VoiceSampleUpsertArgs>(args: SelectSubset<T, VoiceSampleUpsertArgs<ExtArgs>>): Prisma__VoiceSampleClient<$Result.GetResult<Prisma.$VoiceSamplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoiceSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSampleCountArgs} args - Arguments to filter VoiceSamples to count.
     * @example
     * // Count the number of VoiceSamples
     * const count = await prisma.voiceSample.count({
     *   where: {
     *     // ... the filter for the VoiceSamples we want to count
     *   }
     * })
    **/
    count<T extends VoiceSampleCountArgs>(
      args?: Subset<T, VoiceSampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoiceSampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoiceSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoiceSampleAggregateArgs>(args: Subset<T, VoiceSampleAggregateArgs>): Prisma.PrismaPromise<GetVoiceSampleAggregateType<T>>

    /**
     * Group by VoiceSample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoiceSampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoiceSampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoiceSampleGroupByArgs['orderBy'] }
        : { orderBy?: VoiceSampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoiceSampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoiceSampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoiceSample model
   */
  readonly fields: VoiceSampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoiceSample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoiceSampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    voiceProfile<T extends VoiceProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoiceProfileDefaultArgs<ExtArgs>>): Prisma__VoiceProfileClient<$Result.GetResult<Prisma.$VoiceProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoiceSample model
   */
  interface VoiceSampleFieldRefs {
    readonly id: FieldRef<"VoiceSample", 'String'>
    readonly voiceProfileId: FieldRef<"VoiceSample", 'String'>
    readonly url: FieldRef<"VoiceSample", 'String'>
    readonly durationMs: FieldRef<"VoiceSample", 'Int'>
    readonly metadata: FieldRef<"VoiceSample", 'Json'>
    readonly createdAt: FieldRef<"VoiceSample", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VoiceSample findUnique
   */
  export type VoiceSampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSample to fetch.
     */
    where: VoiceSampleWhereUniqueInput
  }

  /**
   * VoiceSample findUniqueOrThrow
   */
  export type VoiceSampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSample to fetch.
     */
    where: VoiceSampleWhereUniqueInput
  }

  /**
   * VoiceSample findFirst
   */
  export type VoiceSampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSample to fetch.
     */
    where?: VoiceSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceSamples to fetch.
     */
    orderBy?: VoiceSampleOrderByWithRelationInput | VoiceSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceSamples.
     */
    cursor?: VoiceSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceSamples.
     */
    distinct?: VoiceSampleScalarFieldEnum | VoiceSampleScalarFieldEnum[]
  }

  /**
   * VoiceSample findFirstOrThrow
   */
  export type VoiceSampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSample to fetch.
     */
    where?: VoiceSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceSamples to fetch.
     */
    orderBy?: VoiceSampleOrderByWithRelationInput | VoiceSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoiceSamples.
     */
    cursor?: VoiceSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoiceSamples.
     */
    distinct?: VoiceSampleScalarFieldEnum | VoiceSampleScalarFieldEnum[]
  }

  /**
   * VoiceSample findMany
   */
  export type VoiceSampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    /**
     * Filter, which VoiceSamples to fetch.
     */
    where?: VoiceSampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoiceSamples to fetch.
     */
    orderBy?: VoiceSampleOrderByWithRelationInput | VoiceSampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoiceSamples.
     */
    cursor?: VoiceSampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoiceSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoiceSamples.
     */
    skip?: number
    distinct?: VoiceSampleScalarFieldEnum | VoiceSampleScalarFieldEnum[]
  }

  /**
   * VoiceSample create
   */
  export type VoiceSampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    /**
     * The data needed to create a VoiceSample.
     */
    data: XOR<VoiceSampleCreateInput, VoiceSampleUncheckedCreateInput>
  }

  /**
   * VoiceSample createMany
   */
  export type VoiceSampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoiceSamples.
     */
    data: VoiceSampleCreateManyInput | VoiceSampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoiceSample createManyAndReturn
   */
  export type VoiceSampleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * The data used to create many VoiceSamples.
     */
    data: VoiceSampleCreateManyInput | VoiceSampleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoiceSample update
   */
  export type VoiceSampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    /**
     * The data needed to update a VoiceSample.
     */
    data: XOR<VoiceSampleUpdateInput, VoiceSampleUncheckedUpdateInput>
    /**
     * Choose, which VoiceSample to update.
     */
    where: VoiceSampleWhereUniqueInput
  }

  /**
   * VoiceSample updateMany
   */
  export type VoiceSampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoiceSamples.
     */
    data: XOR<VoiceSampleUpdateManyMutationInput, VoiceSampleUncheckedUpdateManyInput>
    /**
     * Filter which VoiceSamples to update
     */
    where?: VoiceSampleWhereInput
    /**
     * Limit how many VoiceSamples to update.
     */
    limit?: number
  }

  /**
   * VoiceSample updateManyAndReturn
   */
  export type VoiceSampleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * The data used to update VoiceSamples.
     */
    data: XOR<VoiceSampleUpdateManyMutationInput, VoiceSampleUncheckedUpdateManyInput>
    /**
     * Filter which VoiceSamples to update
     */
    where?: VoiceSampleWhereInput
    /**
     * Limit how many VoiceSamples to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoiceSample upsert
   */
  export type VoiceSampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    /**
     * The filter to search for the VoiceSample to update in case it exists.
     */
    where: VoiceSampleWhereUniqueInput
    /**
     * In case the VoiceSample found by the `where` argument doesn't exist, create a new VoiceSample with this data.
     */
    create: XOR<VoiceSampleCreateInput, VoiceSampleUncheckedCreateInput>
    /**
     * In case the VoiceSample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoiceSampleUpdateInput, VoiceSampleUncheckedUpdateInput>
  }

  /**
   * VoiceSample delete
   */
  export type VoiceSampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
    /**
     * Filter which VoiceSample to delete.
     */
    where: VoiceSampleWhereUniqueInput
  }

  /**
   * VoiceSample deleteMany
   */
  export type VoiceSampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoiceSamples to delete
     */
    where?: VoiceSampleWhereInput
    /**
     * Limit how many VoiceSamples to delete.
     */
    limit?: number
  }

  /**
   * VoiceSample without action
   */
  export type VoiceSampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoiceSample
     */
    select?: VoiceSampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoiceSample
     */
    omit?: VoiceSampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoiceSampleInclude<ExtArgs> | null
  }


  /**
   * Model AvatarProfile
   */

  export type AggregateAvatarProfile = {
    _count: AvatarProfileCountAggregateOutputType | null
    _min: AvatarProfileMinAggregateOutputType | null
    _max: AvatarProfileMaxAggregateOutputType | null
  }

  export type AvatarProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvatarProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AvatarProfileCountAggregateOutputType = {
    id: number
    userId: number
    settings: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AvatarProfileMinAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvatarProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AvatarProfileCountAggregateInputType = {
    id?: true
    userId?: true
    settings?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AvatarProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarProfile to aggregate.
     */
    where?: AvatarProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarProfiles to fetch.
     */
    orderBy?: AvatarProfileOrderByWithRelationInput | AvatarProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvatarProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AvatarProfiles
    **/
    _count?: true | AvatarProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvatarProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvatarProfileMaxAggregateInputType
  }

  export type GetAvatarProfileAggregateType<T extends AvatarProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateAvatarProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvatarProfile[P]>
      : GetScalarType<T[P], AggregateAvatarProfile[P]>
  }




  export type AvatarProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvatarProfileWhereInput
    orderBy?: AvatarProfileOrderByWithAggregationInput | AvatarProfileOrderByWithAggregationInput[]
    by: AvatarProfileScalarFieldEnum[] | AvatarProfileScalarFieldEnum
    having?: AvatarProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvatarProfileCountAggregateInputType | true
    _min?: AvatarProfileMinAggregateInputType
    _max?: AvatarProfileMaxAggregateInputType
  }

  export type AvatarProfileGroupByOutputType = {
    id: string
    userId: string
    settings: JsonValue | null
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: AvatarProfileCountAggregateOutputType | null
    _min: AvatarProfileMinAggregateOutputType | null
    _max: AvatarProfileMaxAggregateOutputType | null
  }

  type GetAvatarProfileGroupByPayload<T extends AvatarProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvatarProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvatarProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvatarProfileGroupByOutputType[P]>
            : GetScalarType<T[P], AvatarProfileGroupByOutputType[P]>
        }
      >
    >


  export type AvatarProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    settings?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    assets?: boolean | AvatarProfile$assetsArgs<ExtArgs>
    _count?: boolean | AvatarProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avatarProfile"]>

  export type AvatarProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    settings?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avatarProfile"]>

  export type AvatarProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    settings?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avatarProfile"]>

  export type AvatarProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    settings?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AvatarProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "settings" | "imageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["avatarProfile"]>
  export type AvatarProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    assets?: boolean | AvatarProfile$assetsArgs<ExtArgs>
    _count?: boolean | AvatarProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AvatarProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AvatarProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AvatarProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AvatarProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      assets: Prisma.$AvatarAssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      settings: Prisma.JsonValue | null
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["avatarProfile"]>
    composites: {}
  }

  type AvatarProfileGetPayload<S extends boolean | null | undefined | AvatarProfileDefaultArgs> = $Result.GetResult<Prisma.$AvatarProfilePayload, S>

  type AvatarProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvatarProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvatarProfileCountAggregateInputType | true
    }

  export interface AvatarProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AvatarProfile'], meta: { name: 'AvatarProfile' } }
    /**
     * Find zero or one AvatarProfile that matches the filter.
     * @param {AvatarProfileFindUniqueArgs} args - Arguments to find a AvatarProfile
     * @example
     * // Get one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvatarProfileFindUniqueArgs>(args: SelectSubset<T, AvatarProfileFindUniqueArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AvatarProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvatarProfileFindUniqueOrThrowArgs} args - Arguments to find a AvatarProfile
     * @example
     * // Get one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvatarProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, AvatarProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileFindFirstArgs} args - Arguments to find a AvatarProfile
     * @example
     * // Get one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvatarProfileFindFirstArgs>(args?: SelectSubset<T, AvatarProfileFindFirstArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileFindFirstOrThrowArgs} args - Arguments to find a AvatarProfile
     * @example
     * // Get one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvatarProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, AvatarProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AvatarProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AvatarProfiles
     * const avatarProfiles = await prisma.avatarProfile.findMany()
     * 
     * // Get first 10 AvatarProfiles
     * const avatarProfiles = await prisma.avatarProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avatarProfileWithIdOnly = await prisma.avatarProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvatarProfileFindManyArgs>(args?: SelectSubset<T, AvatarProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AvatarProfile.
     * @param {AvatarProfileCreateArgs} args - Arguments to create a AvatarProfile.
     * @example
     * // Create one AvatarProfile
     * const AvatarProfile = await prisma.avatarProfile.create({
     *   data: {
     *     // ... data to create a AvatarProfile
     *   }
     * })
     * 
     */
    create<T extends AvatarProfileCreateArgs>(args: SelectSubset<T, AvatarProfileCreateArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AvatarProfiles.
     * @param {AvatarProfileCreateManyArgs} args - Arguments to create many AvatarProfiles.
     * @example
     * // Create many AvatarProfiles
     * const avatarProfile = await prisma.avatarProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvatarProfileCreateManyArgs>(args?: SelectSubset<T, AvatarProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AvatarProfiles and returns the data saved in the database.
     * @param {AvatarProfileCreateManyAndReturnArgs} args - Arguments to create many AvatarProfiles.
     * @example
     * // Create many AvatarProfiles
     * const avatarProfile = await prisma.avatarProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AvatarProfiles and only return the `id`
     * const avatarProfileWithIdOnly = await prisma.avatarProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvatarProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, AvatarProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AvatarProfile.
     * @param {AvatarProfileDeleteArgs} args - Arguments to delete one AvatarProfile.
     * @example
     * // Delete one AvatarProfile
     * const AvatarProfile = await prisma.avatarProfile.delete({
     *   where: {
     *     // ... filter to delete one AvatarProfile
     *   }
     * })
     * 
     */
    delete<T extends AvatarProfileDeleteArgs>(args: SelectSubset<T, AvatarProfileDeleteArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AvatarProfile.
     * @param {AvatarProfileUpdateArgs} args - Arguments to update one AvatarProfile.
     * @example
     * // Update one AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvatarProfileUpdateArgs>(args: SelectSubset<T, AvatarProfileUpdateArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AvatarProfiles.
     * @param {AvatarProfileDeleteManyArgs} args - Arguments to filter AvatarProfiles to delete.
     * @example
     * // Delete a few AvatarProfiles
     * const { count } = await prisma.avatarProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvatarProfileDeleteManyArgs>(args?: SelectSubset<T, AvatarProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvatarProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AvatarProfiles
     * const avatarProfile = await prisma.avatarProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvatarProfileUpdateManyArgs>(args: SelectSubset<T, AvatarProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvatarProfiles and returns the data updated in the database.
     * @param {AvatarProfileUpdateManyAndReturnArgs} args - Arguments to update many AvatarProfiles.
     * @example
     * // Update many AvatarProfiles
     * const avatarProfile = await prisma.avatarProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AvatarProfiles and only return the `id`
     * const avatarProfileWithIdOnly = await prisma.avatarProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvatarProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, AvatarProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AvatarProfile.
     * @param {AvatarProfileUpsertArgs} args - Arguments to update or create a AvatarProfile.
     * @example
     * // Update or create a AvatarProfile
     * const avatarProfile = await prisma.avatarProfile.upsert({
     *   create: {
     *     // ... data to create a AvatarProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AvatarProfile we want to update
     *   }
     * })
     */
    upsert<T extends AvatarProfileUpsertArgs>(args: SelectSubset<T, AvatarProfileUpsertArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AvatarProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileCountArgs} args - Arguments to filter AvatarProfiles to count.
     * @example
     * // Count the number of AvatarProfiles
     * const count = await prisma.avatarProfile.count({
     *   where: {
     *     // ... the filter for the AvatarProfiles we want to count
     *   }
     * })
    **/
    count<T extends AvatarProfileCountArgs>(
      args?: Subset<T, AvatarProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvatarProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AvatarProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvatarProfileAggregateArgs>(args: Subset<T, AvatarProfileAggregateArgs>): Prisma.PrismaPromise<GetAvatarProfileAggregateType<T>>

    /**
     * Group by AvatarProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvatarProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvatarProfileGroupByArgs['orderBy'] }
        : { orderBy?: AvatarProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvatarProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvatarProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AvatarProfile model
   */
  readonly fields: AvatarProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AvatarProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvatarProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assets<T extends AvatarProfile$assetsArgs<ExtArgs> = {}>(args?: Subset<T, AvatarProfile$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AvatarProfile model
   */
  interface AvatarProfileFieldRefs {
    readonly id: FieldRef<"AvatarProfile", 'String'>
    readonly userId: FieldRef<"AvatarProfile", 'String'>
    readonly settings: FieldRef<"AvatarProfile", 'Json'>
    readonly imageUrl: FieldRef<"AvatarProfile", 'String'>
    readonly createdAt: FieldRef<"AvatarProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"AvatarProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AvatarProfile findUnique
   */
  export type AvatarProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfile to fetch.
     */
    where: AvatarProfileWhereUniqueInput
  }

  /**
   * AvatarProfile findUniqueOrThrow
   */
  export type AvatarProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfile to fetch.
     */
    where: AvatarProfileWhereUniqueInput
  }

  /**
   * AvatarProfile findFirst
   */
  export type AvatarProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfile to fetch.
     */
    where?: AvatarProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarProfiles to fetch.
     */
    orderBy?: AvatarProfileOrderByWithRelationInput | AvatarProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarProfiles.
     */
    cursor?: AvatarProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarProfiles.
     */
    distinct?: AvatarProfileScalarFieldEnum | AvatarProfileScalarFieldEnum[]
  }

  /**
   * AvatarProfile findFirstOrThrow
   */
  export type AvatarProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfile to fetch.
     */
    where?: AvatarProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarProfiles to fetch.
     */
    orderBy?: AvatarProfileOrderByWithRelationInput | AvatarProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarProfiles.
     */
    cursor?: AvatarProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarProfiles.
     */
    distinct?: AvatarProfileScalarFieldEnum | AvatarProfileScalarFieldEnum[]
  }

  /**
   * AvatarProfile findMany
   */
  export type AvatarProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter, which AvatarProfiles to fetch.
     */
    where?: AvatarProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarProfiles to fetch.
     */
    orderBy?: AvatarProfileOrderByWithRelationInput | AvatarProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AvatarProfiles.
     */
    cursor?: AvatarProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarProfiles.
     */
    skip?: number
    distinct?: AvatarProfileScalarFieldEnum | AvatarProfileScalarFieldEnum[]
  }

  /**
   * AvatarProfile create
   */
  export type AvatarProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a AvatarProfile.
     */
    data: XOR<AvatarProfileCreateInput, AvatarProfileUncheckedCreateInput>
  }

  /**
   * AvatarProfile createMany
   */
  export type AvatarProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AvatarProfiles.
     */
    data: AvatarProfileCreateManyInput | AvatarProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AvatarProfile createManyAndReturn
   */
  export type AvatarProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * The data used to create many AvatarProfiles.
     */
    data: AvatarProfileCreateManyInput | AvatarProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvatarProfile update
   */
  export type AvatarProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a AvatarProfile.
     */
    data: XOR<AvatarProfileUpdateInput, AvatarProfileUncheckedUpdateInput>
    /**
     * Choose, which AvatarProfile to update.
     */
    where: AvatarProfileWhereUniqueInput
  }

  /**
   * AvatarProfile updateMany
   */
  export type AvatarProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AvatarProfiles.
     */
    data: XOR<AvatarProfileUpdateManyMutationInput, AvatarProfileUncheckedUpdateManyInput>
    /**
     * Filter which AvatarProfiles to update
     */
    where?: AvatarProfileWhereInput
    /**
     * Limit how many AvatarProfiles to update.
     */
    limit?: number
  }

  /**
   * AvatarProfile updateManyAndReturn
   */
  export type AvatarProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * The data used to update AvatarProfiles.
     */
    data: XOR<AvatarProfileUpdateManyMutationInput, AvatarProfileUncheckedUpdateManyInput>
    /**
     * Filter which AvatarProfiles to update
     */
    where?: AvatarProfileWhereInput
    /**
     * Limit how many AvatarProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvatarProfile upsert
   */
  export type AvatarProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the AvatarProfile to update in case it exists.
     */
    where: AvatarProfileWhereUniqueInput
    /**
     * In case the AvatarProfile found by the `where` argument doesn't exist, create a new AvatarProfile with this data.
     */
    create: XOR<AvatarProfileCreateInput, AvatarProfileUncheckedCreateInput>
    /**
     * In case the AvatarProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvatarProfileUpdateInput, AvatarProfileUncheckedUpdateInput>
  }

  /**
   * AvatarProfile delete
   */
  export type AvatarProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
    /**
     * Filter which AvatarProfile to delete.
     */
    where: AvatarProfileWhereUniqueInput
  }

  /**
   * AvatarProfile deleteMany
   */
  export type AvatarProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarProfiles to delete
     */
    where?: AvatarProfileWhereInput
    /**
     * Limit how many AvatarProfiles to delete.
     */
    limit?: number
  }

  /**
   * AvatarProfile.assets
   */
  export type AvatarProfile$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    where?: AvatarAssetWhereInput
    orderBy?: AvatarAssetOrderByWithRelationInput | AvatarAssetOrderByWithRelationInput[]
    cursor?: AvatarAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvatarAssetScalarFieldEnum | AvatarAssetScalarFieldEnum[]
  }

  /**
   * AvatarProfile without action
   */
  export type AvatarProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarProfile
     */
    select?: AvatarProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarProfile
     */
    omit?: AvatarProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarProfileInclude<ExtArgs> | null
  }


  /**
   * Model AvatarAsset
   */

  export type AggregateAvatarAsset = {
    _count: AvatarAssetCountAggregateOutputType | null
    _min: AvatarAssetMinAggregateOutputType | null
    _max: AvatarAssetMaxAggregateOutputType | null
  }

  export type AvatarAssetMinAggregateOutputType = {
    id: string | null
    avatarProfileId: string | null
    url: string | null
    description: string | null
    createdAt: Date | null
  }

  export type AvatarAssetMaxAggregateOutputType = {
    id: string | null
    avatarProfileId: string | null
    url: string | null
    description: string | null
    createdAt: Date | null
  }

  export type AvatarAssetCountAggregateOutputType = {
    id: number
    avatarProfileId: number
    url: number
    description: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AvatarAssetMinAggregateInputType = {
    id?: true
    avatarProfileId?: true
    url?: true
    description?: true
    createdAt?: true
  }

  export type AvatarAssetMaxAggregateInputType = {
    id?: true
    avatarProfileId?: true
    url?: true
    description?: true
    createdAt?: true
  }

  export type AvatarAssetCountAggregateInputType = {
    id?: true
    avatarProfileId?: true
    url?: true
    description?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AvatarAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarAsset to aggregate.
     */
    where?: AvatarAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarAssets to fetch.
     */
    orderBy?: AvatarAssetOrderByWithRelationInput | AvatarAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvatarAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AvatarAssets
    **/
    _count?: true | AvatarAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvatarAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvatarAssetMaxAggregateInputType
  }

  export type GetAvatarAssetAggregateType<T extends AvatarAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAvatarAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvatarAsset[P]>
      : GetScalarType<T[P], AggregateAvatarAsset[P]>
  }




  export type AvatarAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvatarAssetWhereInput
    orderBy?: AvatarAssetOrderByWithAggregationInput | AvatarAssetOrderByWithAggregationInput[]
    by: AvatarAssetScalarFieldEnum[] | AvatarAssetScalarFieldEnum
    having?: AvatarAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvatarAssetCountAggregateInputType | true
    _min?: AvatarAssetMinAggregateInputType
    _max?: AvatarAssetMaxAggregateInputType
  }

  export type AvatarAssetGroupByOutputType = {
    id: string
    avatarProfileId: string
    url: string
    description: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AvatarAssetCountAggregateOutputType | null
    _min: AvatarAssetMinAggregateOutputType | null
    _max: AvatarAssetMaxAggregateOutputType | null
  }

  type GetAvatarAssetGroupByPayload<T extends AvatarAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvatarAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvatarAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvatarAssetGroupByOutputType[P]>
            : GetScalarType<T[P], AvatarAssetGroupByOutputType[P]>
        }
      >
    >


  export type AvatarAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatarProfileId?: boolean
    url?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    avatarProfile?: boolean | AvatarProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avatarAsset"]>

  export type AvatarAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatarProfileId?: boolean
    url?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    avatarProfile?: boolean | AvatarProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avatarAsset"]>

  export type AvatarAssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatarProfileId?: boolean
    url?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    avatarProfile?: boolean | AvatarProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avatarAsset"]>

  export type AvatarAssetSelectScalar = {
    id?: boolean
    avatarProfileId?: boolean
    url?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AvatarAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "avatarProfileId" | "url" | "description" | "metadata" | "createdAt", ExtArgs["result"]["avatarAsset"]>
  export type AvatarAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarProfile?: boolean | AvatarProfileDefaultArgs<ExtArgs>
  }
  export type AvatarAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarProfile?: boolean | AvatarProfileDefaultArgs<ExtArgs>
  }
  export type AvatarAssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarProfile?: boolean | AvatarProfileDefaultArgs<ExtArgs>
  }

  export type $AvatarAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AvatarAsset"
    objects: {
      avatarProfile: Prisma.$AvatarProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      avatarProfileId: string
      url: string
      description: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["avatarAsset"]>
    composites: {}
  }

  type AvatarAssetGetPayload<S extends boolean | null | undefined | AvatarAssetDefaultArgs> = $Result.GetResult<Prisma.$AvatarAssetPayload, S>

  type AvatarAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvatarAssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvatarAssetCountAggregateInputType | true
    }

  export interface AvatarAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AvatarAsset'], meta: { name: 'AvatarAsset' } }
    /**
     * Find zero or one AvatarAsset that matches the filter.
     * @param {AvatarAssetFindUniqueArgs} args - Arguments to find a AvatarAsset
     * @example
     * // Get one AvatarAsset
     * const avatarAsset = await prisma.avatarAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvatarAssetFindUniqueArgs>(args: SelectSubset<T, AvatarAssetFindUniqueArgs<ExtArgs>>): Prisma__AvatarAssetClient<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AvatarAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvatarAssetFindUniqueOrThrowArgs} args - Arguments to find a AvatarAsset
     * @example
     * // Get one AvatarAsset
     * const avatarAsset = await prisma.avatarAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvatarAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AvatarAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvatarAssetClient<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarAssetFindFirstArgs} args - Arguments to find a AvatarAsset
     * @example
     * // Get one AvatarAsset
     * const avatarAsset = await prisma.avatarAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvatarAssetFindFirstArgs>(args?: SelectSubset<T, AvatarAssetFindFirstArgs<ExtArgs>>): Prisma__AvatarAssetClient<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvatarAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarAssetFindFirstOrThrowArgs} args - Arguments to find a AvatarAsset
     * @example
     * // Get one AvatarAsset
     * const avatarAsset = await prisma.avatarAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvatarAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AvatarAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvatarAssetClient<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AvatarAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AvatarAssets
     * const avatarAssets = await prisma.avatarAsset.findMany()
     * 
     * // Get first 10 AvatarAssets
     * const avatarAssets = await prisma.avatarAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avatarAssetWithIdOnly = await prisma.avatarAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvatarAssetFindManyArgs>(args?: SelectSubset<T, AvatarAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AvatarAsset.
     * @param {AvatarAssetCreateArgs} args - Arguments to create a AvatarAsset.
     * @example
     * // Create one AvatarAsset
     * const AvatarAsset = await prisma.avatarAsset.create({
     *   data: {
     *     // ... data to create a AvatarAsset
     *   }
     * })
     * 
     */
    create<T extends AvatarAssetCreateArgs>(args: SelectSubset<T, AvatarAssetCreateArgs<ExtArgs>>): Prisma__AvatarAssetClient<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AvatarAssets.
     * @param {AvatarAssetCreateManyArgs} args - Arguments to create many AvatarAssets.
     * @example
     * // Create many AvatarAssets
     * const avatarAsset = await prisma.avatarAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvatarAssetCreateManyArgs>(args?: SelectSubset<T, AvatarAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AvatarAssets and returns the data saved in the database.
     * @param {AvatarAssetCreateManyAndReturnArgs} args - Arguments to create many AvatarAssets.
     * @example
     * // Create many AvatarAssets
     * const avatarAsset = await prisma.avatarAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AvatarAssets and only return the `id`
     * const avatarAssetWithIdOnly = await prisma.avatarAsset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvatarAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AvatarAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AvatarAsset.
     * @param {AvatarAssetDeleteArgs} args - Arguments to delete one AvatarAsset.
     * @example
     * // Delete one AvatarAsset
     * const AvatarAsset = await prisma.avatarAsset.delete({
     *   where: {
     *     // ... filter to delete one AvatarAsset
     *   }
     * })
     * 
     */
    delete<T extends AvatarAssetDeleteArgs>(args: SelectSubset<T, AvatarAssetDeleteArgs<ExtArgs>>): Prisma__AvatarAssetClient<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AvatarAsset.
     * @param {AvatarAssetUpdateArgs} args - Arguments to update one AvatarAsset.
     * @example
     * // Update one AvatarAsset
     * const avatarAsset = await prisma.avatarAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvatarAssetUpdateArgs>(args: SelectSubset<T, AvatarAssetUpdateArgs<ExtArgs>>): Prisma__AvatarAssetClient<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AvatarAssets.
     * @param {AvatarAssetDeleteManyArgs} args - Arguments to filter AvatarAssets to delete.
     * @example
     * // Delete a few AvatarAssets
     * const { count } = await prisma.avatarAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvatarAssetDeleteManyArgs>(args?: SelectSubset<T, AvatarAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvatarAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AvatarAssets
     * const avatarAsset = await prisma.avatarAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvatarAssetUpdateManyArgs>(args: SelectSubset<T, AvatarAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvatarAssets and returns the data updated in the database.
     * @param {AvatarAssetUpdateManyAndReturnArgs} args - Arguments to update many AvatarAssets.
     * @example
     * // Update many AvatarAssets
     * const avatarAsset = await prisma.avatarAsset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AvatarAssets and only return the `id`
     * const avatarAssetWithIdOnly = await prisma.avatarAsset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvatarAssetUpdateManyAndReturnArgs>(args: SelectSubset<T, AvatarAssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AvatarAsset.
     * @param {AvatarAssetUpsertArgs} args - Arguments to update or create a AvatarAsset.
     * @example
     * // Update or create a AvatarAsset
     * const avatarAsset = await prisma.avatarAsset.upsert({
     *   create: {
     *     // ... data to create a AvatarAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AvatarAsset we want to update
     *   }
     * })
     */
    upsert<T extends AvatarAssetUpsertArgs>(args: SelectSubset<T, AvatarAssetUpsertArgs<ExtArgs>>): Prisma__AvatarAssetClient<$Result.GetResult<Prisma.$AvatarAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AvatarAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarAssetCountArgs} args - Arguments to filter AvatarAssets to count.
     * @example
     * // Count the number of AvatarAssets
     * const count = await prisma.avatarAsset.count({
     *   where: {
     *     // ... the filter for the AvatarAssets we want to count
     *   }
     * })
    **/
    count<T extends AvatarAssetCountArgs>(
      args?: Subset<T, AvatarAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvatarAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AvatarAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvatarAssetAggregateArgs>(args: Subset<T, AvatarAssetAggregateArgs>): Prisma.PrismaPromise<GetAvatarAssetAggregateType<T>>

    /**
     * Group by AvatarAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvatarAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvatarAssetGroupByArgs['orderBy'] }
        : { orderBy?: AvatarAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvatarAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvatarAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AvatarAsset model
   */
  readonly fields: AvatarAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AvatarAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvatarAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avatarProfile<T extends AvatarProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AvatarProfileDefaultArgs<ExtArgs>>): Prisma__AvatarProfileClient<$Result.GetResult<Prisma.$AvatarProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AvatarAsset model
   */
  interface AvatarAssetFieldRefs {
    readonly id: FieldRef<"AvatarAsset", 'String'>
    readonly avatarProfileId: FieldRef<"AvatarAsset", 'String'>
    readonly url: FieldRef<"AvatarAsset", 'String'>
    readonly description: FieldRef<"AvatarAsset", 'String'>
    readonly metadata: FieldRef<"AvatarAsset", 'Json'>
    readonly createdAt: FieldRef<"AvatarAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AvatarAsset findUnique
   */
  export type AvatarAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    /**
     * Filter, which AvatarAsset to fetch.
     */
    where: AvatarAssetWhereUniqueInput
  }

  /**
   * AvatarAsset findUniqueOrThrow
   */
  export type AvatarAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    /**
     * Filter, which AvatarAsset to fetch.
     */
    where: AvatarAssetWhereUniqueInput
  }

  /**
   * AvatarAsset findFirst
   */
  export type AvatarAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    /**
     * Filter, which AvatarAsset to fetch.
     */
    where?: AvatarAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarAssets to fetch.
     */
    orderBy?: AvatarAssetOrderByWithRelationInput | AvatarAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarAssets.
     */
    cursor?: AvatarAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarAssets.
     */
    distinct?: AvatarAssetScalarFieldEnum | AvatarAssetScalarFieldEnum[]
  }

  /**
   * AvatarAsset findFirstOrThrow
   */
  export type AvatarAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    /**
     * Filter, which AvatarAsset to fetch.
     */
    where?: AvatarAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarAssets to fetch.
     */
    orderBy?: AvatarAssetOrderByWithRelationInput | AvatarAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvatarAssets.
     */
    cursor?: AvatarAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvatarAssets.
     */
    distinct?: AvatarAssetScalarFieldEnum | AvatarAssetScalarFieldEnum[]
  }

  /**
   * AvatarAsset findMany
   */
  export type AvatarAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    /**
     * Filter, which AvatarAssets to fetch.
     */
    where?: AvatarAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvatarAssets to fetch.
     */
    orderBy?: AvatarAssetOrderByWithRelationInput | AvatarAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AvatarAssets.
     */
    cursor?: AvatarAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvatarAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvatarAssets.
     */
    skip?: number
    distinct?: AvatarAssetScalarFieldEnum | AvatarAssetScalarFieldEnum[]
  }

  /**
   * AvatarAsset create
   */
  export type AvatarAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a AvatarAsset.
     */
    data: XOR<AvatarAssetCreateInput, AvatarAssetUncheckedCreateInput>
  }

  /**
   * AvatarAsset createMany
   */
  export type AvatarAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AvatarAssets.
     */
    data: AvatarAssetCreateManyInput | AvatarAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AvatarAsset createManyAndReturn
   */
  export type AvatarAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * The data used to create many AvatarAssets.
     */
    data: AvatarAssetCreateManyInput | AvatarAssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvatarAsset update
   */
  export type AvatarAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a AvatarAsset.
     */
    data: XOR<AvatarAssetUpdateInput, AvatarAssetUncheckedUpdateInput>
    /**
     * Choose, which AvatarAsset to update.
     */
    where: AvatarAssetWhereUniqueInput
  }

  /**
   * AvatarAsset updateMany
   */
  export type AvatarAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AvatarAssets.
     */
    data: XOR<AvatarAssetUpdateManyMutationInput, AvatarAssetUncheckedUpdateManyInput>
    /**
     * Filter which AvatarAssets to update
     */
    where?: AvatarAssetWhereInput
    /**
     * Limit how many AvatarAssets to update.
     */
    limit?: number
  }

  /**
   * AvatarAsset updateManyAndReturn
   */
  export type AvatarAssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * The data used to update AvatarAssets.
     */
    data: XOR<AvatarAssetUpdateManyMutationInput, AvatarAssetUncheckedUpdateManyInput>
    /**
     * Filter which AvatarAssets to update
     */
    where?: AvatarAssetWhereInput
    /**
     * Limit how many AvatarAssets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvatarAsset upsert
   */
  export type AvatarAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the AvatarAsset to update in case it exists.
     */
    where: AvatarAssetWhereUniqueInput
    /**
     * In case the AvatarAsset found by the `where` argument doesn't exist, create a new AvatarAsset with this data.
     */
    create: XOR<AvatarAssetCreateInput, AvatarAssetUncheckedCreateInput>
    /**
     * In case the AvatarAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvatarAssetUpdateInput, AvatarAssetUncheckedUpdateInput>
  }

  /**
   * AvatarAsset delete
   */
  export type AvatarAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
    /**
     * Filter which AvatarAsset to delete.
     */
    where: AvatarAssetWhereUniqueInput
  }

  /**
   * AvatarAsset deleteMany
   */
  export type AvatarAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvatarAssets to delete
     */
    where?: AvatarAssetWhereInput
    /**
     * Limit how many AvatarAssets to delete.
     */
    limit?: number
  }

  /**
   * AvatarAsset without action
   */
  export type AvatarAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvatarAsset
     */
    select?: AvatarAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvatarAsset
     */
    omit?: AvatarAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvatarAssetInclude<ExtArgs> | null
  }


  /**
   * Model Upload
   */

  export type AggregateUpload = {
    _count: UploadCountAggregateOutputType | null
    _avg: UploadAvgAggregateOutputType | null
    _sum: UploadSumAggregateOutputType | null
    _min: UploadMinAggregateOutputType | null
    _max: UploadMaxAggregateOutputType | null
  }

  export type UploadAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type UploadSumAggregateOutputType = {
    sizeBytes: number | null
  }

  export type UploadMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mediaType: $Enums.MediaType | null
    url: string | null
    originalName: string | null
    sizeBytes: number | null
    createdAt: Date | null
  }

  export type UploadMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mediaType: $Enums.MediaType | null
    url: string | null
    originalName: string | null
    sizeBytes: number | null
    createdAt: Date | null
  }

  export type UploadCountAggregateOutputType = {
    id: number
    userId: number
    mediaType: number
    url: number
    originalName: number
    sizeBytes: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type UploadAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type UploadSumAggregateInputType = {
    sizeBytes?: true
  }

  export type UploadMinAggregateInputType = {
    id?: true
    userId?: true
    mediaType?: true
    url?: true
    originalName?: true
    sizeBytes?: true
    createdAt?: true
  }

  export type UploadMaxAggregateInputType = {
    id?: true
    userId?: true
    mediaType?: true
    url?: true
    originalName?: true
    sizeBytes?: true
    createdAt?: true
  }

  export type UploadCountAggregateInputType = {
    id?: true
    userId?: true
    mediaType?: true
    url?: true
    originalName?: true
    sizeBytes?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type UploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Upload to aggregate.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Uploads
    **/
    _count?: true | UploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UploadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UploadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadMaxAggregateInputType
  }

  export type GetUploadAggregateType<T extends UploadAggregateArgs> = {
        [P in keyof T & keyof AggregateUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpload[P]>
      : GetScalarType<T[P], AggregateUpload[P]>
  }




  export type UploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadWhereInput
    orderBy?: UploadOrderByWithAggregationInput | UploadOrderByWithAggregationInput[]
    by: UploadScalarFieldEnum[] | UploadScalarFieldEnum
    having?: UploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadCountAggregateInputType | true
    _avg?: UploadAvgAggregateInputType
    _sum?: UploadSumAggregateInputType
    _min?: UploadMinAggregateInputType
    _max?: UploadMaxAggregateInputType
  }

  export type UploadGroupByOutputType = {
    id: string
    userId: string | null
    mediaType: $Enums.MediaType
    url: string
    originalName: string | null
    sizeBytes: number | null
    metadata: JsonValue | null
    createdAt: Date
    _count: UploadCountAggregateOutputType | null
    _avg: UploadAvgAggregateOutputType | null
    _sum: UploadSumAggregateOutputType | null
    _min: UploadMinAggregateOutputType | null
    _max: UploadMaxAggregateOutputType | null
  }

  type GetUploadGroupByPayload<T extends UploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadGroupByOutputType[P]>
            : GetScalarType<T[P], UploadGroupByOutputType[P]>
        }
      >
    >


  export type UploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mediaType?: boolean
    url?: boolean
    originalName?: boolean
    sizeBytes?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | Upload$userArgs<ExtArgs>
  }, ExtArgs["result"]["upload"]>

  export type UploadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mediaType?: boolean
    url?: boolean
    originalName?: boolean
    sizeBytes?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | Upload$userArgs<ExtArgs>
  }, ExtArgs["result"]["upload"]>

  export type UploadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mediaType?: boolean
    url?: boolean
    originalName?: boolean
    sizeBytes?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | Upload$userArgs<ExtArgs>
  }, ExtArgs["result"]["upload"]>

  export type UploadSelectScalar = {
    id?: boolean
    userId?: boolean
    mediaType?: boolean
    url?: boolean
    originalName?: boolean
    sizeBytes?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type UploadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mediaType" | "url" | "originalName" | "sizeBytes" | "metadata" | "createdAt", ExtArgs["result"]["upload"]>
  export type UploadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Upload$userArgs<ExtArgs>
  }
  export type UploadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Upload$userArgs<ExtArgs>
  }
  export type UploadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Upload$userArgs<ExtArgs>
  }

  export type $UploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Upload"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      mediaType: $Enums.MediaType
      url: string
      originalName: string | null
      sizeBytes: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["upload"]>
    composites: {}
  }

  type UploadGetPayload<S extends boolean | null | undefined | UploadDefaultArgs> = $Result.GetResult<Prisma.$UploadPayload, S>

  type UploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UploadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UploadCountAggregateInputType | true
    }

  export interface UploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Upload'], meta: { name: 'Upload' } }
    /**
     * Find zero or one Upload that matches the filter.
     * @param {UploadFindUniqueArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UploadFindUniqueArgs>(args: SelectSubset<T, UploadFindUniqueArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Upload that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UploadFindUniqueOrThrowArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UploadFindUniqueOrThrowArgs>(args: SelectSubset<T, UploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Upload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindFirstArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UploadFindFirstArgs>(args?: SelectSubset<T, UploadFindFirstArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Upload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindFirstOrThrowArgs} args - Arguments to find a Upload
     * @example
     * // Get one Upload
     * const upload = await prisma.upload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UploadFindFirstOrThrowArgs>(args?: SelectSubset<T, UploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Uploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Uploads
     * const uploads = await prisma.upload.findMany()
     * 
     * // Get first 10 Uploads
     * const uploads = await prisma.upload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadWithIdOnly = await prisma.upload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UploadFindManyArgs>(args?: SelectSubset<T, UploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Upload.
     * @param {UploadCreateArgs} args - Arguments to create a Upload.
     * @example
     * // Create one Upload
     * const Upload = await prisma.upload.create({
     *   data: {
     *     // ... data to create a Upload
     *   }
     * })
     * 
     */
    create<T extends UploadCreateArgs>(args: SelectSubset<T, UploadCreateArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Uploads.
     * @param {UploadCreateManyArgs} args - Arguments to create many Uploads.
     * @example
     * // Create many Uploads
     * const upload = await prisma.upload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UploadCreateManyArgs>(args?: SelectSubset<T, UploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Uploads and returns the data saved in the database.
     * @param {UploadCreateManyAndReturnArgs} args - Arguments to create many Uploads.
     * @example
     * // Create many Uploads
     * const upload = await prisma.upload.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Uploads and only return the `id`
     * const uploadWithIdOnly = await prisma.upload.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UploadCreateManyAndReturnArgs>(args?: SelectSubset<T, UploadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Upload.
     * @param {UploadDeleteArgs} args - Arguments to delete one Upload.
     * @example
     * // Delete one Upload
     * const Upload = await prisma.upload.delete({
     *   where: {
     *     // ... filter to delete one Upload
     *   }
     * })
     * 
     */
    delete<T extends UploadDeleteArgs>(args: SelectSubset<T, UploadDeleteArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Upload.
     * @param {UploadUpdateArgs} args - Arguments to update one Upload.
     * @example
     * // Update one Upload
     * const upload = await prisma.upload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UploadUpdateArgs>(args: SelectSubset<T, UploadUpdateArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Uploads.
     * @param {UploadDeleteManyArgs} args - Arguments to filter Uploads to delete.
     * @example
     * // Delete a few Uploads
     * const { count } = await prisma.upload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UploadDeleteManyArgs>(args?: SelectSubset<T, UploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Uploads
     * const upload = await prisma.upload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UploadUpdateManyArgs>(args: SelectSubset<T, UploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Uploads and returns the data updated in the database.
     * @param {UploadUpdateManyAndReturnArgs} args - Arguments to update many Uploads.
     * @example
     * // Update many Uploads
     * const upload = await prisma.upload.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Uploads and only return the `id`
     * const uploadWithIdOnly = await prisma.upload.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UploadUpdateManyAndReturnArgs>(args: SelectSubset<T, UploadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Upload.
     * @param {UploadUpsertArgs} args - Arguments to update or create a Upload.
     * @example
     * // Update or create a Upload
     * const upload = await prisma.upload.upsert({
     *   create: {
     *     // ... data to create a Upload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Upload we want to update
     *   }
     * })
     */
    upsert<T extends UploadUpsertArgs>(args: SelectSubset<T, UploadUpsertArgs<ExtArgs>>): Prisma__UploadClient<$Result.GetResult<Prisma.$UploadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Uploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadCountArgs} args - Arguments to filter Uploads to count.
     * @example
     * // Count the number of Uploads
     * const count = await prisma.upload.count({
     *   where: {
     *     // ... the filter for the Uploads we want to count
     *   }
     * })
    **/
    count<T extends UploadCountArgs>(
      args?: Subset<T, UploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Upload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadAggregateArgs>(args: Subset<T, UploadAggregateArgs>): Prisma.PrismaPromise<GetUploadAggregateType<T>>

    /**
     * Group by Upload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadGroupByArgs['orderBy'] }
        : { orderBy?: UploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Upload model
   */
  readonly fields: UploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Upload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Upload$userArgs<ExtArgs> = {}>(args?: Subset<T, Upload$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Upload model
   */
  interface UploadFieldRefs {
    readonly id: FieldRef<"Upload", 'String'>
    readonly userId: FieldRef<"Upload", 'String'>
    readonly mediaType: FieldRef<"Upload", 'MediaType'>
    readonly url: FieldRef<"Upload", 'String'>
    readonly originalName: FieldRef<"Upload", 'String'>
    readonly sizeBytes: FieldRef<"Upload", 'Int'>
    readonly metadata: FieldRef<"Upload", 'Json'>
    readonly createdAt: FieldRef<"Upload", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Upload findUnique
   */
  export type UploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload findUniqueOrThrow
   */
  export type UploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload findFirst
   */
  export type UploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Uploads.
     */
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Upload findFirstOrThrow
   */
  export type UploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Upload to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Uploads.
     */
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Upload findMany
   */
  export type UploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter, which Uploads to fetch.
     */
    where?: UploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Uploads to fetch.
     */
    orderBy?: UploadOrderByWithRelationInput | UploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Uploads.
     */
    cursor?: UploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Uploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Uploads.
     */
    skip?: number
    distinct?: UploadScalarFieldEnum | UploadScalarFieldEnum[]
  }

  /**
   * Upload create
   */
  export type UploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * The data needed to create a Upload.
     */
    data: XOR<UploadCreateInput, UploadUncheckedCreateInput>
  }

  /**
   * Upload createMany
   */
  export type UploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Uploads.
     */
    data: UploadCreateManyInput | UploadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Upload createManyAndReturn
   */
  export type UploadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * The data used to create many Uploads.
     */
    data: UploadCreateManyInput | UploadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Upload update
   */
  export type UploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * The data needed to update a Upload.
     */
    data: XOR<UploadUpdateInput, UploadUncheckedUpdateInput>
    /**
     * Choose, which Upload to update.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload updateMany
   */
  export type UploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Uploads.
     */
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyInput>
    /**
     * Filter which Uploads to update
     */
    where?: UploadWhereInput
    /**
     * Limit how many Uploads to update.
     */
    limit?: number
  }

  /**
   * Upload updateManyAndReturn
   */
  export type UploadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * The data used to update Uploads.
     */
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyInput>
    /**
     * Filter which Uploads to update
     */
    where?: UploadWhereInput
    /**
     * Limit how many Uploads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Upload upsert
   */
  export type UploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * The filter to search for the Upload to update in case it exists.
     */
    where: UploadWhereUniqueInput
    /**
     * In case the Upload found by the `where` argument doesn't exist, create a new Upload with this data.
     */
    create: XOR<UploadCreateInput, UploadUncheckedCreateInput>
    /**
     * In case the Upload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadUpdateInput, UploadUncheckedUpdateInput>
  }

  /**
   * Upload delete
   */
  export type UploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
    /**
     * Filter which Upload to delete.
     */
    where: UploadWhereUniqueInput
  }

  /**
   * Upload deleteMany
   */
  export type UploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Uploads to delete
     */
    where?: UploadWhereInput
    /**
     * Limit how many Uploads to delete.
     */
    limit?: number
  }

  /**
   * Upload.user
   */
  export type Upload$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Upload without action
   */
  export type UploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Upload
     */
    select?: UploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Upload
     */
    omit?: UploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadInclude<ExtArgs> | null
  }


  /**
   * Model UsageEvent
   */

  export type AggregateUsageEvent = {
    _count: UsageEventCountAggregateOutputType | null
    _min: UsageEventMinAggregateOutputType | null
    _max: UsageEventMaxAggregateOutputType | null
  }

  export type UsageEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.UsageEventType | null
    createdAt: Date | null
  }

  export type UsageEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.UsageEventType | null
    createdAt: Date | null
  }

  export type UsageEventCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type UsageEventMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type UsageEventMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type UsageEventCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type UsageEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageEvent to aggregate.
     */
    where?: UsageEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageEvents to fetch.
     */
    orderBy?: UsageEventOrderByWithRelationInput | UsageEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageEvents
    **/
    _count?: true | UsageEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageEventMaxAggregateInputType
  }

  export type GetUsageEventAggregateType<T extends UsageEventAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageEvent[P]>
      : GetScalarType<T[P], AggregateUsageEvent[P]>
  }




  export type UsageEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageEventWhereInput
    orderBy?: UsageEventOrderByWithAggregationInput | UsageEventOrderByWithAggregationInput[]
    by: UsageEventScalarFieldEnum[] | UsageEventScalarFieldEnum
    having?: UsageEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageEventCountAggregateInputType | true
    _min?: UsageEventMinAggregateInputType
    _max?: UsageEventMaxAggregateInputType
  }

  export type UsageEventGroupByOutputType = {
    id: string
    userId: string | null
    type: $Enums.UsageEventType
    metadata: JsonValue | null
    createdAt: Date
    _count: UsageEventCountAggregateOutputType | null
    _min: UsageEventMinAggregateOutputType | null
    _max: UsageEventMaxAggregateOutputType | null
  }

  type GetUsageEventGroupByPayload<T extends UsageEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageEventGroupByOutputType[P]>
            : GetScalarType<T[P], UsageEventGroupByOutputType[P]>
        }
      >
    >


  export type UsageEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UsageEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["usageEvent"]>

  export type UsageEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UsageEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["usageEvent"]>

  export type UsageEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UsageEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["usageEvent"]>

  export type UsageEventSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type UsageEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "metadata" | "createdAt", ExtArgs["result"]["usageEvent"]>
  export type UsageEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsageEvent$userArgs<ExtArgs>
  }
  export type UsageEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsageEvent$userArgs<ExtArgs>
  }
  export type UsageEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsageEvent$userArgs<ExtArgs>
  }

  export type $UsageEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      type: $Enums.UsageEventType
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["usageEvent"]>
    composites: {}
  }

  type UsageEventGetPayload<S extends boolean | null | undefined | UsageEventDefaultArgs> = $Result.GetResult<Prisma.$UsageEventPayload, S>

  type UsageEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageEventCountAggregateInputType | true
    }

  export interface UsageEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageEvent'], meta: { name: 'UsageEvent' } }
    /**
     * Find zero or one UsageEvent that matches the filter.
     * @param {UsageEventFindUniqueArgs} args - Arguments to find a UsageEvent
     * @example
     * // Get one UsageEvent
     * const usageEvent = await prisma.usageEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageEventFindUniqueArgs>(args: SelectSubset<T, UsageEventFindUniqueArgs<ExtArgs>>): Prisma__UsageEventClient<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsageEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageEventFindUniqueOrThrowArgs} args - Arguments to find a UsageEvent
     * @example
     * // Get one UsageEvent
     * const usageEvent = await prisma.usageEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageEventFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageEventClient<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageEventFindFirstArgs} args - Arguments to find a UsageEvent
     * @example
     * // Get one UsageEvent
     * const usageEvent = await prisma.usageEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageEventFindFirstArgs>(args?: SelectSubset<T, UsageEventFindFirstArgs<ExtArgs>>): Prisma__UsageEventClient<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageEventFindFirstOrThrowArgs} args - Arguments to find a UsageEvent
     * @example
     * // Get one UsageEvent
     * const usageEvent = await prisma.usageEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageEventFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageEventClient<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsageEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageEvents
     * const usageEvents = await prisma.usageEvent.findMany()
     * 
     * // Get first 10 UsageEvents
     * const usageEvents = await prisma.usageEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageEventWithIdOnly = await prisma.usageEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageEventFindManyArgs>(args?: SelectSubset<T, UsageEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsageEvent.
     * @param {UsageEventCreateArgs} args - Arguments to create a UsageEvent.
     * @example
     * // Create one UsageEvent
     * const UsageEvent = await prisma.usageEvent.create({
     *   data: {
     *     // ... data to create a UsageEvent
     *   }
     * })
     * 
     */
    create<T extends UsageEventCreateArgs>(args: SelectSubset<T, UsageEventCreateArgs<ExtArgs>>): Prisma__UsageEventClient<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsageEvents.
     * @param {UsageEventCreateManyArgs} args - Arguments to create many UsageEvents.
     * @example
     * // Create many UsageEvents
     * const usageEvent = await prisma.usageEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageEventCreateManyArgs>(args?: SelectSubset<T, UsageEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageEvents and returns the data saved in the database.
     * @param {UsageEventCreateManyAndReturnArgs} args - Arguments to create many UsageEvents.
     * @example
     * // Create many UsageEvents
     * const usageEvent = await prisma.usageEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageEvents and only return the `id`
     * const usageEventWithIdOnly = await prisma.usageEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageEventCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsageEvent.
     * @param {UsageEventDeleteArgs} args - Arguments to delete one UsageEvent.
     * @example
     * // Delete one UsageEvent
     * const UsageEvent = await prisma.usageEvent.delete({
     *   where: {
     *     // ... filter to delete one UsageEvent
     *   }
     * })
     * 
     */
    delete<T extends UsageEventDeleteArgs>(args: SelectSubset<T, UsageEventDeleteArgs<ExtArgs>>): Prisma__UsageEventClient<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsageEvent.
     * @param {UsageEventUpdateArgs} args - Arguments to update one UsageEvent.
     * @example
     * // Update one UsageEvent
     * const usageEvent = await prisma.usageEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageEventUpdateArgs>(args: SelectSubset<T, UsageEventUpdateArgs<ExtArgs>>): Prisma__UsageEventClient<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsageEvents.
     * @param {UsageEventDeleteManyArgs} args - Arguments to filter UsageEvents to delete.
     * @example
     * // Delete a few UsageEvents
     * const { count } = await prisma.usageEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageEventDeleteManyArgs>(args?: SelectSubset<T, UsageEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageEvents
     * const usageEvent = await prisma.usageEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageEventUpdateManyArgs>(args: SelectSubset<T, UsageEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageEvents and returns the data updated in the database.
     * @param {UsageEventUpdateManyAndReturnArgs} args - Arguments to update many UsageEvents.
     * @example
     * // Update many UsageEvents
     * const usageEvent = await prisma.usageEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageEvents and only return the `id`
     * const usageEventWithIdOnly = await prisma.usageEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageEventUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsageEvent.
     * @param {UsageEventUpsertArgs} args - Arguments to update or create a UsageEvent.
     * @example
     * // Update or create a UsageEvent
     * const usageEvent = await prisma.usageEvent.upsert({
     *   create: {
     *     // ... data to create a UsageEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageEvent we want to update
     *   }
     * })
     */
    upsert<T extends UsageEventUpsertArgs>(args: SelectSubset<T, UsageEventUpsertArgs<ExtArgs>>): Prisma__UsageEventClient<$Result.GetResult<Prisma.$UsageEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsageEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageEventCountArgs} args - Arguments to filter UsageEvents to count.
     * @example
     * // Count the number of UsageEvents
     * const count = await prisma.usageEvent.count({
     *   where: {
     *     // ... the filter for the UsageEvents we want to count
     *   }
     * })
    **/
    count<T extends UsageEventCountArgs>(
      args?: Subset<T, UsageEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageEventAggregateArgs>(args: Subset<T, UsageEventAggregateArgs>): Prisma.PrismaPromise<GetUsageEventAggregateType<T>>

    /**
     * Group by UsageEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageEventGroupByArgs['orderBy'] }
        : { orderBy?: UsageEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageEvent model
   */
  readonly fields: UsageEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsageEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, UsageEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageEvent model
   */
  interface UsageEventFieldRefs {
    readonly id: FieldRef<"UsageEvent", 'String'>
    readonly userId: FieldRef<"UsageEvent", 'String'>
    readonly type: FieldRef<"UsageEvent", 'UsageEventType'>
    readonly metadata: FieldRef<"UsageEvent", 'Json'>
    readonly createdAt: FieldRef<"UsageEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageEvent findUnique
   */
  export type UsageEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    /**
     * Filter, which UsageEvent to fetch.
     */
    where: UsageEventWhereUniqueInput
  }

  /**
   * UsageEvent findUniqueOrThrow
   */
  export type UsageEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    /**
     * Filter, which UsageEvent to fetch.
     */
    where: UsageEventWhereUniqueInput
  }

  /**
   * UsageEvent findFirst
   */
  export type UsageEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    /**
     * Filter, which UsageEvent to fetch.
     */
    where?: UsageEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageEvents to fetch.
     */
    orderBy?: UsageEventOrderByWithRelationInput | UsageEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageEvents.
     */
    cursor?: UsageEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageEvents.
     */
    distinct?: UsageEventScalarFieldEnum | UsageEventScalarFieldEnum[]
  }

  /**
   * UsageEvent findFirstOrThrow
   */
  export type UsageEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    /**
     * Filter, which UsageEvent to fetch.
     */
    where?: UsageEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageEvents to fetch.
     */
    orderBy?: UsageEventOrderByWithRelationInput | UsageEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageEvents.
     */
    cursor?: UsageEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageEvents.
     */
    distinct?: UsageEventScalarFieldEnum | UsageEventScalarFieldEnum[]
  }

  /**
   * UsageEvent findMany
   */
  export type UsageEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    /**
     * Filter, which UsageEvents to fetch.
     */
    where?: UsageEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageEvents to fetch.
     */
    orderBy?: UsageEventOrderByWithRelationInput | UsageEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageEvents.
     */
    cursor?: UsageEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageEvents.
     */
    skip?: number
    distinct?: UsageEventScalarFieldEnum | UsageEventScalarFieldEnum[]
  }

  /**
   * UsageEvent create
   */
  export type UsageEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageEvent.
     */
    data: XOR<UsageEventCreateInput, UsageEventUncheckedCreateInput>
  }

  /**
   * UsageEvent createMany
   */
  export type UsageEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageEvents.
     */
    data: UsageEventCreateManyInput | UsageEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageEvent createManyAndReturn
   */
  export type UsageEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * The data used to create many UsageEvents.
     */
    data: UsageEventCreateManyInput | UsageEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageEvent update
   */
  export type UsageEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageEvent.
     */
    data: XOR<UsageEventUpdateInput, UsageEventUncheckedUpdateInput>
    /**
     * Choose, which UsageEvent to update.
     */
    where: UsageEventWhereUniqueInput
  }

  /**
   * UsageEvent updateMany
   */
  export type UsageEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageEvents.
     */
    data: XOR<UsageEventUpdateManyMutationInput, UsageEventUncheckedUpdateManyInput>
    /**
     * Filter which UsageEvents to update
     */
    where?: UsageEventWhereInput
    /**
     * Limit how many UsageEvents to update.
     */
    limit?: number
  }

  /**
   * UsageEvent updateManyAndReturn
   */
  export type UsageEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * The data used to update UsageEvents.
     */
    data: XOR<UsageEventUpdateManyMutationInput, UsageEventUncheckedUpdateManyInput>
    /**
     * Filter which UsageEvents to update
     */
    where?: UsageEventWhereInput
    /**
     * Limit how many UsageEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageEvent upsert
   */
  export type UsageEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageEvent to update in case it exists.
     */
    where: UsageEventWhereUniqueInput
    /**
     * In case the UsageEvent found by the `where` argument doesn't exist, create a new UsageEvent with this data.
     */
    create: XOR<UsageEventCreateInput, UsageEventUncheckedCreateInput>
    /**
     * In case the UsageEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageEventUpdateInput, UsageEventUncheckedUpdateInput>
  }

  /**
   * UsageEvent delete
   */
  export type UsageEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
    /**
     * Filter which UsageEvent to delete.
     */
    where: UsageEventWhereUniqueInput
  }

  /**
   * UsageEvent deleteMany
   */
  export type UsageEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageEvents to delete
     */
    where?: UsageEventWhereInput
    /**
     * Limit how many UsageEvents to delete.
     */
    limit?: number
  }

  /**
   * UsageEvent.user
   */
  export type UsageEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UsageEvent without action
   */
  export type UsageEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageEvent
     */
    select?: UsageEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageEvent
     */
    omit?: UsageEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageEventInclude<ExtArgs> | null
  }


  /**
   * Model SystemMetric
   */

  export type AggregateSystemMetric = {
    _count: SystemMetricCountAggregateOutputType | null
    _avg: SystemMetricAvgAggregateOutputType | null
    _sum: SystemMetricSumAggregateOutputType | null
    _min: SystemMetricMinAggregateOutputType | null
    _max: SystemMetricMaxAggregateOutputType | null
  }

  export type SystemMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type SystemMetricSumAggregateOutputType = {
    value: number | null
  }

  export type SystemMetricMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    capturedAt: Date | null
  }

  export type SystemMetricMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    capturedAt: Date | null
  }

  export type SystemMetricCountAggregateOutputType = {
    id: number
    name: number
    labels: number
    value: number
    capturedAt: number
    _all: number
  }


  export type SystemMetricAvgAggregateInputType = {
    value?: true
  }

  export type SystemMetricSumAggregateInputType = {
    value?: true
  }

  export type SystemMetricMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    capturedAt?: true
  }

  export type SystemMetricMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    capturedAt?: true
  }

  export type SystemMetricCountAggregateInputType = {
    id?: true
    name?: true
    labels?: true
    value?: true
    capturedAt?: true
    _all?: true
  }

  export type SystemMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMetric to aggregate.
     */
    where?: SystemMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricOrderByWithRelationInput | SystemMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemMetrics
    **/
    _count?: true | SystemMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemMetricMaxAggregateInputType
  }

  export type GetSystemMetricAggregateType<T extends SystemMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemMetric[P]>
      : GetScalarType<T[P], AggregateSystemMetric[P]>
  }




  export type SystemMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemMetricWhereInput
    orderBy?: SystemMetricOrderByWithAggregationInput | SystemMetricOrderByWithAggregationInput[]
    by: SystemMetricScalarFieldEnum[] | SystemMetricScalarFieldEnum
    having?: SystemMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemMetricCountAggregateInputType | true
    _avg?: SystemMetricAvgAggregateInputType
    _sum?: SystemMetricSumAggregateInputType
    _min?: SystemMetricMinAggregateInputType
    _max?: SystemMetricMaxAggregateInputType
  }

  export type SystemMetricGroupByOutputType = {
    id: string
    name: string
    labels: JsonValue | null
    value: number
    capturedAt: Date
    _count: SystemMetricCountAggregateOutputType | null
    _avg: SystemMetricAvgAggregateOutputType | null
    _sum: SystemMetricSumAggregateOutputType | null
    _min: SystemMetricMinAggregateOutputType | null
    _max: SystemMetricMaxAggregateOutputType | null
  }

  type GetSystemMetricGroupByPayload<T extends SystemMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemMetricGroupByOutputType[P]>
            : GetScalarType<T[P], SystemMetricGroupByOutputType[P]>
        }
      >
    >


  export type SystemMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    labels?: boolean
    value?: boolean
    capturedAt?: boolean
  }, ExtArgs["result"]["systemMetric"]>

  export type SystemMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    labels?: boolean
    value?: boolean
    capturedAt?: boolean
  }, ExtArgs["result"]["systemMetric"]>

  export type SystemMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    labels?: boolean
    value?: boolean
    capturedAt?: boolean
  }, ExtArgs["result"]["systemMetric"]>

  export type SystemMetricSelectScalar = {
    id?: boolean
    name?: boolean
    labels?: boolean
    value?: boolean
    capturedAt?: boolean
  }

  export type SystemMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "labels" | "value" | "capturedAt", ExtArgs["result"]["systemMetric"]>

  export type $SystemMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      labels: Prisma.JsonValue | null
      value: number
      capturedAt: Date
    }, ExtArgs["result"]["systemMetric"]>
    composites: {}
  }

  type SystemMetricGetPayload<S extends boolean | null | undefined | SystemMetricDefaultArgs> = $Result.GetResult<Prisma.$SystemMetricPayload, S>

  type SystemMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemMetricCountAggregateInputType | true
    }

  export interface SystemMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemMetric'], meta: { name: 'SystemMetric' } }
    /**
     * Find zero or one SystemMetric that matches the filter.
     * @param {SystemMetricFindUniqueArgs} args - Arguments to find a SystemMetric
     * @example
     * // Get one SystemMetric
     * const systemMetric = await prisma.systemMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemMetricFindUniqueArgs>(args: SelectSubset<T, SystemMetricFindUniqueArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemMetricFindUniqueOrThrowArgs} args - Arguments to find a SystemMetric
     * @example
     * // Get one SystemMetric
     * const systemMetric = await prisma.systemMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricFindFirstArgs} args - Arguments to find a SystemMetric
     * @example
     * // Get one SystemMetric
     * const systemMetric = await prisma.systemMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemMetricFindFirstArgs>(args?: SelectSubset<T, SystemMetricFindFirstArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricFindFirstOrThrowArgs} args - Arguments to find a SystemMetric
     * @example
     * // Get one SystemMetric
     * const systemMetric = await prisma.systemMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemMetrics
     * const systemMetrics = await prisma.systemMetric.findMany()
     * 
     * // Get first 10 SystemMetrics
     * const systemMetrics = await prisma.systemMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemMetricWithIdOnly = await prisma.systemMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemMetricFindManyArgs>(args?: SelectSubset<T, SystemMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemMetric.
     * @param {SystemMetricCreateArgs} args - Arguments to create a SystemMetric.
     * @example
     * // Create one SystemMetric
     * const SystemMetric = await prisma.systemMetric.create({
     *   data: {
     *     // ... data to create a SystemMetric
     *   }
     * })
     * 
     */
    create<T extends SystemMetricCreateArgs>(args: SelectSubset<T, SystemMetricCreateArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemMetrics.
     * @param {SystemMetricCreateManyArgs} args - Arguments to create many SystemMetrics.
     * @example
     * // Create many SystemMetrics
     * const systemMetric = await prisma.systemMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemMetricCreateManyArgs>(args?: SelectSubset<T, SystemMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemMetrics and returns the data saved in the database.
     * @param {SystemMetricCreateManyAndReturnArgs} args - Arguments to create many SystemMetrics.
     * @example
     * // Create many SystemMetrics
     * const systemMetric = await prisma.systemMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemMetrics and only return the `id`
     * const systemMetricWithIdOnly = await prisma.systemMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemMetric.
     * @param {SystemMetricDeleteArgs} args - Arguments to delete one SystemMetric.
     * @example
     * // Delete one SystemMetric
     * const SystemMetric = await prisma.systemMetric.delete({
     *   where: {
     *     // ... filter to delete one SystemMetric
     *   }
     * })
     * 
     */
    delete<T extends SystemMetricDeleteArgs>(args: SelectSubset<T, SystemMetricDeleteArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemMetric.
     * @param {SystemMetricUpdateArgs} args - Arguments to update one SystemMetric.
     * @example
     * // Update one SystemMetric
     * const systemMetric = await prisma.systemMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemMetricUpdateArgs>(args: SelectSubset<T, SystemMetricUpdateArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemMetrics.
     * @param {SystemMetricDeleteManyArgs} args - Arguments to filter SystemMetrics to delete.
     * @example
     * // Delete a few SystemMetrics
     * const { count } = await prisma.systemMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemMetricDeleteManyArgs>(args?: SelectSubset<T, SystemMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemMetrics
     * const systemMetric = await prisma.systemMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemMetricUpdateManyArgs>(args: SelectSubset<T, SystemMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemMetrics and returns the data updated in the database.
     * @param {SystemMetricUpdateManyAndReturnArgs} args - Arguments to update many SystemMetrics.
     * @example
     * // Update many SystemMetrics
     * const systemMetric = await prisma.systemMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemMetrics and only return the `id`
     * const systemMetricWithIdOnly = await prisma.systemMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemMetric.
     * @param {SystemMetricUpsertArgs} args - Arguments to update or create a SystemMetric.
     * @example
     * // Update or create a SystemMetric
     * const systemMetric = await prisma.systemMetric.upsert({
     *   create: {
     *     // ... data to create a SystemMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemMetric we want to update
     *   }
     * })
     */
    upsert<T extends SystemMetricUpsertArgs>(args: SelectSubset<T, SystemMetricUpsertArgs<ExtArgs>>): Prisma__SystemMetricClient<$Result.GetResult<Prisma.$SystemMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricCountArgs} args - Arguments to filter SystemMetrics to count.
     * @example
     * // Count the number of SystemMetrics
     * const count = await prisma.systemMetric.count({
     *   where: {
     *     // ... the filter for the SystemMetrics we want to count
     *   }
     * })
    **/
    count<T extends SystemMetricCountArgs>(
      args?: Subset<T, SystemMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemMetricAggregateArgs>(args: Subset<T, SystemMetricAggregateArgs>): Prisma.PrismaPromise<GetSystemMetricAggregateType<T>>

    /**
     * Group by SystemMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemMetricGroupByArgs['orderBy'] }
        : { orderBy?: SystemMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemMetric model
   */
  readonly fields: SystemMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemMetric model
   */
  interface SystemMetricFieldRefs {
    readonly id: FieldRef<"SystemMetric", 'String'>
    readonly name: FieldRef<"SystemMetric", 'String'>
    readonly labels: FieldRef<"SystemMetric", 'Json'>
    readonly value: FieldRef<"SystemMetric", 'Float'>
    readonly capturedAt: FieldRef<"SystemMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemMetric findUnique
   */
  export type SystemMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetric to fetch.
     */
    where: SystemMetricWhereUniqueInput
  }

  /**
   * SystemMetric findUniqueOrThrow
   */
  export type SystemMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetric to fetch.
     */
    where: SystemMetricWhereUniqueInput
  }

  /**
   * SystemMetric findFirst
   */
  export type SystemMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetric to fetch.
     */
    where?: SystemMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricOrderByWithRelationInput | SystemMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMetrics.
     */
    cursor?: SystemMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMetrics.
     */
    distinct?: SystemMetricScalarFieldEnum | SystemMetricScalarFieldEnum[]
  }

  /**
   * SystemMetric findFirstOrThrow
   */
  export type SystemMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetric to fetch.
     */
    where?: SystemMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricOrderByWithRelationInput | SystemMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMetrics.
     */
    cursor?: SystemMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMetrics.
     */
    distinct?: SystemMetricScalarFieldEnum | SystemMetricScalarFieldEnum[]
  }

  /**
   * SystemMetric findMany
   */
  export type SystemMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where?: SystemMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricOrderByWithRelationInput | SystemMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemMetrics.
     */
    cursor?: SystemMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    distinct?: SystemMetricScalarFieldEnum | SystemMetricScalarFieldEnum[]
  }

  /**
   * SystemMetric create
   */
  export type SystemMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemMetric.
     */
    data: XOR<SystemMetricCreateInput, SystemMetricUncheckedCreateInput>
  }

  /**
   * SystemMetric createMany
   */
  export type SystemMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemMetrics.
     */
    data: SystemMetricCreateManyInput | SystemMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemMetric createManyAndReturn
   */
  export type SystemMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The data used to create many SystemMetrics.
     */
    data: SystemMetricCreateManyInput | SystemMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemMetric update
   */
  export type SystemMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemMetric.
     */
    data: XOR<SystemMetricUpdateInput, SystemMetricUncheckedUpdateInput>
    /**
     * Choose, which SystemMetric to update.
     */
    where: SystemMetricWhereUniqueInput
  }

  /**
   * SystemMetric updateMany
   */
  export type SystemMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemMetrics.
     */
    data: XOR<SystemMetricUpdateManyMutationInput, SystemMetricUncheckedUpdateManyInput>
    /**
     * Filter which SystemMetrics to update
     */
    where?: SystemMetricWhereInput
    /**
     * Limit how many SystemMetrics to update.
     */
    limit?: number
  }

  /**
   * SystemMetric updateManyAndReturn
   */
  export type SystemMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The data used to update SystemMetrics.
     */
    data: XOR<SystemMetricUpdateManyMutationInput, SystemMetricUncheckedUpdateManyInput>
    /**
     * Filter which SystemMetrics to update
     */
    where?: SystemMetricWhereInput
    /**
     * Limit how many SystemMetrics to update.
     */
    limit?: number
  }

  /**
   * SystemMetric upsert
   */
  export type SystemMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemMetric to update in case it exists.
     */
    where: SystemMetricWhereUniqueInput
    /**
     * In case the SystemMetric found by the `where` argument doesn't exist, create a new SystemMetric with this data.
     */
    create: XOR<SystemMetricCreateInput, SystemMetricUncheckedCreateInput>
    /**
     * In case the SystemMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemMetricUpdateInput, SystemMetricUncheckedUpdateInput>
  }

  /**
   * SystemMetric delete
   */
  export type SystemMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
    /**
     * Filter which SystemMetric to delete.
     */
    where: SystemMetricWhereUniqueInput
  }

  /**
   * SystemMetric deleteMany
   */
  export type SystemMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMetrics to delete
     */
    where?: SystemMetricWhereInput
    /**
     * Limit how many SystemMetrics to delete.
     */
    limit?: number
  }

  /**
   * SystemMetric without action
   */
  export type SystemMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetric
     */
    select?: SystemMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemMetric
     */
    omit?: SystemMetricOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: $Enums.AuditAction | null
    entityType: $Enums.AuditEntityType | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: $Enums.AuditAction | null
    entityType: $Enums.AuditEntityType | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    action: number
    entityType: number
    entityId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorId: string | null
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorId" | "action" | "entityType" | "entityId" | "metadata" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string | null
      action: $Enums.AuditAction
      entityType: $Enums.AuditEntityType
      entityId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly entityType: FieldRef<"AuditLog", 'AuditEntityType'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model BackupSnapshot
   */

  export type AggregateBackupSnapshot = {
    _count: BackupSnapshotCountAggregateOutputType | null
    _min: BackupSnapshotMinAggregateOutputType | null
    _max: BackupSnapshotMaxAggregateOutputType | null
  }

  export type BackupSnapshotMinAggregateOutputType = {
    id: string | null
    label: string | null
    snapshotType: string | null
    locationUrl: string | null
    createdAt: Date | null
  }

  export type BackupSnapshotMaxAggregateOutputType = {
    id: string | null
    label: string | null
    snapshotType: string | null
    locationUrl: string | null
    createdAt: Date | null
  }

  export type BackupSnapshotCountAggregateOutputType = {
    id: number
    label: number
    snapshotType: number
    locationUrl: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type BackupSnapshotMinAggregateInputType = {
    id?: true
    label?: true
    snapshotType?: true
    locationUrl?: true
    createdAt?: true
  }

  export type BackupSnapshotMaxAggregateInputType = {
    id?: true
    label?: true
    snapshotType?: true
    locationUrl?: true
    createdAt?: true
  }

  export type BackupSnapshotCountAggregateInputType = {
    id?: true
    label?: true
    snapshotType?: true
    locationUrl?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type BackupSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupSnapshot to aggregate.
     */
    where?: BackupSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupSnapshots to fetch.
     */
    orderBy?: BackupSnapshotOrderByWithRelationInput | BackupSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackupSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BackupSnapshots
    **/
    _count?: true | BackupSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackupSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackupSnapshotMaxAggregateInputType
  }

  export type GetBackupSnapshotAggregateType<T extends BackupSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateBackupSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackupSnapshot[P]>
      : GetScalarType<T[P], AggregateBackupSnapshot[P]>
  }




  export type BackupSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackupSnapshotWhereInput
    orderBy?: BackupSnapshotOrderByWithAggregationInput | BackupSnapshotOrderByWithAggregationInput[]
    by: BackupSnapshotScalarFieldEnum[] | BackupSnapshotScalarFieldEnum
    having?: BackupSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackupSnapshotCountAggregateInputType | true
    _min?: BackupSnapshotMinAggregateInputType
    _max?: BackupSnapshotMaxAggregateInputType
  }

  export type BackupSnapshotGroupByOutputType = {
    id: string
    label: string | null
    snapshotType: string
    locationUrl: string
    metadata: JsonValue | null
    createdAt: Date
    _count: BackupSnapshotCountAggregateOutputType | null
    _min: BackupSnapshotMinAggregateOutputType | null
    _max: BackupSnapshotMaxAggregateOutputType | null
  }

  type GetBackupSnapshotGroupByPayload<T extends BackupSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackupSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackupSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackupSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], BackupSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type BackupSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    snapshotType?: boolean
    locationUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["backupSnapshot"]>

  export type BackupSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    snapshotType?: boolean
    locationUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["backupSnapshot"]>

  export type BackupSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    snapshotType?: boolean
    locationUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["backupSnapshot"]>

  export type BackupSnapshotSelectScalar = {
    id?: boolean
    label?: boolean
    snapshotType?: boolean
    locationUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type BackupSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "snapshotType" | "locationUrl" | "metadata" | "createdAt", ExtArgs["result"]["backupSnapshot"]>

  export type $BackupSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BackupSnapshot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string | null
      snapshotType: string
      locationUrl: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["backupSnapshot"]>
    composites: {}
  }

  type BackupSnapshotGetPayload<S extends boolean | null | undefined | BackupSnapshotDefaultArgs> = $Result.GetResult<Prisma.$BackupSnapshotPayload, S>

  type BackupSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BackupSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BackupSnapshotCountAggregateInputType | true
    }

  export interface BackupSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BackupSnapshot'], meta: { name: 'BackupSnapshot' } }
    /**
     * Find zero or one BackupSnapshot that matches the filter.
     * @param {BackupSnapshotFindUniqueArgs} args - Arguments to find a BackupSnapshot
     * @example
     * // Get one BackupSnapshot
     * const backupSnapshot = await prisma.backupSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackupSnapshotFindUniqueArgs>(args: SelectSubset<T, BackupSnapshotFindUniqueArgs<ExtArgs>>): Prisma__BackupSnapshotClient<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BackupSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BackupSnapshotFindUniqueOrThrowArgs} args - Arguments to find a BackupSnapshot
     * @example
     * // Get one BackupSnapshot
     * const backupSnapshot = await prisma.backupSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackupSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, BackupSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackupSnapshotClient<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BackupSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupSnapshotFindFirstArgs} args - Arguments to find a BackupSnapshot
     * @example
     * // Get one BackupSnapshot
     * const backupSnapshot = await prisma.backupSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackupSnapshotFindFirstArgs>(args?: SelectSubset<T, BackupSnapshotFindFirstArgs<ExtArgs>>): Prisma__BackupSnapshotClient<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BackupSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupSnapshotFindFirstOrThrowArgs} args - Arguments to find a BackupSnapshot
     * @example
     * // Get one BackupSnapshot
     * const backupSnapshot = await prisma.backupSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackupSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, BackupSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackupSnapshotClient<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BackupSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BackupSnapshots
     * const backupSnapshots = await prisma.backupSnapshot.findMany()
     * 
     * // Get first 10 BackupSnapshots
     * const backupSnapshots = await prisma.backupSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backupSnapshotWithIdOnly = await prisma.backupSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackupSnapshotFindManyArgs>(args?: SelectSubset<T, BackupSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BackupSnapshot.
     * @param {BackupSnapshotCreateArgs} args - Arguments to create a BackupSnapshot.
     * @example
     * // Create one BackupSnapshot
     * const BackupSnapshot = await prisma.backupSnapshot.create({
     *   data: {
     *     // ... data to create a BackupSnapshot
     *   }
     * })
     * 
     */
    create<T extends BackupSnapshotCreateArgs>(args: SelectSubset<T, BackupSnapshotCreateArgs<ExtArgs>>): Prisma__BackupSnapshotClient<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BackupSnapshots.
     * @param {BackupSnapshotCreateManyArgs} args - Arguments to create many BackupSnapshots.
     * @example
     * // Create many BackupSnapshots
     * const backupSnapshot = await prisma.backupSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackupSnapshotCreateManyArgs>(args?: SelectSubset<T, BackupSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BackupSnapshots and returns the data saved in the database.
     * @param {BackupSnapshotCreateManyAndReturnArgs} args - Arguments to create many BackupSnapshots.
     * @example
     * // Create many BackupSnapshots
     * const backupSnapshot = await prisma.backupSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BackupSnapshots and only return the `id`
     * const backupSnapshotWithIdOnly = await prisma.backupSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BackupSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, BackupSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BackupSnapshot.
     * @param {BackupSnapshotDeleteArgs} args - Arguments to delete one BackupSnapshot.
     * @example
     * // Delete one BackupSnapshot
     * const BackupSnapshot = await prisma.backupSnapshot.delete({
     *   where: {
     *     // ... filter to delete one BackupSnapshot
     *   }
     * })
     * 
     */
    delete<T extends BackupSnapshotDeleteArgs>(args: SelectSubset<T, BackupSnapshotDeleteArgs<ExtArgs>>): Prisma__BackupSnapshotClient<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BackupSnapshot.
     * @param {BackupSnapshotUpdateArgs} args - Arguments to update one BackupSnapshot.
     * @example
     * // Update one BackupSnapshot
     * const backupSnapshot = await prisma.backupSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackupSnapshotUpdateArgs>(args: SelectSubset<T, BackupSnapshotUpdateArgs<ExtArgs>>): Prisma__BackupSnapshotClient<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BackupSnapshots.
     * @param {BackupSnapshotDeleteManyArgs} args - Arguments to filter BackupSnapshots to delete.
     * @example
     * // Delete a few BackupSnapshots
     * const { count } = await prisma.backupSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackupSnapshotDeleteManyArgs>(args?: SelectSubset<T, BackupSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackupSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BackupSnapshots
     * const backupSnapshot = await prisma.backupSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackupSnapshotUpdateManyArgs>(args: SelectSubset<T, BackupSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BackupSnapshots and returns the data updated in the database.
     * @param {BackupSnapshotUpdateManyAndReturnArgs} args - Arguments to update many BackupSnapshots.
     * @example
     * // Update many BackupSnapshots
     * const backupSnapshot = await prisma.backupSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BackupSnapshots and only return the `id`
     * const backupSnapshotWithIdOnly = await prisma.backupSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BackupSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, BackupSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BackupSnapshot.
     * @param {BackupSnapshotUpsertArgs} args - Arguments to update or create a BackupSnapshot.
     * @example
     * // Update or create a BackupSnapshot
     * const backupSnapshot = await prisma.backupSnapshot.upsert({
     *   create: {
     *     // ... data to create a BackupSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BackupSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends BackupSnapshotUpsertArgs>(args: SelectSubset<T, BackupSnapshotUpsertArgs<ExtArgs>>): Prisma__BackupSnapshotClient<$Result.GetResult<Prisma.$BackupSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BackupSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupSnapshotCountArgs} args - Arguments to filter BackupSnapshots to count.
     * @example
     * // Count the number of BackupSnapshots
     * const count = await prisma.backupSnapshot.count({
     *   where: {
     *     // ... the filter for the BackupSnapshots we want to count
     *   }
     * })
    **/
    count<T extends BackupSnapshotCountArgs>(
      args?: Subset<T, BackupSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackupSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BackupSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackupSnapshotAggregateArgs>(args: Subset<T, BackupSnapshotAggregateArgs>): Prisma.PrismaPromise<GetBackupSnapshotAggregateType<T>>

    /**
     * Group by BackupSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackupSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackupSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: BackupSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackupSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackupSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BackupSnapshot model
   */
  readonly fields: BackupSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BackupSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackupSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BackupSnapshot model
   */
  interface BackupSnapshotFieldRefs {
    readonly id: FieldRef<"BackupSnapshot", 'String'>
    readonly label: FieldRef<"BackupSnapshot", 'String'>
    readonly snapshotType: FieldRef<"BackupSnapshot", 'String'>
    readonly locationUrl: FieldRef<"BackupSnapshot", 'String'>
    readonly metadata: FieldRef<"BackupSnapshot", 'Json'>
    readonly createdAt: FieldRef<"BackupSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BackupSnapshot findUnique
   */
  export type BackupSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which BackupSnapshot to fetch.
     */
    where: BackupSnapshotWhereUniqueInput
  }

  /**
   * BackupSnapshot findUniqueOrThrow
   */
  export type BackupSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which BackupSnapshot to fetch.
     */
    where: BackupSnapshotWhereUniqueInput
  }

  /**
   * BackupSnapshot findFirst
   */
  export type BackupSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which BackupSnapshot to fetch.
     */
    where?: BackupSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupSnapshots to fetch.
     */
    orderBy?: BackupSnapshotOrderByWithRelationInput | BackupSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupSnapshots.
     */
    cursor?: BackupSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupSnapshots.
     */
    distinct?: BackupSnapshotScalarFieldEnum | BackupSnapshotScalarFieldEnum[]
  }

  /**
   * BackupSnapshot findFirstOrThrow
   */
  export type BackupSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which BackupSnapshot to fetch.
     */
    where?: BackupSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupSnapshots to fetch.
     */
    orderBy?: BackupSnapshotOrderByWithRelationInput | BackupSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BackupSnapshots.
     */
    cursor?: BackupSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BackupSnapshots.
     */
    distinct?: BackupSnapshotScalarFieldEnum | BackupSnapshotScalarFieldEnum[]
  }

  /**
   * BackupSnapshot findMany
   */
  export type BackupSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which BackupSnapshots to fetch.
     */
    where?: BackupSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BackupSnapshots to fetch.
     */
    orderBy?: BackupSnapshotOrderByWithRelationInput | BackupSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BackupSnapshots.
     */
    cursor?: BackupSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BackupSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BackupSnapshots.
     */
    skip?: number
    distinct?: BackupSnapshotScalarFieldEnum | BackupSnapshotScalarFieldEnum[]
  }

  /**
   * BackupSnapshot create
   */
  export type BackupSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to create a BackupSnapshot.
     */
    data: XOR<BackupSnapshotCreateInput, BackupSnapshotUncheckedCreateInput>
  }

  /**
   * BackupSnapshot createMany
   */
  export type BackupSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BackupSnapshots.
     */
    data: BackupSnapshotCreateManyInput | BackupSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackupSnapshot createManyAndReturn
   */
  export type BackupSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many BackupSnapshots.
     */
    data: BackupSnapshotCreateManyInput | BackupSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BackupSnapshot update
   */
  export type BackupSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to update a BackupSnapshot.
     */
    data: XOR<BackupSnapshotUpdateInput, BackupSnapshotUncheckedUpdateInput>
    /**
     * Choose, which BackupSnapshot to update.
     */
    where: BackupSnapshotWhereUniqueInput
  }

  /**
   * BackupSnapshot updateMany
   */
  export type BackupSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BackupSnapshots.
     */
    data: XOR<BackupSnapshotUpdateManyMutationInput, BackupSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which BackupSnapshots to update
     */
    where?: BackupSnapshotWhereInput
    /**
     * Limit how many BackupSnapshots to update.
     */
    limit?: number
  }

  /**
   * BackupSnapshot updateManyAndReturn
   */
  export type BackupSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update BackupSnapshots.
     */
    data: XOR<BackupSnapshotUpdateManyMutationInput, BackupSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which BackupSnapshots to update
     */
    where?: BackupSnapshotWhereInput
    /**
     * Limit how many BackupSnapshots to update.
     */
    limit?: number
  }

  /**
   * BackupSnapshot upsert
   */
  export type BackupSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * The filter to search for the BackupSnapshot to update in case it exists.
     */
    where: BackupSnapshotWhereUniqueInput
    /**
     * In case the BackupSnapshot found by the `where` argument doesn't exist, create a new BackupSnapshot with this data.
     */
    create: XOR<BackupSnapshotCreateInput, BackupSnapshotUncheckedCreateInput>
    /**
     * In case the BackupSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackupSnapshotUpdateInput, BackupSnapshotUncheckedUpdateInput>
  }

  /**
   * BackupSnapshot delete
   */
  export type BackupSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
    /**
     * Filter which BackupSnapshot to delete.
     */
    where: BackupSnapshotWhereUniqueInput
  }

  /**
   * BackupSnapshot deleteMany
   */
  export type BackupSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BackupSnapshots to delete
     */
    where?: BackupSnapshotWhereInput
    /**
     * Limit how many BackupSnapshots to delete.
     */
    limit?: number
  }

  /**
   * BackupSnapshot without action
   */
  export type BackupSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BackupSnapshot
     */
    select?: BackupSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BackupSnapshot
     */
    omit?: BackupSnapshotOmit<ExtArgs> | null
  }


  /**
   * Model ConfigVersionHistory
   */

  export type AggregateConfigVersionHistory = {
    _count: ConfigVersionHistoryCountAggregateOutputType | null
    _avg: ConfigVersionHistoryAvgAggregateOutputType | null
    _sum: ConfigVersionHistorySumAggregateOutputType | null
    _min: ConfigVersionHistoryMinAggregateOutputType | null
    _max: ConfigVersionHistoryMaxAggregateOutputType | null
  }

  export type ConfigVersionHistoryAvgAggregateOutputType = {
    fromVersion: number | null
    toVersion: number | null
  }

  export type ConfigVersionHistorySumAggregateOutputType = {
    fromVersion: number | null
    toVersion: number | null
  }

  export type ConfigVersionHistoryMinAggregateOutputType = {
    id: string | null
    configId: string | null
    fromVersion: number | null
    toVersion: number | null
    reason: string | null
    changedById: string | null
    changedAt: Date | null
  }

  export type ConfigVersionHistoryMaxAggregateOutputType = {
    id: string | null
    configId: string | null
    fromVersion: number | null
    toVersion: number | null
    reason: string | null
    changedById: string | null
    changedAt: Date | null
  }

  export type ConfigVersionHistoryCountAggregateOutputType = {
    id: number
    configId: number
    fromVersion: number
    toVersion: number
    reason: number
    changedById: number
    changedAt: number
    _all: number
  }


  export type ConfigVersionHistoryAvgAggregateInputType = {
    fromVersion?: true
    toVersion?: true
  }

  export type ConfigVersionHistorySumAggregateInputType = {
    fromVersion?: true
    toVersion?: true
  }

  export type ConfigVersionHistoryMinAggregateInputType = {
    id?: true
    configId?: true
    fromVersion?: true
    toVersion?: true
    reason?: true
    changedById?: true
    changedAt?: true
  }

  export type ConfigVersionHistoryMaxAggregateInputType = {
    id?: true
    configId?: true
    fromVersion?: true
    toVersion?: true
    reason?: true
    changedById?: true
    changedAt?: true
  }

  export type ConfigVersionHistoryCountAggregateInputType = {
    id?: true
    configId?: true
    fromVersion?: true
    toVersion?: true
    reason?: true
    changedById?: true
    changedAt?: true
    _all?: true
  }

  export type ConfigVersionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigVersionHistory to aggregate.
     */
    where?: ConfigVersionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigVersionHistories to fetch.
     */
    orderBy?: ConfigVersionHistoryOrderByWithRelationInput | ConfigVersionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigVersionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigVersionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigVersionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigVersionHistories
    **/
    _count?: true | ConfigVersionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigVersionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigVersionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigVersionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigVersionHistoryMaxAggregateInputType
  }

  export type GetConfigVersionHistoryAggregateType<T extends ConfigVersionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigVersionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigVersionHistory[P]>
      : GetScalarType<T[P], AggregateConfigVersionHistory[P]>
  }




  export type ConfigVersionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigVersionHistoryWhereInput
    orderBy?: ConfigVersionHistoryOrderByWithAggregationInput | ConfigVersionHistoryOrderByWithAggregationInput[]
    by: ConfigVersionHistoryScalarFieldEnum[] | ConfigVersionHistoryScalarFieldEnum
    having?: ConfigVersionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigVersionHistoryCountAggregateInputType | true
    _avg?: ConfigVersionHistoryAvgAggregateInputType
    _sum?: ConfigVersionHistorySumAggregateInputType
    _min?: ConfigVersionHistoryMinAggregateInputType
    _max?: ConfigVersionHistoryMaxAggregateInputType
  }

  export type ConfigVersionHistoryGroupByOutputType = {
    id: string
    configId: string
    fromVersion: number
    toVersion: number
    reason: string | null
    changedById: string | null
    changedAt: Date
    _count: ConfigVersionHistoryCountAggregateOutputType | null
    _avg: ConfigVersionHistoryAvgAggregateOutputType | null
    _sum: ConfigVersionHistorySumAggregateOutputType | null
    _min: ConfigVersionHistoryMinAggregateOutputType | null
    _max: ConfigVersionHistoryMaxAggregateOutputType | null
  }

  type GetConfigVersionHistoryGroupByPayload<T extends ConfigVersionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigVersionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigVersionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigVersionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigVersionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ConfigVersionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configId?: boolean
    fromVersion?: boolean
    toVersion?: boolean
    reason?: boolean
    changedById?: boolean
    changedAt?: boolean
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configVersionHistory"]>

  export type ConfigVersionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configId?: boolean
    fromVersion?: boolean
    toVersion?: boolean
    reason?: boolean
    changedById?: boolean
    changedAt?: boolean
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configVersionHistory"]>

  export type ConfigVersionHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configId?: boolean
    fromVersion?: boolean
    toVersion?: boolean
    reason?: boolean
    changedById?: boolean
    changedAt?: boolean
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configVersionHistory"]>

  export type ConfigVersionHistorySelectScalar = {
    id?: boolean
    configId?: boolean
    fromVersion?: boolean
    toVersion?: boolean
    reason?: boolean
    changedById?: boolean
    changedAt?: boolean
  }

  export type ConfigVersionHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "configId" | "fromVersion" | "toVersion" | "reason" | "changedById" | "changedAt", ExtArgs["result"]["configVersionHistory"]>
  export type ConfigVersionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }
  export type ConfigVersionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }
  export type ConfigVersionHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | EthicalConfigDefaultArgs<ExtArgs>
  }

  export type $ConfigVersionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigVersionHistory"
    objects: {
      config: Prisma.$EthicalConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      configId: string
      fromVersion: number
      toVersion: number
      reason: string | null
      changedById: string | null
      changedAt: Date
    }, ExtArgs["result"]["configVersionHistory"]>
    composites: {}
  }

  type ConfigVersionHistoryGetPayload<S extends boolean | null | undefined | ConfigVersionHistoryDefaultArgs> = $Result.GetResult<Prisma.$ConfigVersionHistoryPayload, S>

  type ConfigVersionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigVersionHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigVersionHistoryCountAggregateInputType | true
    }

  export interface ConfigVersionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigVersionHistory'], meta: { name: 'ConfigVersionHistory' } }
    /**
     * Find zero or one ConfigVersionHistory that matches the filter.
     * @param {ConfigVersionHistoryFindUniqueArgs} args - Arguments to find a ConfigVersionHistory
     * @example
     * // Get one ConfigVersionHistory
     * const configVersionHistory = await prisma.configVersionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigVersionHistoryFindUniqueArgs>(args: SelectSubset<T, ConfigVersionHistoryFindUniqueArgs<ExtArgs>>): Prisma__ConfigVersionHistoryClient<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConfigVersionHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigVersionHistoryFindUniqueOrThrowArgs} args - Arguments to find a ConfigVersionHistory
     * @example
     * // Get one ConfigVersionHistory
     * const configVersionHistory = await prisma.configVersionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigVersionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigVersionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigVersionHistoryClient<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigVersionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigVersionHistoryFindFirstArgs} args - Arguments to find a ConfigVersionHistory
     * @example
     * // Get one ConfigVersionHistory
     * const configVersionHistory = await prisma.configVersionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigVersionHistoryFindFirstArgs>(args?: SelectSubset<T, ConfigVersionHistoryFindFirstArgs<ExtArgs>>): Prisma__ConfigVersionHistoryClient<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigVersionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigVersionHistoryFindFirstOrThrowArgs} args - Arguments to find a ConfigVersionHistory
     * @example
     * // Get one ConfigVersionHistory
     * const configVersionHistory = await prisma.configVersionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigVersionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigVersionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigVersionHistoryClient<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConfigVersionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigVersionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigVersionHistories
     * const configVersionHistories = await prisma.configVersionHistory.findMany()
     * 
     * // Get first 10 ConfigVersionHistories
     * const configVersionHistories = await prisma.configVersionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configVersionHistoryWithIdOnly = await prisma.configVersionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigVersionHistoryFindManyArgs>(args?: SelectSubset<T, ConfigVersionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConfigVersionHistory.
     * @param {ConfigVersionHistoryCreateArgs} args - Arguments to create a ConfigVersionHistory.
     * @example
     * // Create one ConfigVersionHistory
     * const ConfigVersionHistory = await prisma.configVersionHistory.create({
     *   data: {
     *     // ... data to create a ConfigVersionHistory
     *   }
     * })
     * 
     */
    create<T extends ConfigVersionHistoryCreateArgs>(args: SelectSubset<T, ConfigVersionHistoryCreateArgs<ExtArgs>>): Prisma__ConfigVersionHistoryClient<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConfigVersionHistories.
     * @param {ConfigVersionHistoryCreateManyArgs} args - Arguments to create many ConfigVersionHistories.
     * @example
     * // Create many ConfigVersionHistories
     * const configVersionHistory = await prisma.configVersionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigVersionHistoryCreateManyArgs>(args?: SelectSubset<T, ConfigVersionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigVersionHistories and returns the data saved in the database.
     * @param {ConfigVersionHistoryCreateManyAndReturnArgs} args - Arguments to create many ConfigVersionHistories.
     * @example
     * // Create many ConfigVersionHistories
     * const configVersionHistory = await prisma.configVersionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigVersionHistories and only return the `id`
     * const configVersionHistoryWithIdOnly = await prisma.configVersionHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigVersionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigVersionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConfigVersionHistory.
     * @param {ConfigVersionHistoryDeleteArgs} args - Arguments to delete one ConfigVersionHistory.
     * @example
     * // Delete one ConfigVersionHistory
     * const ConfigVersionHistory = await prisma.configVersionHistory.delete({
     *   where: {
     *     // ... filter to delete one ConfigVersionHistory
     *   }
     * })
     * 
     */
    delete<T extends ConfigVersionHistoryDeleteArgs>(args: SelectSubset<T, ConfigVersionHistoryDeleteArgs<ExtArgs>>): Prisma__ConfigVersionHistoryClient<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConfigVersionHistory.
     * @param {ConfigVersionHistoryUpdateArgs} args - Arguments to update one ConfigVersionHistory.
     * @example
     * // Update one ConfigVersionHistory
     * const configVersionHistory = await prisma.configVersionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigVersionHistoryUpdateArgs>(args: SelectSubset<T, ConfigVersionHistoryUpdateArgs<ExtArgs>>): Prisma__ConfigVersionHistoryClient<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConfigVersionHistories.
     * @param {ConfigVersionHistoryDeleteManyArgs} args - Arguments to filter ConfigVersionHistories to delete.
     * @example
     * // Delete a few ConfigVersionHistories
     * const { count } = await prisma.configVersionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigVersionHistoryDeleteManyArgs>(args?: SelectSubset<T, ConfigVersionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigVersionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigVersionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigVersionHistories
     * const configVersionHistory = await prisma.configVersionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigVersionHistoryUpdateManyArgs>(args: SelectSubset<T, ConfigVersionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigVersionHistories and returns the data updated in the database.
     * @param {ConfigVersionHistoryUpdateManyAndReturnArgs} args - Arguments to update many ConfigVersionHistories.
     * @example
     * // Update many ConfigVersionHistories
     * const configVersionHistory = await prisma.configVersionHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConfigVersionHistories and only return the `id`
     * const configVersionHistoryWithIdOnly = await prisma.configVersionHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConfigVersionHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ConfigVersionHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConfigVersionHistory.
     * @param {ConfigVersionHistoryUpsertArgs} args - Arguments to update or create a ConfigVersionHistory.
     * @example
     * // Update or create a ConfigVersionHistory
     * const configVersionHistory = await prisma.configVersionHistory.upsert({
     *   create: {
     *     // ... data to create a ConfigVersionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigVersionHistory we want to update
     *   }
     * })
     */
    upsert<T extends ConfigVersionHistoryUpsertArgs>(args: SelectSubset<T, ConfigVersionHistoryUpsertArgs<ExtArgs>>): Prisma__ConfigVersionHistoryClient<$Result.GetResult<Prisma.$ConfigVersionHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConfigVersionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigVersionHistoryCountArgs} args - Arguments to filter ConfigVersionHistories to count.
     * @example
     * // Count the number of ConfigVersionHistories
     * const count = await prisma.configVersionHistory.count({
     *   where: {
     *     // ... the filter for the ConfigVersionHistories we want to count
     *   }
     * })
    **/
    count<T extends ConfigVersionHistoryCountArgs>(
      args?: Subset<T, ConfigVersionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigVersionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigVersionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigVersionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigVersionHistoryAggregateArgs>(args: Subset<T, ConfigVersionHistoryAggregateArgs>): Prisma.PrismaPromise<GetConfigVersionHistoryAggregateType<T>>

    /**
     * Group by ConfigVersionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigVersionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigVersionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigVersionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ConfigVersionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigVersionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigVersionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigVersionHistory model
   */
  readonly fields: ConfigVersionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigVersionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigVersionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    config<T extends EthicalConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EthicalConfigDefaultArgs<ExtArgs>>): Prisma__EthicalConfigClient<$Result.GetResult<Prisma.$EthicalConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigVersionHistory model
   */
  interface ConfigVersionHistoryFieldRefs {
    readonly id: FieldRef<"ConfigVersionHistory", 'String'>
    readonly configId: FieldRef<"ConfigVersionHistory", 'String'>
    readonly fromVersion: FieldRef<"ConfigVersionHistory", 'Int'>
    readonly toVersion: FieldRef<"ConfigVersionHistory", 'Int'>
    readonly reason: FieldRef<"ConfigVersionHistory", 'String'>
    readonly changedById: FieldRef<"ConfigVersionHistory", 'String'>
    readonly changedAt: FieldRef<"ConfigVersionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfigVersionHistory findUnique
   */
  export type ConfigVersionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigVersionHistory to fetch.
     */
    where: ConfigVersionHistoryWhereUniqueInput
  }

  /**
   * ConfigVersionHistory findUniqueOrThrow
   */
  export type ConfigVersionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigVersionHistory to fetch.
     */
    where: ConfigVersionHistoryWhereUniqueInput
  }

  /**
   * ConfigVersionHistory findFirst
   */
  export type ConfigVersionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigVersionHistory to fetch.
     */
    where?: ConfigVersionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigVersionHistories to fetch.
     */
    orderBy?: ConfigVersionHistoryOrderByWithRelationInput | ConfigVersionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigVersionHistories.
     */
    cursor?: ConfigVersionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigVersionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigVersionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigVersionHistories.
     */
    distinct?: ConfigVersionHistoryScalarFieldEnum | ConfigVersionHistoryScalarFieldEnum[]
  }

  /**
   * ConfigVersionHistory findFirstOrThrow
   */
  export type ConfigVersionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigVersionHistory to fetch.
     */
    where?: ConfigVersionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigVersionHistories to fetch.
     */
    orderBy?: ConfigVersionHistoryOrderByWithRelationInput | ConfigVersionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigVersionHistories.
     */
    cursor?: ConfigVersionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigVersionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigVersionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigVersionHistories.
     */
    distinct?: ConfigVersionHistoryScalarFieldEnum | ConfigVersionHistoryScalarFieldEnum[]
  }

  /**
   * ConfigVersionHistory findMany
   */
  export type ConfigVersionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ConfigVersionHistories to fetch.
     */
    where?: ConfigVersionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigVersionHistories to fetch.
     */
    orderBy?: ConfigVersionHistoryOrderByWithRelationInput | ConfigVersionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigVersionHistories.
     */
    cursor?: ConfigVersionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigVersionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigVersionHistories.
     */
    skip?: number
    distinct?: ConfigVersionHistoryScalarFieldEnum | ConfigVersionHistoryScalarFieldEnum[]
  }

  /**
   * ConfigVersionHistory create
   */
  export type ConfigVersionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfigVersionHistory.
     */
    data: XOR<ConfigVersionHistoryCreateInput, ConfigVersionHistoryUncheckedCreateInput>
  }

  /**
   * ConfigVersionHistory createMany
   */
  export type ConfigVersionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigVersionHistories.
     */
    data: ConfigVersionHistoryCreateManyInput | ConfigVersionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigVersionHistory createManyAndReturn
   */
  export type ConfigVersionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ConfigVersionHistories.
     */
    data: ConfigVersionHistoryCreateManyInput | ConfigVersionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigVersionHistory update
   */
  export type ConfigVersionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfigVersionHistory.
     */
    data: XOR<ConfigVersionHistoryUpdateInput, ConfigVersionHistoryUncheckedUpdateInput>
    /**
     * Choose, which ConfigVersionHistory to update.
     */
    where: ConfigVersionHistoryWhereUniqueInput
  }

  /**
   * ConfigVersionHistory updateMany
   */
  export type ConfigVersionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigVersionHistories.
     */
    data: XOR<ConfigVersionHistoryUpdateManyMutationInput, ConfigVersionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ConfigVersionHistories to update
     */
    where?: ConfigVersionHistoryWhereInput
    /**
     * Limit how many ConfigVersionHistories to update.
     */
    limit?: number
  }

  /**
   * ConfigVersionHistory updateManyAndReturn
   */
  export type ConfigVersionHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ConfigVersionHistories.
     */
    data: XOR<ConfigVersionHistoryUpdateManyMutationInput, ConfigVersionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ConfigVersionHistories to update
     */
    where?: ConfigVersionHistoryWhereInput
    /**
     * Limit how many ConfigVersionHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigVersionHistory upsert
   */
  export type ConfigVersionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfigVersionHistory to update in case it exists.
     */
    where: ConfigVersionHistoryWhereUniqueInput
    /**
     * In case the ConfigVersionHistory found by the `where` argument doesn't exist, create a new ConfigVersionHistory with this data.
     */
    create: XOR<ConfigVersionHistoryCreateInput, ConfigVersionHistoryUncheckedCreateInput>
    /**
     * In case the ConfigVersionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigVersionHistoryUpdateInput, ConfigVersionHistoryUncheckedUpdateInput>
  }

  /**
   * ConfigVersionHistory delete
   */
  export type ConfigVersionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
    /**
     * Filter which ConfigVersionHistory to delete.
     */
    where: ConfigVersionHistoryWhereUniqueInput
  }

  /**
   * ConfigVersionHistory deleteMany
   */
  export type ConfigVersionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigVersionHistories to delete
     */
    where?: ConfigVersionHistoryWhereInput
    /**
     * Limit how many ConfigVersionHistories to delete.
     */
    limit?: number
  }

  /**
   * ConfigVersionHistory without action
   */
  export type ConfigVersionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigVersionHistory
     */
    select?: ConfigVersionHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigVersionHistory
     */
    omit?: ConfigVersionHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigVersionHistoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authProvider: 'authProvider',
    externalId: 'externalId',
    passwordHash: 'passwordHash',
    displayName: 'displayName',
    locale: 'locale',
    timezone: 'timezone',
    preferences: 'preferences'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminUserScalarFieldEnum = (typeof AdminUserScalarFieldEnum)[keyof typeof AdminUserScalarFieldEnum]


  export const EthicalConfigScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    latestVersion: 'latestVersion',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EthicalConfigScalarFieldEnum = (typeof EthicalConfigScalarFieldEnum)[keyof typeof EthicalConfigScalarFieldEnum]


  export const EthicalConfigVersionScalarFieldEnum: {
    id: 'id',
    configId: 'configId',
    version: 'version',
    data: 'data',
    createdAt: 'createdAt',
    createdById: 'createdById'
  };

  export type EthicalConfigVersionScalarFieldEnum = (typeof EthicalConfigVersionScalarFieldEnum)[keyof typeof EthicalConfigVersionScalarFieldEnum]


  export const RoleTemplateScalarFieldEnum: {
    id: 'id',
    type: 'type',
    key: 'key',
    displayName: 'displayName',
    description: 'description',
    defaultSettings: 'defaultSettings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleTemplateScalarFieldEnum = (typeof RoleTemplateScalarFieldEnum)[keyof typeof RoleTemplateScalarFieldEnum]


  export const CulturalParameterScalarFieldEnum: {
    id: 'id',
    regionCode: 'regionCode',
    cultureKey: 'cultureKey',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CulturalParameterScalarFieldEnum = (typeof CulturalParameterScalarFieldEnum)[keyof typeof CulturalParameterScalarFieldEnum]


  export const RelationshipScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    counterpartUserId: 'counterpartUserId',
    roleTemplateId: 'roleTemplateId',
    title: 'title',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive'
  };

  export type RelationshipScalarFieldEnum = (typeof RelationshipScalarFieldEnum)[keyof typeof RelationshipScalarFieldEnum]


  export const ConversationMessageScalarFieldEnum: {
    id: 'id',
    relationshipId: 'relationshipId',
    senderId: 'senderId',
    content: 'content',
    emotionalTone: 'emotionalTone',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ConversationMessageScalarFieldEnum = (typeof ConversationMessageScalarFieldEnum)[keyof typeof ConversationMessageScalarFieldEnum]


  export const GrowthMetricScalarFieldEnum: {
    id: 'id',
    relationshipId: 'relationshipId',
    bucketDate: 'bucketDate',
    messagesCount: 'messagesCount',
    positiveCount: 'positiveCount',
    neutralCount: 'neutralCount',
    negativeCount: 'negativeCount',
    metrics: 'metrics'
  };

  export type GrowthMetricScalarFieldEnum = (typeof GrowthMetricScalarFieldEnum)[keyof typeof GrowthMetricScalarFieldEnum]


  export const VoiceProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    settings: 'settings',
    sampleUrl: 'sampleUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoiceProfileScalarFieldEnum = (typeof VoiceProfileScalarFieldEnum)[keyof typeof VoiceProfileScalarFieldEnum]


  export const VoiceSampleScalarFieldEnum: {
    id: 'id',
    voiceProfileId: 'voiceProfileId',
    url: 'url',
    durationMs: 'durationMs',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type VoiceSampleScalarFieldEnum = (typeof VoiceSampleScalarFieldEnum)[keyof typeof VoiceSampleScalarFieldEnum]


  export const AvatarProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    settings: 'settings',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AvatarProfileScalarFieldEnum = (typeof AvatarProfileScalarFieldEnum)[keyof typeof AvatarProfileScalarFieldEnum]


  export const AvatarAssetScalarFieldEnum: {
    id: 'id',
    avatarProfileId: 'avatarProfileId',
    url: 'url',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AvatarAssetScalarFieldEnum = (typeof AvatarAssetScalarFieldEnum)[keyof typeof AvatarAssetScalarFieldEnum]


  export const UploadScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mediaType: 'mediaType',
    url: 'url',
    originalName: 'originalName',
    sizeBytes: 'sizeBytes',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type UploadScalarFieldEnum = (typeof UploadScalarFieldEnum)[keyof typeof UploadScalarFieldEnum]


  export const UsageEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type UsageEventScalarFieldEnum = (typeof UsageEventScalarFieldEnum)[keyof typeof UsageEventScalarFieldEnum]


  export const SystemMetricScalarFieldEnum: {
    id: 'id',
    name: 'name',
    labels: 'labels',
    value: 'value',
    capturedAt: 'capturedAt'
  };

  export type SystemMetricScalarFieldEnum = (typeof SystemMetricScalarFieldEnum)[keyof typeof SystemMetricScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const BackupSnapshotScalarFieldEnum: {
    id: 'id',
    label: 'label',
    snapshotType: 'snapshotType',
    locationUrl: 'locationUrl',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type BackupSnapshotScalarFieldEnum = (typeof BackupSnapshotScalarFieldEnum)[keyof typeof BackupSnapshotScalarFieldEnum]


  export const ConfigVersionHistoryScalarFieldEnum: {
    id: 'id',
    configId: 'configId',
    fromVersion: 'fromVersion',
    toVersion: 'toVersion',
    reason: 'reason',
    changedById: 'changedById',
    changedAt: 'changedAt'
  };

  export type ConfigVersionHistoryScalarFieldEnum = (typeof ConfigVersionHistoryScalarFieldEnum)[keyof typeof ConfigVersionHistoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>
    


  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AdminRole'
   */
  export type EnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole'>
    


  /**
   * Reference to a field of type 'AdminRole[]'
   */
  export type ListEnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'RelationshipRoleTemplateType'
   */
  export type EnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipRoleTemplateType'>
    


  /**
   * Reference to a field of type 'RelationshipRoleTemplateType[]'
   */
  export type ListEnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipRoleTemplateType[]'>
    


  /**
   * Reference to a field of type 'EmotionalTone'
   */
  export type EnumEmotionalToneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmotionalTone'>
    


  /**
   * Reference to a field of type 'EmotionalTone[]'
   */
  export type ListEnumEmotionalToneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmotionalTone[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'UsageEventType'
   */
  export type EnumUsageEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UsageEventType'>
    


  /**
   * Reference to a field of type 'UsageEventType[]'
   */
  export type ListEnumUsageEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UsageEventType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'AuditEntityType'
   */
  export type EnumAuditEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntityType'>
    


  /**
   * Reference to a field of type 'AuditEntityType[]'
   */
  export type ListEnumAuditEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntityType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    externalId?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    locale?: StringNullableFilter<"User"> | string | null
    timezone?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    adminProfile?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    relationships?: RelationshipListRelationFilter
    counterpartRels?: RelationshipListRelationFilter
    voiceProfile?: XOR<VoiceProfileNullableScalarRelationFilter, VoiceProfileWhereInput> | null
    avatarProfile?: XOR<AvatarProfileNullableScalarRelationFilter, AvatarProfileWhereInput> | null
    uploads?: UploadListRelationFilter
    usageEvents?: UsageEventListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    sentMessages?: ConversationMessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
    externalId?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    adminProfile?: AdminUserOrderByWithRelationInput
    relationships?: RelationshipOrderByRelationAggregateInput
    counterpartRels?: RelationshipOrderByRelationAggregateInput
    voiceProfile?: VoiceProfileOrderByWithRelationInput
    avatarProfile?: AvatarProfileOrderByWithRelationInput
    uploads?: UploadOrderByRelationAggregateInput
    usageEvents?: UsageEventOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    sentMessages?: ConversationMessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    externalId?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    locale?: StringNullableFilter<"User"> | string | null
    timezone?: StringNullableFilter<"User"> | string | null
    preferences?: JsonNullableFilter<"User">
    adminProfile?: XOR<AdminUserNullableScalarRelationFilter, AdminUserWhereInput> | null
    relationships?: RelationshipListRelationFilter
    counterpartRels?: RelationshipListRelationFilter
    voiceProfile?: XOR<VoiceProfileNullableScalarRelationFilter, VoiceProfileWhereInput> | null
    avatarProfile?: XOR<AvatarProfileNullableScalarRelationFilter, AvatarProfileWhereInput> | null
    uploads?: UploadListRelationFilter
    usageEvents?: UsageEventListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    sentMessages?: ConversationMessageListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
    externalId?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    authProvider?: EnumAuthProviderWithAggregatesFilter<"User"> | $Enums.AuthProvider
    externalId?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    locale?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferences?: JsonNullableWithAggregatesFilter<"User">
  }

  export type AdminUserWhereInput = {
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    id?: StringFilter<"AdminUser"> | string
    userId?: StringFilter<"AdminUser"> | string
    role?: EnumAdminRoleFilter<"AdminUser"> | $Enums.AdminRole
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    role?: EnumAdminRoleFilter<"AdminUser"> | $Enums.AdminRole
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminUserCountOrderByAggregateInput
    _max?: AdminUserMaxOrderByAggregateInput
    _min?: AdminUserMinOrderByAggregateInput
  }

  export type AdminUserScalarWhereWithAggregatesInput = {
    AND?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    OR?: AdminUserScalarWhereWithAggregatesInput[]
    NOT?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminUser"> | string
    userId?: StringWithAggregatesFilter<"AdminUser"> | string
    role?: EnumAdminRoleWithAggregatesFilter<"AdminUser"> | $Enums.AdminRole
    createdAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
  }

  export type EthicalConfigWhereInput = {
    AND?: EthicalConfigWhereInput | EthicalConfigWhereInput[]
    OR?: EthicalConfigWhereInput[]
    NOT?: EthicalConfigWhereInput | EthicalConfigWhereInput[]
    id?: StringFilter<"EthicalConfig"> | string
    name?: StringFilter<"EthicalConfig"> | string
    description?: StringNullableFilter<"EthicalConfig"> | string | null
    latestVersion?: IntFilter<"EthicalConfig"> | number
    isActive?: BoolFilter<"EthicalConfig"> | boolean
    createdAt?: DateTimeFilter<"EthicalConfig"> | Date | string
    updatedAt?: DateTimeFilter<"EthicalConfig"> | Date | string
    versions?: EthicalConfigVersionListRelationFilter
    history?: ConfigVersionHistoryListRelationFilter
  }

  export type EthicalConfigOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    latestVersion?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    versions?: EthicalConfigVersionOrderByRelationAggregateInput
    history?: ConfigVersionHistoryOrderByRelationAggregateInput
  }

  export type EthicalConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: EthicalConfigWhereInput | EthicalConfigWhereInput[]
    OR?: EthicalConfigWhereInput[]
    NOT?: EthicalConfigWhereInput | EthicalConfigWhereInput[]
    description?: StringNullableFilter<"EthicalConfig"> | string | null
    latestVersion?: IntFilter<"EthicalConfig"> | number
    isActive?: BoolFilter<"EthicalConfig"> | boolean
    createdAt?: DateTimeFilter<"EthicalConfig"> | Date | string
    updatedAt?: DateTimeFilter<"EthicalConfig"> | Date | string
    versions?: EthicalConfigVersionListRelationFilter
    history?: ConfigVersionHistoryListRelationFilter
  }, "id" | "name">

  export type EthicalConfigOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    latestVersion?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EthicalConfigCountOrderByAggregateInput
    _avg?: EthicalConfigAvgOrderByAggregateInput
    _max?: EthicalConfigMaxOrderByAggregateInput
    _min?: EthicalConfigMinOrderByAggregateInput
    _sum?: EthicalConfigSumOrderByAggregateInput
  }

  export type EthicalConfigScalarWhereWithAggregatesInput = {
    AND?: EthicalConfigScalarWhereWithAggregatesInput | EthicalConfigScalarWhereWithAggregatesInput[]
    OR?: EthicalConfigScalarWhereWithAggregatesInput[]
    NOT?: EthicalConfigScalarWhereWithAggregatesInput | EthicalConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EthicalConfig"> | string
    name?: StringWithAggregatesFilter<"EthicalConfig"> | string
    description?: StringNullableWithAggregatesFilter<"EthicalConfig"> | string | null
    latestVersion?: IntWithAggregatesFilter<"EthicalConfig"> | number
    isActive?: BoolWithAggregatesFilter<"EthicalConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EthicalConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EthicalConfig"> | Date | string
  }

  export type EthicalConfigVersionWhereInput = {
    AND?: EthicalConfigVersionWhereInput | EthicalConfigVersionWhereInput[]
    OR?: EthicalConfigVersionWhereInput[]
    NOT?: EthicalConfigVersionWhereInput | EthicalConfigVersionWhereInput[]
    id?: StringFilter<"EthicalConfigVersion"> | string
    configId?: StringFilter<"EthicalConfigVersion"> | string
    version?: IntFilter<"EthicalConfigVersion"> | number
    data?: JsonFilter<"EthicalConfigVersion">
    createdAt?: DateTimeFilter<"EthicalConfigVersion"> | Date | string
    createdById?: StringNullableFilter<"EthicalConfigVersion"> | string | null
    config?: XOR<EthicalConfigScalarRelationFilter, EthicalConfigWhereInput>
  }

  export type EthicalConfigVersionOrderByWithRelationInput = {
    id?: SortOrder
    configId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    config?: EthicalConfigOrderByWithRelationInput
  }

  export type EthicalConfigVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    configId_version?: EthicalConfigVersionConfigIdVersionCompoundUniqueInput
    AND?: EthicalConfigVersionWhereInput | EthicalConfigVersionWhereInput[]
    OR?: EthicalConfigVersionWhereInput[]
    NOT?: EthicalConfigVersionWhereInput | EthicalConfigVersionWhereInput[]
    configId?: StringFilter<"EthicalConfigVersion"> | string
    version?: IntFilter<"EthicalConfigVersion"> | number
    data?: JsonFilter<"EthicalConfigVersion">
    createdAt?: DateTimeFilter<"EthicalConfigVersion"> | Date | string
    createdById?: StringNullableFilter<"EthicalConfigVersion"> | string | null
    config?: XOR<EthicalConfigScalarRelationFilter, EthicalConfigWhereInput>
  }, "id" | "configId_version">

  export type EthicalConfigVersionOrderByWithAggregationInput = {
    id?: SortOrder
    configId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: EthicalConfigVersionCountOrderByAggregateInput
    _avg?: EthicalConfigVersionAvgOrderByAggregateInput
    _max?: EthicalConfigVersionMaxOrderByAggregateInput
    _min?: EthicalConfigVersionMinOrderByAggregateInput
    _sum?: EthicalConfigVersionSumOrderByAggregateInput
  }

  export type EthicalConfigVersionScalarWhereWithAggregatesInput = {
    AND?: EthicalConfigVersionScalarWhereWithAggregatesInput | EthicalConfigVersionScalarWhereWithAggregatesInput[]
    OR?: EthicalConfigVersionScalarWhereWithAggregatesInput[]
    NOT?: EthicalConfigVersionScalarWhereWithAggregatesInput | EthicalConfigVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EthicalConfigVersion"> | string
    configId?: StringWithAggregatesFilter<"EthicalConfigVersion"> | string
    version?: IntWithAggregatesFilter<"EthicalConfigVersion"> | number
    data?: JsonWithAggregatesFilter<"EthicalConfigVersion">
    createdAt?: DateTimeWithAggregatesFilter<"EthicalConfigVersion"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"EthicalConfigVersion"> | string | null
  }

  export type RoleTemplateWhereInput = {
    AND?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    OR?: RoleTemplateWhereInput[]
    NOT?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    id?: StringFilter<"RoleTemplate"> | string
    type?: EnumRelationshipRoleTemplateTypeFilter<"RoleTemplate"> | $Enums.RelationshipRoleTemplateType
    key?: StringFilter<"RoleTemplate"> | string
    displayName?: StringFilter<"RoleTemplate"> | string
    description?: StringNullableFilter<"RoleTemplate"> | string | null
    defaultSettings?: JsonNullableFilter<"RoleTemplate">
    createdAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    relationships?: RelationshipListRelationFilter
  }

  export type RoleTemplateOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultSettings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    relationships?: RelationshipOrderByRelationAggregateInput
  }

  export type RoleTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    OR?: RoleTemplateWhereInput[]
    NOT?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    type?: EnumRelationshipRoleTemplateTypeFilter<"RoleTemplate"> | $Enums.RelationshipRoleTemplateType
    displayName?: StringFilter<"RoleTemplate"> | string
    description?: StringNullableFilter<"RoleTemplate"> | string | null
    defaultSettings?: JsonNullableFilter<"RoleTemplate">
    createdAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    relationships?: RelationshipListRelationFilter
  }, "id" | "key">

  export type RoleTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultSettings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleTemplateCountOrderByAggregateInput
    _max?: RoleTemplateMaxOrderByAggregateInput
    _min?: RoleTemplateMinOrderByAggregateInput
  }

  export type RoleTemplateScalarWhereWithAggregatesInput = {
    AND?: RoleTemplateScalarWhereWithAggregatesInput | RoleTemplateScalarWhereWithAggregatesInput[]
    OR?: RoleTemplateScalarWhereWithAggregatesInput[]
    NOT?: RoleTemplateScalarWhereWithAggregatesInput | RoleTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleTemplate"> | string
    type?: EnumRelationshipRoleTemplateTypeWithAggregatesFilter<"RoleTemplate"> | $Enums.RelationshipRoleTemplateType
    key?: StringWithAggregatesFilter<"RoleTemplate"> | string
    displayName?: StringWithAggregatesFilter<"RoleTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"RoleTemplate"> | string | null
    defaultSettings?: JsonNullableWithAggregatesFilter<"RoleTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"RoleTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleTemplate"> | Date | string
  }

  export type CulturalParameterWhereInput = {
    AND?: CulturalParameterWhereInput | CulturalParameterWhereInput[]
    OR?: CulturalParameterWhereInput[]
    NOT?: CulturalParameterWhereInput | CulturalParameterWhereInput[]
    id?: StringFilter<"CulturalParameter"> | string
    regionCode?: StringFilter<"CulturalParameter"> | string
    cultureKey?: StringFilter<"CulturalParameter"> | string
    settings?: JsonFilter<"CulturalParameter">
    createdAt?: DateTimeFilter<"CulturalParameter"> | Date | string
    updatedAt?: DateTimeFilter<"CulturalParameter"> | Date | string
  }

  export type CulturalParameterOrderByWithRelationInput = {
    id?: SortOrder
    regionCode?: SortOrder
    cultureKey?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CulturalParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    regionCode_cultureKey?: CulturalParameterRegionCodeCultureKeyCompoundUniqueInput
    AND?: CulturalParameterWhereInput | CulturalParameterWhereInput[]
    OR?: CulturalParameterWhereInput[]
    NOT?: CulturalParameterWhereInput | CulturalParameterWhereInput[]
    regionCode?: StringFilter<"CulturalParameter"> | string
    cultureKey?: StringFilter<"CulturalParameter"> | string
    settings?: JsonFilter<"CulturalParameter">
    createdAt?: DateTimeFilter<"CulturalParameter"> | Date | string
    updatedAt?: DateTimeFilter<"CulturalParameter"> | Date | string
  }, "id" | "regionCode_cultureKey">

  export type CulturalParameterOrderByWithAggregationInput = {
    id?: SortOrder
    regionCode?: SortOrder
    cultureKey?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CulturalParameterCountOrderByAggregateInput
    _max?: CulturalParameterMaxOrderByAggregateInput
    _min?: CulturalParameterMinOrderByAggregateInput
  }

  export type CulturalParameterScalarWhereWithAggregatesInput = {
    AND?: CulturalParameterScalarWhereWithAggregatesInput | CulturalParameterScalarWhereWithAggregatesInput[]
    OR?: CulturalParameterScalarWhereWithAggregatesInput[]
    NOT?: CulturalParameterScalarWhereWithAggregatesInput | CulturalParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CulturalParameter"> | string
    regionCode?: StringWithAggregatesFilter<"CulturalParameter"> | string
    cultureKey?: StringWithAggregatesFilter<"CulturalParameter"> | string
    settings?: JsonWithAggregatesFilter<"CulturalParameter">
    createdAt?: DateTimeWithAggregatesFilter<"CulturalParameter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CulturalParameter"> | Date | string
  }

  export type RelationshipWhereInput = {
    AND?: RelationshipWhereInput | RelationshipWhereInput[]
    OR?: RelationshipWhereInput[]
    NOT?: RelationshipWhereInput | RelationshipWhereInput[]
    id?: StringFilter<"Relationship"> | string
    userId?: StringFilter<"Relationship"> | string
    counterpartUserId?: StringNullableFilter<"Relationship"> | string | null
    roleTemplateId?: StringNullableFilter<"Relationship"> | string | null
    title?: StringNullableFilter<"Relationship"> | string | null
    metadata?: JsonNullableFilter<"Relationship">
    createdAt?: DateTimeFilter<"Relationship"> | Date | string
    updatedAt?: DateTimeFilter<"Relationship"> | Date | string
    isActive?: BoolFilter<"Relationship"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    counterpartUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    roleTemplate?: XOR<RoleTemplateNullableScalarRelationFilter, RoleTemplateWhereInput> | null
    messages?: ConversationMessageListRelationFilter
    growthMetrics?: GrowthMetricListRelationFilter
  }

  export type RelationshipOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    counterpartUserId?: SortOrderInput | SortOrder
    roleTemplateId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    user?: UserOrderByWithRelationInput
    counterpartUser?: UserOrderByWithRelationInput
    roleTemplate?: RoleTemplateOrderByWithRelationInput
    messages?: ConversationMessageOrderByRelationAggregateInput
    growthMetrics?: GrowthMetricOrderByRelationAggregateInput
  }

  export type RelationshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RelationshipWhereInput | RelationshipWhereInput[]
    OR?: RelationshipWhereInput[]
    NOT?: RelationshipWhereInput | RelationshipWhereInput[]
    userId?: StringFilter<"Relationship"> | string
    counterpartUserId?: StringNullableFilter<"Relationship"> | string | null
    roleTemplateId?: StringNullableFilter<"Relationship"> | string | null
    title?: StringNullableFilter<"Relationship"> | string | null
    metadata?: JsonNullableFilter<"Relationship">
    createdAt?: DateTimeFilter<"Relationship"> | Date | string
    updatedAt?: DateTimeFilter<"Relationship"> | Date | string
    isActive?: BoolFilter<"Relationship"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    counterpartUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    roleTemplate?: XOR<RoleTemplateNullableScalarRelationFilter, RoleTemplateWhereInput> | null
    messages?: ConversationMessageListRelationFilter
    growthMetrics?: GrowthMetricListRelationFilter
  }, "id">

  export type RelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    counterpartUserId?: SortOrderInput | SortOrder
    roleTemplateId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    _count?: RelationshipCountOrderByAggregateInput
    _max?: RelationshipMaxOrderByAggregateInput
    _min?: RelationshipMinOrderByAggregateInput
  }

  export type RelationshipScalarWhereWithAggregatesInput = {
    AND?: RelationshipScalarWhereWithAggregatesInput | RelationshipScalarWhereWithAggregatesInput[]
    OR?: RelationshipScalarWhereWithAggregatesInput[]
    NOT?: RelationshipScalarWhereWithAggregatesInput | RelationshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Relationship"> | string
    userId?: StringWithAggregatesFilter<"Relationship"> | string
    counterpartUserId?: StringNullableWithAggregatesFilter<"Relationship"> | string | null
    roleTemplateId?: StringNullableWithAggregatesFilter<"Relationship"> | string | null
    title?: StringNullableWithAggregatesFilter<"Relationship"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Relationship">
    createdAt?: DateTimeWithAggregatesFilter<"Relationship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Relationship"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Relationship"> | boolean
  }

  export type ConversationMessageWhereInput = {
    AND?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    OR?: ConversationMessageWhereInput[]
    NOT?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    id?: StringFilter<"ConversationMessage"> | string
    relationshipId?: StringFilter<"ConversationMessage"> | string
    senderId?: StringNullableFilter<"ConversationMessage"> | string | null
    content?: StringFilter<"ConversationMessage"> | string
    emotionalTone?: EnumEmotionalToneFilter<"ConversationMessage"> | $Enums.EmotionalTone
    metadata?: JsonNullableFilter<"ConversationMessage">
    createdAt?: DateTimeFilter<"ConversationMessage"> | Date | string
    relationship?: XOR<RelationshipScalarRelationFilter, RelationshipWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ConversationMessageOrderByWithRelationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    content?: SortOrder
    emotionalTone?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    relationship?: RelationshipOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type ConversationMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    OR?: ConversationMessageWhereInput[]
    NOT?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    relationshipId?: StringFilter<"ConversationMessage"> | string
    senderId?: StringNullableFilter<"ConversationMessage"> | string | null
    content?: StringFilter<"ConversationMessage"> | string
    emotionalTone?: EnumEmotionalToneFilter<"ConversationMessage"> | $Enums.EmotionalTone
    metadata?: JsonNullableFilter<"ConversationMessage">
    createdAt?: DateTimeFilter<"ConversationMessage"> | Date | string
    relationship?: XOR<RelationshipScalarRelationFilter, RelationshipWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ConversationMessageOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    content?: SortOrder
    emotionalTone?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConversationMessageCountOrderByAggregateInput
    _max?: ConversationMessageMaxOrderByAggregateInput
    _min?: ConversationMessageMinOrderByAggregateInput
  }

  export type ConversationMessageScalarWhereWithAggregatesInput = {
    AND?: ConversationMessageScalarWhereWithAggregatesInput | ConversationMessageScalarWhereWithAggregatesInput[]
    OR?: ConversationMessageScalarWhereWithAggregatesInput[]
    NOT?: ConversationMessageScalarWhereWithAggregatesInput | ConversationMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationMessage"> | string
    relationshipId?: StringWithAggregatesFilter<"ConversationMessage"> | string
    senderId?: StringNullableWithAggregatesFilter<"ConversationMessage"> | string | null
    content?: StringWithAggregatesFilter<"ConversationMessage"> | string
    emotionalTone?: EnumEmotionalToneWithAggregatesFilter<"ConversationMessage"> | $Enums.EmotionalTone
    metadata?: JsonNullableWithAggregatesFilter<"ConversationMessage">
    createdAt?: DateTimeWithAggregatesFilter<"ConversationMessage"> | Date | string
  }

  export type GrowthMetricWhereInput = {
    AND?: GrowthMetricWhereInput | GrowthMetricWhereInput[]
    OR?: GrowthMetricWhereInput[]
    NOT?: GrowthMetricWhereInput | GrowthMetricWhereInput[]
    id?: StringFilter<"GrowthMetric"> | string
    relationshipId?: StringFilter<"GrowthMetric"> | string
    bucketDate?: DateTimeFilter<"GrowthMetric"> | Date | string
    messagesCount?: IntFilter<"GrowthMetric"> | number
    positiveCount?: IntFilter<"GrowthMetric"> | number
    neutralCount?: IntFilter<"GrowthMetric"> | number
    negativeCount?: IntFilter<"GrowthMetric"> | number
    metrics?: JsonNullableFilter<"GrowthMetric">
    relationship?: XOR<RelationshipScalarRelationFilter, RelationshipWhereInput>
  }

  export type GrowthMetricOrderByWithRelationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    bucketDate?: SortOrder
    messagesCount?: SortOrder
    positiveCount?: SortOrder
    neutralCount?: SortOrder
    negativeCount?: SortOrder
    metrics?: SortOrderInput | SortOrder
    relationship?: RelationshipOrderByWithRelationInput
  }

  export type GrowthMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    relationshipId_bucketDate?: GrowthMetricRelationshipIdBucketDateCompoundUniqueInput
    AND?: GrowthMetricWhereInput | GrowthMetricWhereInput[]
    OR?: GrowthMetricWhereInput[]
    NOT?: GrowthMetricWhereInput | GrowthMetricWhereInput[]
    relationshipId?: StringFilter<"GrowthMetric"> | string
    bucketDate?: DateTimeFilter<"GrowthMetric"> | Date | string
    messagesCount?: IntFilter<"GrowthMetric"> | number
    positiveCount?: IntFilter<"GrowthMetric"> | number
    neutralCount?: IntFilter<"GrowthMetric"> | number
    negativeCount?: IntFilter<"GrowthMetric"> | number
    metrics?: JsonNullableFilter<"GrowthMetric">
    relationship?: XOR<RelationshipScalarRelationFilter, RelationshipWhereInput>
  }, "id" | "relationshipId_bucketDate">

  export type GrowthMetricOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    bucketDate?: SortOrder
    messagesCount?: SortOrder
    positiveCount?: SortOrder
    neutralCount?: SortOrder
    negativeCount?: SortOrder
    metrics?: SortOrderInput | SortOrder
    _count?: GrowthMetricCountOrderByAggregateInput
    _avg?: GrowthMetricAvgOrderByAggregateInput
    _max?: GrowthMetricMaxOrderByAggregateInput
    _min?: GrowthMetricMinOrderByAggregateInput
    _sum?: GrowthMetricSumOrderByAggregateInput
  }

  export type GrowthMetricScalarWhereWithAggregatesInput = {
    AND?: GrowthMetricScalarWhereWithAggregatesInput | GrowthMetricScalarWhereWithAggregatesInput[]
    OR?: GrowthMetricScalarWhereWithAggregatesInput[]
    NOT?: GrowthMetricScalarWhereWithAggregatesInput | GrowthMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GrowthMetric"> | string
    relationshipId?: StringWithAggregatesFilter<"GrowthMetric"> | string
    bucketDate?: DateTimeWithAggregatesFilter<"GrowthMetric"> | Date | string
    messagesCount?: IntWithAggregatesFilter<"GrowthMetric"> | number
    positiveCount?: IntWithAggregatesFilter<"GrowthMetric"> | number
    neutralCount?: IntWithAggregatesFilter<"GrowthMetric"> | number
    negativeCount?: IntWithAggregatesFilter<"GrowthMetric"> | number
    metrics?: JsonNullableWithAggregatesFilter<"GrowthMetric">
  }

  export type VoiceProfileWhereInput = {
    AND?: VoiceProfileWhereInput | VoiceProfileWhereInput[]
    OR?: VoiceProfileWhereInput[]
    NOT?: VoiceProfileWhereInput | VoiceProfileWhereInput[]
    id?: StringFilter<"VoiceProfile"> | string
    userId?: StringFilter<"VoiceProfile"> | string
    settings?: JsonNullableFilter<"VoiceProfile">
    sampleUrl?: StringNullableFilter<"VoiceProfile"> | string | null
    createdAt?: DateTimeFilter<"VoiceProfile"> | Date | string
    updatedAt?: DateTimeFilter<"VoiceProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    samples?: VoiceSampleListRelationFilter
  }

  export type VoiceProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    settings?: SortOrderInput | SortOrder
    sampleUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    samples?: VoiceSampleOrderByRelationAggregateInput
  }

  export type VoiceProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: VoiceProfileWhereInput | VoiceProfileWhereInput[]
    OR?: VoiceProfileWhereInput[]
    NOT?: VoiceProfileWhereInput | VoiceProfileWhereInput[]
    settings?: JsonNullableFilter<"VoiceProfile">
    sampleUrl?: StringNullableFilter<"VoiceProfile"> | string | null
    createdAt?: DateTimeFilter<"VoiceProfile"> | Date | string
    updatedAt?: DateTimeFilter<"VoiceProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    samples?: VoiceSampleListRelationFilter
  }, "id" | "userId">

  export type VoiceProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    settings?: SortOrderInput | SortOrder
    sampleUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoiceProfileCountOrderByAggregateInput
    _max?: VoiceProfileMaxOrderByAggregateInput
    _min?: VoiceProfileMinOrderByAggregateInput
  }

  export type VoiceProfileScalarWhereWithAggregatesInput = {
    AND?: VoiceProfileScalarWhereWithAggregatesInput | VoiceProfileScalarWhereWithAggregatesInput[]
    OR?: VoiceProfileScalarWhereWithAggregatesInput[]
    NOT?: VoiceProfileScalarWhereWithAggregatesInput | VoiceProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VoiceProfile"> | string
    userId?: StringWithAggregatesFilter<"VoiceProfile"> | string
    settings?: JsonNullableWithAggregatesFilter<"VoiceProfile">
    sampleUrl?: StringNullableWithAggregatesFilter<"VoiceProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VoiceProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VoiceProfile"> | Date | string
  }

  export type VoiceSampleWhereInput = {
    AND?: VoiceSampleWhereInput | VoiceSampleWhereInput[]
    OR?: VoiceSampleWhereInput[]
    NOT?: VoiceSampleWhereInput | VoiceSampleWhereInput[]
    id?: StringFilter<"VoiceSample"> | string
    voiceProfileId?: StringFilter<"VoiceSample"> | string
    url?: StringFilter<"VoiceSample"> | string
    durationMs?: IntNullableFilter<"VoiceSample"> | number | null
    metadata?: JsonNullableFilter<"VoiceSample">
    createdAt?: DateTimeFilter<"VoiceSample"> | Date | string
    voiceProfile?: XOR<VoiceProfileScalarRelationFilter, VoiceProfileWhereInput>
  }

  export type VoiceSampleOrderByWithRelationInput = {
    id?: SortOrder
    voiceProfileId?: SortOrder
    url?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    voiceProfile?: VoiceProfileOrderByWithRelationInput
  }

  export type VoiceSampleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoiceSampleWhereInput | VoiceSampleWhereInput[]
    OR?: VoiceSampleWhereInput[]
    NOT?: VoiceSampleWhereInput | VoiceSampleWhereInput[]
    voiceProfileId?: StringFilter<"VoiceSample"> | string
    url?: StringFilter<"VoiceSample"> | string
    durationMs?: IntNullableFilter<"VoiceSample"> | number | null
    metadata?: JsonNullableFilter<"VoiceSample">
    createdAt?: DateTimeFilter<"VoiceSample"> | Date | string
    voiceProfile?: XOR<VoiceProfileScalarRelationFilter, VoiceProfileWhereInput>
  }, "id">

  export type VoiceSampleOrderByWithAggregationInput = {
    id?: SortOrder
    voiceProfileId?: SortOrder
    url?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VoiceSampleCountOrderByAggregateInput
    _avg?: VoiceSampleAvgOrderByAggregateInput
    _max?: VoiceSampleMaxOrderByAggregateInput
    _min?: VoiceSampleMinOrderByAggregateInput
    _sum?: VoiceSampleSumOrderByAggregateInput
  }

  export type VoiceSampleScalarWhereWithAggregatesInput = {
    AND?: VoiceSampleScalarWhereWithAggregatesInput | VoiceSampleScalarWhereWithAggregatesInput[]
    OR?: VoiceSampleScalarWhereWithAggregatesInput[]
    NOT?: VoiceSampleScalarWhereWithAggregatesInput | VoiceSampleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VoiceSample"> | string
    voiceProfileId?: StringWithAggregatesFilter<"VoiceSample"> | string
    url?: StringWithAggregatesFilter<"VoiceSample"> | string
    durationMs?: IntNullableWithAggregatesFilter<"VoiceSample"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"VoiceSample">
    createdAt?: DateTimeWithAggregatesFilter<"VoiceSample"> | Date | string
  }

  export type AvatarProfileWhereInput = {
    AND?: AvatarProfileWhereInput | AvatarProfileWhereInput[]
    OR?: AvatarProfileWhereInput[]
    NOT?: AvatarProfileWhereInput | AvatarProfileWhereInput[]
    id?: StringFilter<"AvatarProfile"> | string
    userId?: StringFilter<"AvatarProfile"> | string
    settings?: JsonNullableFilter<"AvatarProfile">
    imageUrl?: StringNullableFilter<"AvatarProfile"> | string | null
    createdAt?: DateTimeFilter<"AvatarProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AvatarProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assets?: AvatarAssetListRelationFilter
  }

  export type AvatarProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    settings?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    assets?: AvatarAssetOrderByRelationAggregateInput
  }

  export type AvatarProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AvatarProfileWhereInput | AvatarProfileWhereInput[]
    OR?: AvatarProfileWhereInput[]
    NOT?: AvatarProfileWhereInput | AvatarProfileWhereInput[]
    settings?: JsonNullableFilter<"AvatarProfile">
    imageUrl?: StringNullableFilter<"AvatarProfile"> | string | null
    createdAt?: DateTimeFilter<"AvatarProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AvatarProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    assets?: AvatarAssetListRelationFilter
  }, "id" | "userId">

  export type AvatarProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    settings?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AvatarProfileCountOrderByAggregateInput
    _max?: AvatarProfileMaxOrderByAggregateInput
    _min?: AvatarProfileMinOrderByAggregateInput
  }

  export type AvatarProfileScalarWhereWithAggregatesInput = {
    AND?: AvatarProfileScalarWhereWithAggregatesInput | AvatarProfileScalarWhereWithAggregatesInput[]
    OR?: AvatarProfileScalarWhereWithAggregatesInput[]
    NOT?: AvatarProfileScalarWhereWithAggregatesInput | AvatarProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AvatarProfile"> | string
    userId?: StringWithAggregatesFilter<"AvatarProfile"> | string
    settings?: JsonNullableWithAggregatesFilter<"AvatarProfile">
    imageUrl?: StringNullableWithAggregatesFilter<"AvatarProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AvatarProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AvatarProfile"> | Date | string
  }

  export type AvatarAssetWhereInput = {
    AND?: AvatarAssetWhereInput | AvatarAssetWhereInput[]
    OR?: AvatarAssetWhereInput[]
    NOT?: AvatarAssetWhereInput | AvatarAssetWhereInput[]
    id?: StringFilter<"AvatarAsset"> | string
    avatarProfileId?: StringFilter<"AvatarAsset"> | string
    url?: StringFilter<"AvatarAsset"> | string
    description?: StringNullableFilter<"AvatarAsset"> | string | null
    metadata?: JsonNullableFilter<"AvatarAsset">
    createdAt?: DateTimeFilter<"AvatarAsset"> | Date | string
    avatarProfile?: XOR<AvatarProfileScalarRelationFilter, AvatarProfileWhereInput>
  }

  export type AvatarAssetOrderByWithRelationInput = {
    id?: SortOrder
    avatarProfileId?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    avatarProfile?: AvatarProfileOrderByWithRelationInput
  }

  export type AvatarAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvatarAssetWhereInput | AvatarAssetWhereInput[]
    OR?: AvatarAssetWhereInput[]
    NOT?: AvatarAssetWhereInput | AvatarAssetWhereInput[]
    avatarProfileId?: StringFilter<"AvatarAsset"> | string
    url?: StringFilter<"AvatarAsset"> | string
    description?: StringNullableFilter<"AvatarAsset"> | string | null
    metadata?: JsonNullableFilter<"AvatarAsset">
    createdAt?: DateTimeFilter<"AvatarAsset"> | Date | string
    avatarProfile?: XOR<AvatarProfileScalarRelationFilter, AvatarProfileWhereInput>
  }, "id">

  export type AvatarAssetOrderByWithAggregationInput = {
    id?: SortOrder
    avatarProfileId?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AvatarAssetCountOrderByAggregateInput
    _max?: AvatarAssetMaxOrderByAggregateInput
    _min?: AvatarAssetMinOrderByAggregateInput
  }

  export type AvatarAssetScalarWhereWithAggregatesInput = {
    AND?: AvatarAssetScalarWhereWithAggregatesInput | AvatarAssetScalarWhereWithAggregatesInput[]
    OR?: AvatarAssetScalarWhereWithAggregatesInput[]
    NOT?: AvatarAssetScalarWhereWithAggregatesInput | AvatarAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AvatarAsset"> | string
    avatarProfileId?: StringWithAggregatesFilter<"AvatarAsset"> | string
    url?: StringWithAggregatesFilter<"AvatarAsset"> | string
    description?: StringNullableWithAggregatesFilter<"AvatarAsset"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AvatarAsset">
    createdAt?: DateTimeWithAggregatesFilter<"AvatarAsset"> | Date | string
  }

  export type UploadWhereInput = {
    AND?: UploadWhereInput | UploadWhereInput[]
    OR?: UploadWhereInput[]
    NOT?: UploadWhereInput | UploadWhereInput[]
    id?: StringFilter<"Upload"> | string
    userId?: StringNullableFilter<"Upload"> | string | null
    mediaType?: EnumMediaTypeFilter<"Upload"> | $Enums.MediaType
    url?: StringFilter<"Upload"> | string
    originalName?: StringNullableFilter<"Upload"> | string | null
    sizeBytes?: IntNullableFilter<"Upload"> | number | null
    metadata?: JsonNullableFilter<"Upload">
    createdAt?: DateTimeFilter<"Upload"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UploadOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    originalName?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UploadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UploadWhereInput | UploadWhereInput[]
    OR?: UploadWhereInput[]
    NOT?: UploadWhereInput | UploadWhereInput[]
    userId?: StringNullableFilter<"Upload"> | string | null
    mediaType?: EnumMediaTypeFilter<"Upload"> | $Enums.MediaType
    url?: StringFilter<"Upload"> | string
    originalName?: StringNullableFilter<"Upload"> | string | null
    sizeBytes?: IntNullableFilter<"Upload"> | number | null
    metadata?: JsonNullableFilter<"Upload">
    createdAt?: DateTimeFilter<"Upload"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type UploadOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    originalName?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UploadCountOrderByAggregateInput
    _avg?: UploadAvgOrderByAggregateInput
    _max?: UploadMaxOrderByAggregateInput
    _min?: UploadMinOrderByAggregateInput
    _sum?: UploadSumOrderByAggregateInput
  }

  export type UploadScalarWhereWithAggregatesInput = {
    AND?: UploadScalarWhereWithAggregatesInput | UploadScalarWhereWithAggregatesInput[]
    OR?: UploadScalarWhereWithAggregatesInput[]
    NOT?: UploadScalarWhereWithAggregatesInput | UploadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Upload"> | string
    userId?: StringNullableWithAggregatesFilter<"Upload"> | string | null
    mediaType?: EnumMediaTypeWithAggregatesFilter<"Upload"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"Upload"> | string
    originalName?: StringNullableWithAggregatesFilter<"Upload"> | string | null
    sizeBytes?: IntNullableWithAggregatesFilter<"Upload"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"Upload">
    createdAt?: DateTimeWithAggregatesFilter<"Upload"> | Date | string
  }

  export type UsageEventWhereInput = {
    AND?: UsageEventWhereInput | UsageEventWhereInput[]
    OR?: UsageEventWhereInput[]
    NOT?: UsageEventWhereInput | UsageEventWhereInput[]
    id?: StringFilter<"UsageEvent"> | string
    userId?: StringNullableFilter<"UsageEvent"> | string | null
    type?: EnumUsageEventTypeFilter<"UsageEvent"> | $Enums.UsageEventType
    metadata?: JsonNullableFilter<"UsageEvent">
    createdAt?: DateTimeFilter<"UsageEvent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UsageEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UsageEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageEventWhereInput | UsageEventWhereInput[]
    OR?: UsageEventWhereInput[]
    NOT?: UsageEventWhereInput | UsageEventWhereInput[]
    userId?: StringNullableFilter<"UsageEvent"> | string | null
    type?: EnumUsageEventTypeFilter<"UsageEvent"> | $Enums.UsageEventType
    metadata?: JsonNullableFilter<"UsageEvent">
    createdAt?: DateTimeFilter<"UsageEvent"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type UsageEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UsageEventCountOrderByAggregateInput
    _max?: UsageEventMaxOrderByAggregateInput
    _min?: UsageEventMinOrderByAggregateInput
  }

  export type UsageEventScalarWhereWithAggregatesInput = {
    AND?: UsageEventScalarWhereWithAggregatesInput | UsageEventScalarWhereWithAggregatesInput[]
    OR?: UsageEventScalarWhereWithAggregatesInput[]
    NOT?: UsageEventScalarWhereWithAggregatesInput | UsageEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"UsageEvent"> | string | null
    type?: EnumUsageEventTypeWithAggregatesFilter<"UsageEvent"> | $Enums.UsageEventType
    metadata?: JsonNullableWithAggregatesFilter<"UsageEvent">
    createdAt?: DateTimeWithAggregatesFilter<"UsageEvent"> | Date | string
  }

  export type SystemMetricWhereInput = {
    AND?: SystemMetricWhereInput | SystemMetricWhereInput[]
    OR?: SystemMetricWhereInput[]
    NOT?: SystemMetricWhereInput | SystemMetricWhereInput[]
    id?: StringFilter<"SystemMetric"> | string
    name?: StringFilter<"SystemMetric"> | string
    labels?: JsonNullableFilter<"SystemMetric">
    value?: FloatFilter<"SystemMetric"> | number
    capturedAt?: DateTimeFilter<"SystemMetric"> | Date | string
  }

  export type SystemMetricOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    labels?: SortOrderInput | SortOrder
    value?: SortOrder
    capturedAt?: SortOrder
  }

  export type SystemMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemMetricWhereInput | SystemMetricWhereInput[]
    OR?: SystemMetricWhereInput[]
    NOT?: SystemMetricWhereInput | SystemMetricWhereInput[]
    name?: StringFilter<"SystemMetric"> | string
    labels?: JsonNullableFilter<"SystemMetric">
    value?: FloatFilter<"SystemMetric"> | number
    capturedAt?: DateTimeFilter<"SystemMetric"> | Date | string
  }, "id">

  export type SystemMetricOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    labels?: SortOrderInput | SortOrder
    value?: SortOrder
    capturedAt?: SortOrder
    _count?: SystemMetricCountOrderByAggregateInput
    _avg?: SystemMetricAvgOrderByAggregateInput
    _max?: SystemMetricMaxOrderByAggregateInput
    _min?: SystemMetricMinOrderByAggregateInput
    _sum?: SystemMetricSumOrderByAggregateInput
  }

  export type SystemMetricScalarWhereWithAggregatesInput = {
    AND?: SystemMetricScalarWhereWithAggregatesInput | SystemMetricScalarWhereWithAggregatesInput[]
    OR?: SystemMetricScalarWhereWithAggregatesInput[]
    NOT?: SystemMetricScalarWhereWithAggregatesInput | SystemMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemMetric"> | string
    name?: StringWithAggregatesFilter<"SystemMetric"> | string
    labels?: JsonNullableWithAggregatesFilter<"SystemMetric">
    value?: FloatWithAggregatesFilter<"SystemMetric"> | number
    capturedAt?: DateTimeWithAggregatesFilter<"SystemMetric"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeWithAggregatesFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type BackupSnapshotWhereInput = {
    AND?: BackupSnapshotWhereInput | BackupSnapshotWhereInput[]
    OR?: BackupSnapshotWhereInput[]
    NOT?: BackupSnapshotWhereInput | BackupSnapshotWhereInput[]
    id?: StringFilter<"BackupSnapshot"> | string
    label?: StringNullableFilter<"BackupSnapshot"> | string | null
    snapshotType?: StringFilter<"BackupSnapshot"> | string
    locationUrl?: StringFilter<"BackupSnapshot"> | string
    metadata?: JsonNullableFilter<"BackupSnapshot">
    createdAt?: DateTimeFilter<"BackupSnapshot"> | Date | string
  }

  export type BackupSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrderInput | SortOrder
    snapshotType?: SortOrder
    locationUrl?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type BackupSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BackupSnapshotWhereInput | BackupSnapshotWhereInput[]
    OR?: BackupSnapshotWhereInput[]
    NOT?: BackupSnapshotWhereInput | BackupSnapshotWhereInput[]
    label?: StringNullableFilter<"BackupSnapshot"> | string | null
    snapshotType?: StringFilter<"BackupSnapshot"> | string
    locationUrl?: StringFilter<"BackupSnapshot"> | string
    metadata?: JsonNullableFilter<"BackupSnapshot">
    createdAt?: DateTimeFilter<"BackupSnapshot"> | Date | string
  }, "id">

  export type BackupSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrderInput | SortOrder
    snapshotType?: SortOrder
    locationUrl?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BackupSnapshotCountOrderByAggregateInput
    _max?: BackupSnapshotMaxOrderByAggregateInput
    _min?: BackupSnapshotMinOrderByAggregateInput
  }

  export type BackupSnapshotScalarWhereWithAggregatesInput = {
    AND?: BackupSnapshotScalarWhereWithAggregatesInput | BackupSnapshotScalarWhereWithAggregatesInput[]
    OR?: BackupSnapshotScalarWhereWithAggregatesInput[]
    NOT?: BackupSnapshotScalarWhereWithAggregatesInput | BackupSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BackupSnapshot"> | string
    label?: StringNullableWithAggregatesFilter<"BackupSnapshot"> | string | null
    snapshotType?: StringWithAggregatesFilter<"BackupSnapshot"> | string
    locationUrl?: StringWithAggregatesFilter<"BackupSnapshot"> | string
    metadata?: JsonNullableWithAggregatesFilter<"BackupSnapshot">
    createdAt?: DateTimeWithAggregatesFilter<"BackupSnapshot"> | Date | string
  }

  export type ConfigVersionHistoryWhereInput = {
    AND?: ConfigVersionHistoryWhereInput | ConfigVersionHistoryWhereInput[]
    OR?: ConfigVersionHistoryWhereInput[]
    NOT?: ConfigVersionHistoryWhereInput | ConfigVersionHistoryWhereInput[]
    id?: StringFilter<"ConfigVersionHistory"> | string
    configId?: StringFilter<"ConfigVersionHistory"> | string
    fromVersion?: IntFilter<"ConfigVersionHistory"> | number
    toVersion?: IntFilter<"ConfigVersionHistory"> | number
    reason?: StringNullableFilter<"ConfigVersionHistory"> | string | null
    changedById?: StringNullableFilter<"ConfigVersionHistory"> | string | null
    changedAt?: DateTimeFilter<"ConfigVersionHistory"> | Date | string
    config?: XOR<EthicalConfigScalarRelationFilter, EthicalConfigWhereInput>
  }

  export type ConfigVersionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    configId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    reason?: SortOrderInput | SortOrder
    changedById?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    config?: EthicalConfigOrderByWithRelationInput
  }

  export type ConfigVersionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConfigVersionHistoryWhereInput | ConfigVersionHistoryWhereInput[]
    OR?: ConfigVersionHistoryWhereInput[]
    NOT?: ConfigVersionHistoryWhereInput | ConfigVersionHistoryWhereInput[]
    configId?: StringFilter<"ConfigVersionHistory"> | string
    fromVersion?: IntFilter<"ConfigVersionHistory"> | number
    toVersion?: IntFilter<"ConfigVersionHistory"> | number
    reason?: StringNullableFilter<"ConfigVersionHistory"> | string | null
    changedById?: StringNullableFilter<"ConfigVersionHistory"> | string | null
    changedAt?: DateTimeFilter<"ConfigVersionHistory"> | Date | string
    config?: XOR<EthicalConfigScalarRelationFilter, EthicalConfigWhereInput>
  }, "id">

  export type ConfigVersionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    configId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    reason?: SortOrderInput | SortOrder
    changedById?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    _count?: ConfigVersionHistoryCountOrderByAggregateInput
    _avg?: ConfigVersionHistoryAvgOrderByAggregateInput
    _max?: ConfigVersionHistoryMaxOrderByAggregateInput
    _min?: ConfigVersionHistoryMinOrderByAggregateInput
    _sum?: ConfigVersionHistorySumOrderByAggregateInput
  }

  export type ConfigVersionHistoryScalarWhereWithAggregatesInput = {
    AND?: ConfigVersionHistoryScalarWhereWithAggregatesInput | ConfigVersionHistoryScalarWhereWithAggregatesInput[]
    OR?: ConfigVersionHistoryScalarWhereWithAggregatesInput[]
    NOT?: ConfigVersionHistoryScalarWhereWithAggregatesInput | ConfigVersionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConfigVersionHistory"> | string
    configId?: StringWithAggregatesFilter<"ConfigVersionHistory"> | string
    fromVersion?: IntWithAggregatesFilter<"ConfigVersionHistory"> | number
    toVersion?: IntWithAggregatesFilter<"ConfigVersionHistory"> | number
    reason?: StringNullableWithAggregatesFilter<"ConfigVersionHistory"> | string | null
    changedById?: StringNullableWithAggregatesFilter<"ConfigVersionHistory"> | string | null
    changedAt?: DateTimeWithAggregatesFilter<"ConfigVersionHistory"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    relationships?: RelationshipCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileCreateNestedOneWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    relationships?: RelationshipUncheckedCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileUncheckedCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileUncheckedCreateNestedOneWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUpdateOneWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUncheckedUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUncheckedUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUncheckedUpdateOneWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AdminUserCreateInput = {
    id?: string
    role: $Enums.AdminRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminProfileInput
  }

  export type AdminUserUncheckedCreateInput = {
    id?: string
    userId: string
    role: $Enums.AdminRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminProfileNestedInput
  }

  export type AdminUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserCreateManyInput = {
    id?: string
    userId: string
    role: $Enums.AdminRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EthicalConfigCreateInput = {
    id?: string
    name: string
    description?: string | null
    latestVersion?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: EthicalConfigVersionCreateNestedManyWithoutConfigInput
    history?: ConfigVersionHistoryCreateNestedManyWithoutConfigInput
  }

  export type EthicalConfigUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    latestVersion?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: EthicalConfigVersionUncheckedCreateNestedManyWithoutConfigInput
    history?: ConfigVersionHistoryUncheckedCreateNestedManyWithoutConfigInput
  }

  export type EthicalConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersion?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: EthicalConfigVersionUpdateManyWithoutConfigNestedInput
    history?: ConfigVersionHistoryUpdateManyWithoutConfigNestedInput
  }

  export type EthicalConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersion?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: EthicalConfigVersionUncheckedUpdateManyWithoutConfigNestedInput
    history?: ConfigVersionHistoryUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type EthicalConfigCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    latestVersion?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EthicalConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersion?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EthicalConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersion?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EthicalConfigVersionCreateInput = {
    id?: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
    config: EthicalConfigCreateNestedOneWithoutVersionsInput
  }

  export type EthicalConfigVersionUncheckedCreateInput = {
    id?: string
    configId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
  }

  export type EthicalConfigVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    config?: EthicalConfigUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type EthicalConfigVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EthicalConfigVersionCreateManyInput = {
    id?: string
    configId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
  }

  export type EthicalConfigVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EthicalConfigVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleTemplateCreateInput = {
    id?: string
    type: $Enums.RelationshipRoleTemplateType
    key: string
    displayName: string
    description?: string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    relationships?: RelationshipCreateNestedManyWithoutRoleTemplateInput
  }

  export type RoleTemplateUncheckedCreateInput = {
    id?: string
    type: $Enums.RelationshipRoleTemplateType
    key: string
    displayName: string
    description?: string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    relationships?: RelationshipUncheckedCreateNestedManyWithoutRoleTemplateInput
  }

  export type RoleTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationshipRoleTemplateTypeFieldUpdateOperationsInput | $Enums.RelationshipRoleTemplateType
    key?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationships?: RelationshipUpdateManyWithoutRoleTemplateNestedInput
  }

  export type RoleTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationshipRoleTemplateTypeFieldUpdateOperationsInput | $Enums.RelationshipRoleTemplateType
    key?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationships?: RelationshipUncheckedUpdateManyWithoutRoleTemplateNestedInput
  }

  export type RoleTemplateCreateManyInput = {
    id?: string
    type: $Enums.RelationshipRoleTemplateType
    key: string
    displayName: string
    description?: string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationshipRoleTemplateTypeFieldUpdateOperationsInput | $Enums.RelationshipRoleTemplateType
    key?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationshipRoleTemplateTypeFieldUpdateOperationsInput | $Enums.RelationshipRoleTemplateType
    key?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CulturalParameterCreateInput = {
    id?: string
    regionCode: string
    cultureKey: string
    settings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CulturalParameterUncheckedCreateInput = {
    id?: string
    regionCode: string
    cultureKey: string
    settings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CulturalParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    cultureKey?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CulturalParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    cultureKey?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CulturalParameterCreateManyInput = {
    id?: string
    regionCode: string
    cultureKey: string
    settings: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CulturalParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    cultureKey?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CulturalParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    cultureKey?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipCreateInput = {
    id?: string
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutRelationshipsInput
    counterpartUser?: UserCreateNestedOneWithoutCounterpartRelsInput
    roleTemplate?: RoleTemplateCreateNestedOneWithoutRelationshipsInput
    messages?: ConversationMessageCreateNestedManyWithoutRelationshipInput
    growthMetrics?: GrowthMetricCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateInput = {
    id?: string
    userId: string
    counterpartUserId?: string | null
    roleTemplateId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutRelationshipInput
    growthMetrics?: GrowthMetricUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutRelationshipsNestedInput
    counterpartUser?: UserUpdateOneWithoutCounterpartRelsNestedInput
    roleTemplate?: RoleTemplateUpdateOneWithoutRelationshipsNestedInput
    messages?: ConversationMessageUpdateManyWithoutRelationshipNestedInput
    growthMetrics?: GrowthMetricUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    counterpartUserId?: NullableStringFieldUpdateOperationsInput | string | null
    roleTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ConversationMessageUncheckedUpdateManyWithoutRelationshipNestedInput
    growthMetrics?: GrowthMetricUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipCreateManyInput = {
    id?: string
    userId: string
    counterpartUserId?: string | null
    roleTemplateId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type RelationshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RelationshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    counterpartUserId?: NullableStringFieldUpdateOperationsInput | string | null
    roleTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationMessageCreateInput = {
    id?: string
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutMessagesInput
    sender?: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type ConversationMessageUncheckedCreateInput = {
    id?: string
    relationshipId: string
    senderId?: string | null
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneWithoutSentMessagesNestedInput
  }

  export type ConversationMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageCreateManyInput = {
    id?: string
    relationshipId: string
    senderId?: string | null
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrowthMetricCreateInput = {
    id?: string
    bucketDate: Date | string
    messagesCount?: number
    positiveCount?: number
    neutralCount?: number
    negativeCount?: number
    metrics?: NullableJsonNullValueInput | InputJsonValue
    relationship: RelationshipCreateNestedOneWithoutGrowthMetricsInput
  }

  export type GrowthMetricUncheckedCreateInput = {
    id?: string
    relationshipId: string
    bucketDate: Date | string
    messagesCount?: number
    positiveCount?: number
    neutralCount?: number
    negativeCount?: number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GrowthMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesCount?: IntFieldUpdateOperationsInput | number
    positiveCount?: IntFieldUpdateOperationsInput | number
    neutralCount?: IntFieldUpdateOperationsInput | number
    negativeCount?: IntFieldUpdateOperationsInput | number
    metrics?: NullableJsonNullValueInput | InputJsonValue
    relationship?: RelationshipUpdateOneRequiredWithoutGrowthMetricsNestedInput
  }

  export type GrowthMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    bucketDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesCount?: IntFieldUpdateOperationsInput | number
    positiveCount?: IntFieldUpdateOperationsInput | number
    neutralCount?: IntFieldUpdateOperationsInput | number
    negativeCount?: IntFieldUpdateOperationsInput | number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GrowthMetricCreateManyInput = {
    id?: string
    relationshipId: string
    bucketDate: Date | string
    messagesCount?: number
    positiveCount?: number
    neutralCount?: number
    negativeCount?: number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GrowthMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesCount?: IntFieldUpdateOperationsInput | number
    positiveCount?: IntFieldUpdateOperationsInput | number
    neutralCount?: IntFieldUpdateOperationsInput | number
    negativeCount?: IntFieldUpdateOperationsInput | number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GrowthMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    bucketDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesCount?: IntFieldUpdateOperationsInput | number
    positiveCount?: IntFieldUpdateOperationsInput | number
    neutralCount?: IntFieldUpdateOperationsInput | number
    negativeCount?: IntFieldUpdateOperationsInput | number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VoiceProfileCreateInput = {
    id?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVoiceProfileInput
    samples?: VoiceSampleCreateNestedManyWithoutVoiceProfileInput
  }

  export type VoiceProfileUncheckedCreateInput = {
    id?: string
    userId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: VoiceSampleUncheckedCreateNestedManyWithoutVoiceProfileInput
  }

  export type VoiceProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVoiceProfileNestedInput
    samples?: VoiceSampleUpdateManyWithoutVoiceProfileNestedInput
  }

  export type VoiceProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: VoiceSampleUncheckedUpdateManyWithoutVoiceProfileNestedInput
  }

  export type VoiceProfileCreateManyInput = {
    id?: string
    userId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoiceProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSampleCreateInput = {
    id?: string
    url: string
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    voiceProfile: VoiceProfileCreateNestedOneWithoutSamplesInput
  }

  export type VoiceSampleUncheckedCreateInput = {
    id?: string
    voiceProfileId: string
    url: string
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VoiceSampleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voiceProfile?: VoiceProfileUpdateOneRequiredWithoutSamplesNestedInput
  }

  export type VoiceSampleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceProfileId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSampleCreateManyInput = {
    id?: string
    voiceProfileId: string
    url: string
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VoiceSampleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSampleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voiceProfileId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarProfileCreateInput = {
    id?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAvatarProfileInput
    assets?: AvatarAssetCreateNestedManyWithoutAvatarProfileInput
  }

  export type AvatarProfileUncheckedCreateInput = {
    id?: string
    userId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AvatarAssetUncheckedCreateNestedManyWithoutAvatarProfileInput
  }

  export type AvatarProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAvatarProfileNestedInput
    assets?: AvatarAssetUpdateManyWithoutAvatarProfileNestedInput
  }

  export type AvatarProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AvatarAssetUncheckedUpdateManyWithoutAvatarProfileNestedInput
  }

  export type AvatarProfileCreateManyInput = {
    id?: string
    userId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvatarProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarAssetCreateInput = {
    id?: string
    url: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    avatarProfile: AvatarProfileCreateNestedOneWithoutAssetsInput
  }

  export type AvatarAssetUncheckedCreateInput = {
    id?: string
    avatarProfileId: string
    url: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AvatarAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarProfile?: AvatarProfileUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AvatarAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarProfileId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarAssetCreateManyInput = {
    id?: string
    avatarProfileId: string
    url: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AvatarAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarProfileId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadCreateInput = {
    id?: string
    mediaType: $Enums.MediaType
    url: string
    originalName?: string | null
    sizeBytes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutUploadsInput
  }

  export type UploadUncheckedCreateInput = {
    id?: string
    userId?: string | null
    mediaType: $Enums.MediaType
    url: string
    originalName?: string | null
    sizeBytes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UploadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUploadsNestedInput
  }

  export type UploadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadCreateManyInput = {
    id?: string
    userId?: string | null
    mediaType: $Enums.MediaType
    url: string
    originalName?: string | null
    sizeBytes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UploadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageEventCreateInput = {
    id?: string
    type: $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutUsageEventsInput
  }

  export type UsageEventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    type: $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUsageEventTypeFieldUpdateOperationsInput | $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUsageEventsNestedInput
  }

  export type UsageEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUsageEventTypeFieldUpdateOperationsInput | $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageEventCreateManyInput = {
    id?: string
    userId?: string | null
    type: $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUsageEventTypeFieldUpdateOperationsInput | $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUsageEventTypeFieldUpdateOperationsInput | $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricCreateInput = {
    id?: string
    name: string
    labels?: NullableJsonNullValueInput | InputJsonValue
    value: number
    capturedAt?: Date | string
  }

  export type SystemMetricUncheckedCreateInput = {
    id?: string
    name: string
    labels?: NullableJsonNullValueInput | InputJsonValue
    value: number
    capturedAt?: Date | string
  }

  export type SystemMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labels?: NullableJsonNullValueInput | InputJsonValue
    value?: FloatFieldUpdateOperationsInput | number
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labels?: NullableJsonNullValueInput | InputJsonValue
    value?: FloatFieldUpdateOperationsInput | number
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricCreateManyInput = {
    id?: string
    name: string
    labels?: NullableJsonNullValueInput | InputJsonValue
    value: number
    capturedAt?: Date | string
  }

  export type SystemMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labels?: NullableJsonNullValueInput | InputJsonValue
    value?: FloatFieldUpdateOperationsInput | number
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    labels?: NullableJsonNullValueInput | InputJsonValue
    value?: FloatFieldUpdateOperationsInput | number
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorId?: string | null
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorId?: string | null
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupSnapshotCreateInput = {
    id?: string
    label?: string | null
    snapshotType: string
    locationUrl: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BackupSnapshotUncheckedCreateInput = {
    id?: string
    label?: string | null
    snapshotType: string
    locationUrl: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BackupSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: StringFieldUpdateOperationsInput | string
    locationUrl?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: StringFieldUpdateOperationsInput | string
    locationUrl?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupSnapshotCreateManyInput = {
    id?: string
    label?: string | null
    snapshotType: string
    locationUrl: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BackupSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: StringFieldUpdateOperationsInput | string
    locationUrl?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    snapshotType?: StringFieldUpdateOperationsInput | string
    locationUrl?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigVersionHistoryCreateInput = {
    id?: string
    fromVersion: number
    toVersion: number
    reason?: string | null
    changedById?: string | null
    changedAt?: Date | string
    config: EthicalConfigCreateNestedOneWithoutHistoryInput
  }

  export type ConfigVersionHistoryUncheckedCreateInput = {
    id?: string
    configId: string
    fromVersion: number
    toVersion: number
    reason?: string | null
    changedById?: string | null
    changedAt?: Date | string
  }

  export type ConfigVersionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: IntFieldUpdateOperationsInput | number
    toVersion?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: EthicalConfigUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ConfigVersionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    fromVersion?: IntFieldUpdateOperationsInput | number
    toVersion?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigVersionHistoryCreateManyInput = {
    id?: string
    configId: string
    fromVersion: number
    toVersion: number
    reason?: string | null
    changedById?: string | null
    changedAt?: Date | string
  }

  export type ConfigVersionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: IntFieldUpdateOperationsInput | number
    toVersion?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigVersionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    fromVersion?: IntFieldUpdateOperationsInput | number
    toVersion?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AdminUserNullableScalarRelationFilter = {
    is?: AdminUserWhereInput | null
    isNot?: AdminUserWhereInput | null
  }

  export type RelationshipListRelationFilter = {
    every?: RelationshipWhereInput
    some?: RelationshipWhereInput
    none?: RelationshipWhereInput
  }

  export type VoiceProfileNullableScalarRelationFilter = {
    is?: VoiceProfileWhereInput | null
    isNot?: VoiceProfileWhereInput | null
  }

  export type AvatarProfileNullableScalarRelationFilter = {
    is?: AvatarProfileWhereInput | null
    isNot?: AvatarProfileWhereInput | null
  }

  export type UploadListRelationFilter = {
    every?: UploadWhereInput
    some?: UploadWhereInput
    none?: UploadWhereInput
  }

  export type UsageEventListRelationFilter = {
    every?: UsageEventWhereInput
    some?: UsageEventWhereInput
    none?: UsageEventWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ConversationMessageListRelationFilter = {
    every?: ConversationMessageWhereInput
    some?: ConversationMessageWhereInput
    none?: ConversationMessageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UploadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
    externalId?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
    preferences?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
    externalId?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authProvider?: SortOrder
    externalId?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    locale?: SortOrder
    timezone?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdminUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EthicalConfigVersionListRelationFilter = {
    every?: EthicalConfigVersionWhereInput
    some?: EthicalConfigVersionWhereInput
    none?: EthicalConfigVersionWhereInput
  }

  export type ConfigVersionHistoryListRelationFilter = {
    every?: ConfigVersionHistoryWhereInput
    some?: ConfigVersionHistoryWhereInput
    none?: ConfigVersionHistoryWhereInput
  }

  export type EthicalConfigVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConfigVersionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EthicalConfigCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    latestVersion?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EthicalConfigAvgOrderByAggregateInput = {
    latestVersion?: SortOrder
  }

  export type EthicalConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    latestVersion?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EthicalConfigMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    latestVersion?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EthicalConfigSumOrderByAggregateInput = {
    latestVersion?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EthicalConfigScalarRelationFilter = {
    is?: EthicalConfigWhereInput
    isNot?: EthicalConfigWhereInput
  }

  export type EthicalConfigVersionConfigIdVersionCompoundUniqueInput = {
    configId: string
    version: number
  }

  export type EthicalConfigVersionCountOrderByAggregateInput = {
    id?: SortOrder
    configId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type EthicalConfigVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EthicalConfigVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    configId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type EthicalConfigVersionMinOrderByAggregateInput = {
    id?: SortOrder
    configId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
  }

  export type EthicalConfigVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumRelationshipRoleTemplateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipRoleTemplateType | EnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipRoleTemplateType[] | ListEnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipRoleTemplateType[] | ListEnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipRoleTemplateTypeFilter<$PrismaModel> | $Enums.RelationshipRoleTemplateType
  }

  export type RoleTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    defaultSettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRelationshipRoleTemplateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipRoleTemplateType | EnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipRoleTemplateType[] | ListEnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipRoleTemplateType[] | ListEnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipRoleTemplateTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipRoleTemplateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipRoleTemplateTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationshipRoleTemplateTypeFilter<$PrismaModel>
  }

  export type CulturalParameterRegionCodeCultureKeyCompoundUniqueInput = {
    regionCode: string
    cultureKey: string
  }

  export type CulturalParameterCountOrderByAggregateInput = {
    id?: SortOrder
    regionCode?: SortOrder
    cultureKey?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CulturalParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    regionCode?: SortOrder
    cultureKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CulturalParameterMinOrderByAggregateInput = {
    id?: SortOrder
    regionCode?: SortOrder
    cultureKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RoleTemplateNullableScalarRelationFilter = {
    is?: RoleTemplateWhereInput | null
    isNot?: RoleTemplateWhereInput | null
  }

  export type GrowthMetricListRelationFilter = {
    every?: GrowthMetricWhereInput
    some?: GrowthMetricWhereInput
    none?: GrowthMetricWhereInput
  }

  export type GrowthMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counterpartUserId?: SortOrder
    roleTemplateId?: SortOrder
    title?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type RelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counterpartUserId?: SortOrder
    roleTemplateId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type RelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counterpartUserId?: SortOrder
    roleTemplateId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type EnumEmotionalToneFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalTone | EnumEmotionalToneFieldRefInput<$PrismaModel>
    in?: $Enums.EmotionalTone[] | ListEnumEmotionalToneFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmotionalTone[] | ListEnumEmotionalToneFieldRefInput<$PrismaModel>
    not?: NestedEnumEmotionalToneFilter<$PrismaModel> | $Enums.EmotionalTone
  }

  export type RelationshipScalarRelationFilter = {
    is?: RelationshipWhereInput
    isNot?: RelationshipWhereInput
  }

  export type ConversationMessageCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    emotionalTone?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    emotionalTone?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMessageMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    emotionalTone?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumEmotionalToneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalTone | EnumEmotionalToneFieldRefInput<$PrismaModel>
    in?: $Enums.EmotionalTone[] | ListEnumEmotionalToneFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmotionalTone[] | ListEnumEmotionalToneFieldRefInput<$PrismaModel>
    not?: NestedEnumEmotionalToneWithAggregatesFilter<$PrismaModel> | $Enums.EmotionalTone
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmotionalToneFilter<$PrismaModel>
    _max?: NestedEnumEmotionalToneFilter<$PrismaModel>
  }

  export type GrowthMetricRelationshipIdBucketDateCompoundUniqueInput = {
    relationshipId: string
    bucketDate: Date | string
  }

  export type GrowthMetricCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    bucketDate?: SortOrder
    messagesCount?: SortOrder
    positiveCount?: SortOrder
    neutralCount?: SortOrder
    negativeCount?: SortOrder
    metrics?: SortOrder
  }

  export type GrowthMetricAvgOrderByAggregateInput = {
    messagesCount?: SortOrder
    positiveCount?: SortOrder
    neutralCount?: SortOrder
    negativeCount?: SortOrder
  }

  export type GrowthMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    bucketDate?: SortOrder
    messagesCount?: SortOrder
    positiveCount?: SortOrder
    neutralCount?: SortOrder
    negativeCount?: SortOrder
  }

  export type GrowthMetricMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    bucketDate?: SortOrder
    messagesCount?: SortOrder
    positiveCount?: SortOrder
    neutralCount?: SortOrder
    negativeCount?: SortOrder
  }

  export type GrowthMetricSumOrderByAggregateInput = {
    messagesCount?: SortOrder
    positiveCount?: SortOrder
    neutralCount?: SortOrder
    negativeCount?: SortOrder
  }

  export type VoiceSampleListRelationFilter = {
    every?: VoiceSampleWhereInput
    some?: VoiceSampleWhereInput
    none?: VoiceSampleWhereInput
  }

  export type VoiceSampleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoiceProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settings?: SortOrder
    sampleUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoiceProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sampleUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoiceProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sampleUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VoiceProfileScalarRelationFilter = {
    is?: VoiceProfileWhereInput
    isNot?: VoiceProfileWhereInput
  }

  export type VoiceSampleCountOrderByAggregateInput = {
    id?: SortOrder
    voiceProfileId?: SortOrder
    url?: SortOrder
    durationMs?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type VoiceSampleAvgOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type VoiceSampleMaxOrderByAggregateInput = {
    id?: SortOrder
    voiceProfileId?: SortOrder
    url?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type VoiceSampleMinOrderByAggregateInput = {
    id?: SortOrder
    voiceProfileId?: SortOrder
    url?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type VoiceSampleSumOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AvatarAssetListRelationFilter = {
    every?: AvatarAssetWhereInput
    some?: AvatarAssetWhereInput
    none?: AvatarAssetWhereInput
  }

  export type AvatarAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AvatarProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settings?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvatarProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvatarProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AvatarProfileScalarRelationFilter = {
    is?: AvatarProfileWhereInput
    isNot?: AvatarProfileWhereInput
  }

  export type AvatarAssetCountOrderByAggregateInput = {
    id?: SortOrder
    avatarProfileId?: SortOrder
    url?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AvatarAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    avatarProfileId?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type AvatarAssetMinOrderByAggregateInput = {
    id?: SortOrder
    avatarProfileId?: SortOrder
    url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type UploadCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    originalName?: SortOrder
    sizeBytes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UploadAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type UploadMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    originalName?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type UploadMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mediaType?: SortOrder
    url?: SortOrder
    originalName?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
  }

  export type UploadSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type EnumUsageEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageEventType | EnumUsageEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageEventType[] | ListEnumUsageEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageEventType[] | ListEnumUsageEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageEventTypeFilter<$PrismaModel> | $Enums.UsageEventType
  }

  export type UsageEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumUsageEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageEventType | EnumUsageEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageEventType[] | ListEnumUsageEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageEventType[] | ListEnumUsageEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.UsageEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsageEventTypeFilter<$PrismaModel>
    _max?: NestedEnumUsageEventTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SystemMetricCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    labels?: SortOrder
    value?: SortOrder
    capturedAt?: SortOrder
  }

  export type SystemMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SystemMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    capturedAt?: SortOrder
  }

  export type SystemMetricMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    capturedAt?: SortOrder
  }

  export type SystemMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type EnumAuditEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeFilter<$PrismaModel> | $Enums.AuditEntityType
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type EnumAuditEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
  }

  export type BackupSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    snapshotType?: SortOrder
    locationUrl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    snapshotType?: SortOrder
    locationUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type BackupSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    snapshotType?: SortOrder
    locationUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigVersionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    configId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    reason?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type ConfigVersionHistoryAvgOrderByAggregateInput = {
    fromVersion?: SortOrder
    toVersion?: SortOrder
  }

  export type ConfigVersionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    configId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    reason?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type ConfigVersionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    configId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    reason?: SortOrder
    changedById?: SortOrder
    changedAt?: SortOrder
  }

  export type ConfigVersionHistorySumOrderByAggregateInput = {
    fromVersion?: SortOrder
    toVersion?: SortOrder
  }

  export type AdminUserCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUserInput
    connect?: AdminUserWhereUniqueInput
  }

  export type RelationshipCreateNestedManyWithoutUserInput = {
    create?: XOR<RelationshipCreateWithoutUserInput, RelationshipUncheckedCreateWithoutUserInput> | RelationshipCreateWithoutUserInput[] | RelationshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUserInput | RelationshipCreateOrConnectWithoutUserInput[]
    createMany?: RelationshipCreateManyUserInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type RelationshipCreateNestedManyWithoutCounterpartUserInput = {
    create?: XOR<RelationshipCreateWithoutCounterpartUserInput, RelationshipUncheckedCreateWithoutCounterpartUserInput> | RelationshipCreateWithoutCounterpartUserInput[] | RelationshipUncheckedCreateWithoutCounterpartUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutCounterpartUserInput | RelationshipCreateOrConnectWithoutCounterpartUserInput[]
    createMany?: RelationshipCreateManyCounterpartUserInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type VoiceProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<VoiceProfileCreateWithoutUserInput, VoiceProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: VoiceProfileCreateOrConnectWithoutUserInput
    connect?: VoiceProfileWhereUniqueInput
  }

  export type AvatarProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<AvatarProfileCreateWithoutUserInput, AvatarProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutUserInput
    connect?: AvatarProfileWhereUniqueInput
  }

  export type UploadCreateNestedManyWithoutUserInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
  }

  export type UsageEventCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageEventCreateWithoutUserInput, UsageEventUncheckedCreateWithoutUserInput> | UsageEventCreateWithoutUserInput[] | UsageEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageEventCreateOrConnectWithoutUserInput | UsageEventCreateOrConnectWithoutUserInput[]
    createMany?: UsageEventCreateManyUserInputEnvelope
    connect?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ConversationMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ConversationMessageCreateWithoutSenderInput, ConversationMessageUncheckedCreateWithoutSenderInput> | ConversationMessageCreateWithoutSenderInput[] | ConversationMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutSenderInput | ConversationMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ConversationMessageCreateManySenderInputEnvelope
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
  }

  export type AdminUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUserInput
    connect?: AdminUserWhereUniqueInput
  }

  export type RelationshipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RelationshipCreateWithoutUserInput, RelationshipUncheckedCreateWithoutUserInput> | RelationshipCreateWithoutUserInput[] | RelationshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUserInput | RelationshipCreateOrConnectWithoutUserInput[]
    createMany?: RelationshipCreateManyUserInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput = {
    create?: XOR<RelationshipCreateWithoutCounterpartUserInput, RelationshipUncheckedCreateWithoutCounterpartUserInput> | RelationshipCreateWithoutCounterpartUserInput[] | RelationshipUncheckedCreateWithoutCounterpartUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutCounterpartUserInput | RelationshipCreateOrConnectWithoutCounterpartUserInput[]
    createMany?: RelationshipCreateManyCounterpartUserInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type VoiceProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<VoiceProfileCreateWithoutUserInput, VoiceProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: VoiceProfileCreateOrConnectWithoutUserInput
    connect?: VoiceProfileWhereUniqueInput
  }

  export type AvatarProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AvatarProfileCreateWithoutUserInput, AvatarProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutUserInput
    connect?: AvatarProfileWhereUniqueInput
  }

  export type UploadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
  }

  export type UsageEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageEventCreateWithoutUserInput, UsageEventUncheckedCreateWithoutUserInput> | UsageEventCreateWithoutUserInput[] | UsageEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageEventCreateOrConnectWithoutUserInput | UsageEventCreateOrConnectWithoutUserInput[]
    createMany?: UsageEventCreateManyUserInputEnvelope
    connect?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ConversationMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ConversationMessageCreateWithoutSenderInput, ConversationMessageUncheckedCreateWithoutSenderInput> | ConversationMessageCreateWithoutSenderInput[] | ConversationMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutSenderInput | ConversationMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ConversationMessageCreateManySenderInputEnvelope
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AdminUserUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUserInput
    upsert?: AdminUserUpsertWithoutUserInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutUserInput, AdminUserUpdateWithoutUserInput>, AdminUserUncheckedUpdateWithoutUserInput>
  }

  export type RelationshipUpdateManyWithoutUserNestedInput = {
    create?: XOR<RelationshipCreateWithoutUserInput, RelationshipUncheckedCreateWithoutUserInput> | RelationshipCreateWithoutUserInput[] | RelationshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUserInput | RelationshipCreateOrConnectWithoutUserInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutUserInput | RelationshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RelationshipCreateManyUserInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutUserInput | RelationshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutUserInput | RelationshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type RelationshipUpdateManyWithoutCounterpartUserNestedInput = {
    create?: XOR<RelationshipCreateWithoutCounterpartUserInput, RelationshipUncheckedCreateWithoutCounterpartUserInput> | RelationshipCreateWithoutCounterpartUserInput[] | RelationshipUncheckedCreateWithoutCounterpartUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutCounterpartUserInput | RelationshipCreateOrConnectWithoutCounterpartUserInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutCounterpartUserInput | RelationshipUpsertWithWhereUniqueWithoutCounterpartUserInput[]
    createMany?: RelationshipCreateManyCounterpartUserInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutCounterpartUserInput | RelationshipUpdateWithWhereUniqueWithoutCounterpartUserInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutCounterpartUserInput | RelationshipUpdateManyWithWhereWithoutCounterpartUserInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type VoiceProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<VoiceProfileCreateWithoutUserInput, VoiceProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: VoiceProfileCreateOrConnectWithoutUserInput
    upsert?: VoiceProfileUpsertWithoutUserInput
    disconnect?: VoiceProfileWhereInput | boolean
    delete?: VoiceProfileWhereInput | boolean
    connect?: VoiceProfileWhereUniqueInput
    update?: XOR<XOR<VoiceProfileUpdateToOneWithWhereWithoutUserInput, VoiceProfileUpdateWithoutUserInput>, VoiceProfileUncheckedUpdateWithoutUserInput>
  }

  export type AvatarProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<AvatarProfileCreateWithoutUserInput, AvatarProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutUserInput
    upsert?: AvatarProfileUpsertWithoutUserInput
    disconnect?: AvatarProfileWhereInput | boolean
    delete?: AvatarProfileWhereInput | boolean
    connect?: AvatarProfileWhereUniqueInput
    update?: XOR<XOR<AvatarProfileUpdateToOneWithWhereWithoutUserInput, AvatarProfileUpdateWithoutUserInput>, AvatarProfileUncheckedUpdateWithoutUserInput>
  }

  export type UploadUpdateManyWithoutUserNestedInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    upsert?: UploadUpsertWithWhereUniqueWithoutUserInput | UploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    set?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    disconnect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    delete?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    update?: UploadUpdateWithWhereUniqueWithoutUserInput | UploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UploadUpdateManyWithWhereWithoutUserInput | UploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UploadScalarWhereInput | UploadScalarWhereInput[]
  }

  export type UsageEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageEventCreateWithoutUserInput, UsageEventUncheckedCreateWithoutUserInput> | UsageEventCreateWithoutUserInput[] | UsageEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageEventCreateOrConnectWithoutUserInput | UsageEventCreateOrConnectWithoutUserInput[]
    upsert?: UsageEventUpsertWithWhereUniqueWithoutUserInput | UsageEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageEventCreateManyUserInputEnvelope
    set?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
    disconnect?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
    delete?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
    connect?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
    update?: UsageEventUpdateWithWhereUniqueWithoutUserInput | UsageEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageEventUpdateManyWithWhereWithoutUserInput | UsageEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageEventScalarWhereInput | UsageEventScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ConversationMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ConversationMessageCreateWithoutSenderInput, ConversationMessageUncheckedCreateWithoutSenderInput> | ConversationMessageCreateWithoutSenderInput[] | ConversationMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutSenderInput | ConversationMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ConversationMessageUpsertWithWhereUniqueWithoutSenderInput | ConversationMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ConversationMessageCreateManySenderInputEnvelope
    set?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    disconnect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    delete?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    update?: ConversationMessageUpdateWithWhereUniqueWithoutSenderInput | ConversationMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ConversationMessageUpdateManyWithWhereWithoutSenderInput | ConversationMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
  }

  export type AdminUserUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminUserCreateOrConnectWithoutUserInput
    upsert?: AdminUserUpsertWithoutUserInput
    disconnect?: AdminUserWhereInput | boolean
    delete?: AdminUserWhereInput | boolean
    connect?: AdminUserWhereUniqueInput
    update?: XOR<XOR<AdminUserUpdateToOneWithWhereWithoutUserInput, AdminUserUpdateWithoutUserInput>, AdminUserUncheckedUpdateWithoutUserInput>
  }

  export type RelationshipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RelationshipCreateWithoutUserInput, RelationshipUncheckedCreateWithoutUserInput> | RelationshipCreateWithoutUserInput[] | RelationshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutUserInput | RelationshipCreateOrConnectWithoutUserInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutUserInput | RelationshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RelationshipCreateManyUserInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutUserInput | RelationshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutUserInput | RelationshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput = {
    create?: XOR<RelationshipCreateWithoutCounterpartUserInput, RelationshipUncheckedCreateWithoutCounterpartUserInput> | RelationshipCreateWithoutCounterpartUserInput[] | RelationshipUncheckedCreateWithoutCounterpartUserInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutCounterpartUserInput | RelationshipCreateOrConnectWithoutCounterpartUserInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutCounterpartUserInput | RelationshipUpsertWithWhereUniqueWithoutCounterpartUserInput[]
    createMany?: RelationshipCreateManyCounterpartUserInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutCounterpartUserInput | RelationshipUpdateWithWhereUniqueWithoutCounterpartUserInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutCounterpartUserInput | RelationshipUpdateManyWithWhereWithoutCounterpartUserInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type VoiceProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<VoiceProfileCreateWithoutUserInput, VoiceProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: VoiceProfileCreateOrConnectWithoutUserInput
    upsert?: VoiceProfileUpsertWithoutUserInput
    disconnect?: VoiceProfileWhereInput | boolean
    delete?: VoiceProfileWhereInput | boolean
    connect?: VoiceProfileWhereUniqueInput
    update?: XOR<XOR<VoiceProfileUpdateToOneWithWhereWithoutUserInput, VoiceProfileUpdateWithoutUserInput>, VoiceProfileUncheckedUpdateWithoutUserInput>
  }

  export type AvatarProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AvatarProfileCreateWithoutUserInput, AvatarProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutUserInput
    upsert?: AvatarProfileUpsertWithoutUserInput
    disconnect?: AvatarProfileWhereInput | boolean
    delete?: AvatarProfileWhereInput | boolean
    connect?: AvatarProfileWhereUniqueInput
    update?: XOR<XOR<AvatarProfileUpdateToOneWithWhereWithoutUserInput, AvatarProfileUpdateWithoutUserInput>, AvatarProfileUncheckedUpdateWithoutUserInput>
  }

  export type UploadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput> | UploadCreateWithoutUserInput[] | UploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UploadCreateOrConnectWithoutUserInput | UploadCreateOrConnectWithoutUserInput[]
    upsert?: UploadUpsertWithWhereUniqueWithoutUserInput | UploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UploadCreateManyUserInputEnvelope
    set?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    disconnect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    delete?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    connect?: UploadWhereUniqueInput | UploadWhereUniqueInput[]
    update?: UploadUpdateWithWhereUniqueWithoutUserInput | UploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UploadUpdateManyWithWhereWithoutUserInput | UploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UploadScalarWhereInput | UploadScalarWhereInput[]
  }

  export type UsageEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageEventCreateWithoutUserInput, UsageEventUncheckedCreateWithoutUserInput> | UsageEventCreateWithoutUserInput[] | UsageEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageEventCreateOrConnectWithoutUserInput | UsageEventCreateOrConnectWithoutUserInput[]
    upsert?: UsageEventUpsertWithWhereUniqueWithoutUserInput | UsageEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageEventCreateManyUserInputEnvelope
    set?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
    disconnect?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
    delete?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
    connect?: UsageEventWhereUniqueInput | UsageEventWhereUniqueInput[]
    update?: UsageEventUpdateWithWhereUniqueWithoutUserInput | UsageEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageEventUpdateManyWithWhereWithoutUserInput | UsageEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageEventScalarWhereInput | UsageEventScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ConversationMessageCreateWithoutSenderInput, ConversationMessageUncheckedCreateWithoutSenderInput> | ConversationMessageCreateWithoutSenderInput[] | ConversationMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutSenderInput | ConversationMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ConversationMessageUpsertWithWhereUniqueWithoutSenderInput | ConversationMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ConversationMessageCreateManySenderInputEnvelope
    set?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    disconnect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    delete?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    update?: ConversationMessageUpdateWithWhereUniqueWithoutSenderInput | ConversationMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ConversationMessageUpdateManyWithWhereWithoutSenderInput | ConversationMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminProfileInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAdminRoleFieldUpdateOperationsInput = {
    set?: $Enums.AdminRole
  }

  export type UserUpdateOneRequiredWithoutAdminProfileNestedInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    upsert?: UserUpsertWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminProfileInput, UserUpdateWithoutAdminProfileInput>, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type EthicalConfigVersionCreateNestedManyWithoutConfigInput = {
    create?: XOR<EthicalConfigVersionCreateWithoutConfigInput, EthicalConfigVersionUncheckedCreateWithoutConfigInput> | EthicalConfigVersionCreateWithoutConfigInput[] | EthicalConfigVersionUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: EthicalConfigVersionCreateOrConnectWithoutConfigInput | EthicalConfigVersionCreateOrConnectWithoutConfigInput[]
    createMany?: EthicalConfigVersionCreateManyConfigInputEnvelope
    connect?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
  }

  export type ConfigVersionHistoryCreateNestedManyWithoutConfigInput = {
    create?: XOR<ConfigVersionHistoryCreateWithoutConfigInput, ConfigVersionHistoryUncheckedCreateWithoutConfigInput> | ConfigVersionHistoryCreateWithoutConfigInput[] | ConfigVersionHistoryUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigVersionHistoryCreateOrConnectWithoutConfigInput | ConfigVersionHistoryCreateOrConnectWithoutConfigInput[]
    createMany?: ConfigVersionHistoryCreateManyConfigInputEnvelope
    connect?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
  }

  export type EthicalConfigVersionUncheckedCreateNestedManyWithoutConfigInput = {
    create?: XOR<EthicalConfigVersionCreateWithoutConfigInput, EthicalConfigVersionUncheckedCreateWithoutConfigInput> | EthicalConfigVersionCreateWithoutConfigInput[] | EthicalConfigVersionUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: EthicalConfigVersionCreateOrConnectWithoutConfigInput | EthicalConfigVersionCreateOrConnectWithoutConfigInput[]
    createMany?: EthicalConfigVersionCreateManyConfigInputEnvelope
    connect?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
  }

  export type ConfigVersionHistoryUncheckedCreateNestedManyWithoutConfigInput = {
    create?: XOR<ConfigVersionHistoryCreateWithoutConfigInput, ConfigVersionHistoryUncheckedCreateWithoutConfigInput> | ConfigVersionHistoryCreateWithoutConfigInput[] | ConfigVersionHistoryUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigVersionHistoryCreateOrConnectWithoutConfigInput | ConfigVersionHistoryCreateOrConnectWithoutConfigInput[]
    createMany?: ConfigVersionHistoryCreateManyConfigInputEnvelope
    connect?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EthicalConfigVersionUpdateManyWithoutConfigNestedInput = {
    create?: XOR<EthicalConfigVersionCreateWithoutConfigInput, EthicalConfigVersionUncheckedCreateWithoutConfigInput> | EthicalConfigVersionCreateWithoutConfigInput[] | EthicalConfigVersionUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: EthicalConfigVersionCreateOrConnectWithoutConfigInput | EthicalConfigVersionCreateOrConnectWithoutConfigInput[]
    upsert?: EthicalConfigVersionUpsertWithWhereUniqueWithoutConfigInput | EthicalConfigVersionUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: EthicalConfigVersionCreateManyConfigInputEnvelope
    set?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
    disconnect?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
    delete?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
    connect?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
    update?: EthicalConfigVersionUpdateWithWhereUniqueWithoutConfigInput | EthicalConfigVersionUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: EthicalConfigVersionUpdateManyWithWhereWithoutConfigInput | EthicalConfigVersionUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: EthicalConfigVersionScalarWhereInput | EthicalConfigVersionScalarWhereInput[]
  }

  export type ConfigVersionHistoryUpdateManyWithoutConfigNestedInput = {
    create?: XOR<ConfigVersionHistoryCreateWithoutConfigInput, ConfigVersionHistoryUncheckedCreateWithoutConfigInput> | ConfigVersionHistoryCreateWithoutConfigInput[] | ConfigVersionHistoryUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigVersionHistoryCreateOrConnectWithoutConfigInput | ConfigVersionHistoryCreateOrConnectWithoutConfigInput[]
    upsert?: ConfigVersionHistoryUpsertWithWhereUniqueWithoutConfigInput | ConfigVersionHistoryUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: ConfigVersionHistoryCreateManyConfigInputEnvelope
    set?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
    disconnect?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
    delete?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
    connect?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
    update?: ConfigVersionHistoryUpdateWithWhereUniqueWithoutConfigInput | ConfigVersionHistoryUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: ConfigVersionHistoryUpdateManyWithWhereWithoutConfigInput | ConfigVersionHistoryUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: ConfigVersionHistoryScalarWhereInput | ConfigVersionHistoryScalarWhereInput[]
  }

  export type EthicalConfigVersionUncheckedUpdateManyWithoutConfigNestedInput = {
    create?: XOR<EthicalConfigVersionCreateWithoutConfigInput, EthicalConfigVersionUncheckedCreateWithoutConfigInput> | EthicalConfigVersionCreateWithoutConfigInput[] | EthicalConfigVersionUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: EthicalConfigVersionCreateOrConnectWithoutConfigInput | EthicalConfigVersionCreateOrConnectWithoutConfigInput[]
    upsert?: EthicalConfigVersionUpsertWithWhereUniqueWithoutConfigInput | EthicalConfigVersionUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: EthicalConfigVersionCreateManyConfigInputEnvelope
    set?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
    disconnect?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
    delete?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
    connect?: EthicalConfigVersionWhereUniqueInput | EthicalConfigVersionWhereUniqueInput[]
    update?: EthicalConfigVersionUpdateWithWhereUniqueWithoutConfigInput | EthicalConfigVersionUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: EthicalConfigVersionUpdateManyWithWhereWithoutConfigInput | EthicalConfigVersionUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: EthicalConfigVersionScalarWhereInput | EthicalConfigVersionScalarWhereInput[]
  }

  export type ConfigVersionHistoryUncheckedUpdateManyWithoutConfigNestedInput = {
    create?: XOR<ConfigVersionHistoryCreateWithoutConfigInput, ConfigVersionHistoryUncheckedCreateWithoutConfigInput> | ConfigVersionHistoryCreateWithoutConfigInput[] | ConfigVersionHistoryUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: ConfigVersionHistoryCreateOrConnectWithoutConfigInput | ConfigVersionHistoryCreateOrConnectWithoutConfigInput[]
    upsert?: ConfigVersionHistoryUpsertWithWhereUniqueWithoutConfigInput | ConfigVersionHistoryUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: ConfigVersionHistoryCreateManyConfigInputEnvelope
    set?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
    disconnect?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
    delete?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
    connect?: ConfigVersionHistoryWhereUniqueInput | ConfigVersionHistoryWhereUniqueInput[]
    update?: ConfigVersionHistoryUpdateWithWhereUniqueWithoutConfigInput | ConfigVersionHistoryUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: ConfigVersionHistoryUpdateManyWithWhereWithoutConfigInput | ConfigVersionHistoryUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: ConfigVersionHistoryScalarWhereInput | ConfigVersionHistoryScalarWhereInput[]
  }

  export type EthicalConfigCreateNestedOneWithoutVersionsInput = {
    create?: XOR<EthicalConfigCreateWithoutVersionsInput, EthicalConfigUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: EthicalConfigCreateOrConnectWithoutVersionsInput
    connect?: EthicalConfigWhereUniqueInput
  }

  export type EthicalConfigUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<EthicalConfigCreateWithoutVersionsInput, EthicalConfigUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: EthicalConfigCreateOrConnectWithoutVersionsInput
    upsert?: EthicalConfigUpsertWithoutVersionsInput
    connect?: EthicalConfigWhereUniqueInput
    update?: XOR<XOR<EthicalConfigUpdateToOneWithWhereWithoutVersionsInput, EthicalConfigUpdateWithoutVersionsInput>, EthicalConfigUncheckedUpdateWithoutVersionsInput>
  }

  export type RelationshipCreateNestedManyWithoutRoleTemplateInput = {
    create?: XOR<RelationshipCreateWithoutRoleTemplateInput, RelationshipUncheckedCreateWithoutRoleTemplateInput> | RelationshipCreateWithoutRoleTemplateInput[] | RelationshipUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutRoleTemplateInput | RelationshipCreateOrConnectWithoutRoleTemplateInput[]
    createMany?: RelationshipCreateManyRoleTemplateInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type RelationshipUncheckedCreateNestedManyWithoutRoleTemplateInput = {
    create?: XOR<RelationshipCreateWithoutRoleTemplateInput, RelationshipUncheckedCreateWithoutRoleTemplateInput> | RelationshipCreateWithoutRoleTemplateInput[] | RelationshipUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutRoleTemplateInput | RelationshipCreateOrConnectWithoutRoleTemplateInput[]
    createMany?: RelationshipCreateManyRoleTemplateInputEnvelope
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
  }

  export type EnumRelationshipRoleTemplateTypeFieldUpdateOperationsInput = {
    set?: $Enums.RelationshipRoleTemplateType
  }

  export type RelationshipUpdateManyWithoutRoleTemplateNestedInput = {
    create?: XOR<RelationshipCreateWithoutRoleTemplateInput, RelationshipUncheckedCreateWithoutRoleTemplateInput> | RelationshipCreateWithoutRoleTemplateInput[] | RelationshipUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutRoleTemplateInput | RelationshipCreateOrConnectWithoutRoleTemplateInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutRoleTemplateInput | RelationshipUpsertWithWhereUniqueWithoutRoleTemplateInput[]
    createMany?: RelationshipCreateManyRoleTemplateInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutRoleTemplateInput | RelationshipUpdateWithWhereUniqueWithoutRoleTemplateInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutRoleTemplateInput | RelationshipUpdateManyWithWhereWithoutRoleTemplateInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type RelationshipUncheckedUpdateManyWithoutRoleTemplateNestedInput = {
    create?: XOR<RelationshipCreateWithoutRoleTemplateInput, RelationshipUncheckedCreateWithoutRoleTemplateInput> | RelationshipCreateWithoutRoleTemplateInput[] | RelationshipUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RelationshipCreateOrConnectWithoutRoleTemplateInput | RelationshipCreateOrConnectWithoutRoleTemplateInput[]
    upsert?: RelationshipUpsertWithWhereUniqueWithoutRoleTemplateInput | RelationshipUpsertWithWhereUniqueWithoutRoleTemplateInput[]
    createMany?: RelationshipCreateManyRoleTemplateInputEnvelope
    set?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    disconnect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    delete?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    connect?: RelationshipWhereUniqueInput | RelationshipWhereUniqueInput[]
    update?: RelationshipUpdateWithWhereUniqueWithoutRoleTemplateInput | RelationshipUpdateWithWhereUniqueWithoutRoleTemplateInput[]
    updateMany?: RelationshipUpdateManyWithWhereWithoutRoleTemplateInput | RelationshipUpdateManyWithWhereWithoutRoleTemplateInput[]
    deleteMany?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRelationshipsInput = {
    create?: XOR<UserCreateWithoutRelationshipsInput, UserUncheckedCreateWithoutRelationshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRelationshipsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCounterpartRelsInput = {
    create?: XOR<UserCreateWithoutCounterpartRelsInput, UserUncheckedCreateWithoutCounterpartRelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCounterpartRelsInput
    connect?: UserWhereUniqueInput
  }

  export type RoleTemplateCreateNestedOneWithoutRelationshipsInput = {
    create?: XOR<RoleTemplateCreateWithoutRelationshipsInput, RoleTemplateUncheckedCreateWithoutRelationshipsInput>
    connectOrCreate?: RoleTemplateCreateOrConnectWithoutRelationshipsInput
    connect?: RoleTemplateWhereUniqueInput
  }

  export type ConversationMessageCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<ConversationMessageCreateWithoutRelationshipInput, ConversationMessageUncheckedCreateWithoutRelationshipInput> | ConversationMessageCreateWithoutRelationshipInput[] | ConversationMessageUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutRelationshipInput | ConversationMessageCreateOrConnectWithoutRelationshipInput[]
    createMany?: ConversationMessageCreateManyRelationshipInputEnvelope
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
  }

  export type GrowthMetricCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<GrowthMetricCreateWithoutRelationshipInput, GrowthMetricUncheckedCreateWithoutRelationshipInput> | GrowthMetricCreateWithoutRelationshipInput[] | GrowthMetricUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: GrowthMetricCreateOrConnectWithoutRelationshipInput | GrowthMetricCreateOrConnectWithoutRelationshipInput[]
    createMany?: GrowthMetricCreateManyRelationshipInputEnvelope
    connect?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
  }

  export type ConversationMessageUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<ConversationMessageCreateWithoutRelationshipInput, ConversationMessageUncheckedCreateWithoutRelationshipInput> | ConversationMessageCreateWithoutRelationshipInput[] | ConversationMessageUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutRelationshipInput | ConversationMessageCreateOrConnectWithoutRelationshipInput[]
    createMany?: ConversationMessageCreateManyRelationshipInputEnvelope
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
  }

  export type GrowthMetricUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<GrowthMetricCreateWithoutRelationshipInput, GrowthMetricUncheckedCreateWithoutRelationshipInput> | GrowthMetricCreateWithoutRelationshipInput[] | GrowthMetricUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: GrowthMetricCreateOrConnectWithoutRelationshipInput | GrowthMetricCreateOrConnectWithoutRelationshipInput[]
    createMany?: GrowthMetricCreateManyRelationshipInputEnvelope
    connect?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutRelationshipsNestedInput = {
    create?: XOR<UserCreateWithoutRelationshipsInput, UserUncheckedCreateWithoutRelationshipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRelationshipsInput
    upsert?: UserUpsertWithoutRelationshipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRelationshipsInput, UserUpdateWithoutRelationshipsInput>, UserUncheckedUpdateWithoutRelationshipsInput>
  }

  export type UserUpdateOneWithoutCounterpartRelsNestedInput = {
    create?: XOR<UserCreateWithoutCounterpartRelsInput, UserUncheckedCreateWithoutCounterpartRelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCounterpartRelsInput
    upsert?: UserUpsertWithoutCounterpartRelsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCounterpartRelsInput, UserUpdateWithoutCounterpartRelsInput>, UserUncheckedUpdateWithoutCounterpartRelsInput>
  }

  export type RoleTemplateUpdateOneWithoutRelationshipsNestedInput = {
    create?: XOR<RoleTemplateCreateWithoutRelationshipsInput, RoleTemplateUncheckedCreateWithoutRelationshipsInput>
    connectOrCreate?: RoleTemplateCreateOrConnectWithoutRelationshipsInput
    upsert?: RoleTemplateUpsertWithoutRelationshipsInput
    disconnect?: RoleTemplateWhereInput | boolean
    delete?: RoleTemplateWhereInput | boolean
    connect?: RoleTemplateWhereUniqueInput
    update?: XOR<XOR<RoleTemplateUpdateToOneWithWhereWithoutRelationshipsInput, RoleTemplateUpdateWithoutRelationshipsInput>, RoleTemplateUncheckedUpdateWithoutRelationshipsInput>
  }

  export type ConversationMessageUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<ConversationMessageCreateWithoutRelationshipInput, ConversationMessageUncheckedCreateWithoutRelationshipInput> | ConversationMessageCreateWithoutRelationshipInput[] | ConversationMessageUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutRelationshipInput | ConversationMessageCreateOrConnectWithoutRelationshipInput[]
    upsert?: ConversationMessageUpsertWithWhereUniqueWithoutRelationshipInput | ConversationMessageUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: ConversationMessageCreateManyRelationshipInputEnvelope
    set?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    disconnect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    delete?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    update?: ConversationMessageUpdateWithWhereUniqueWithoutRelationshipInput | ConversationMessageUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: ConversationMessageUpdateManyWithWhereWithoutRelationshipInput | ConversationMessageUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
  }

  export type GrowthMetricUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<GrowthMetricCreateWithoutRelationshipInput, GrowthMetricUncheckedCreateWithoutRelationshipInput> | GrowthMetricCreateWithoutRelationshipInput[] | GrowthMetricUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: GrowthMetricCreateOrConnectWithoutRelationshipInput | GrowthMetricCreateOrConnectWithoutRelationshipInput[]
    upsert?: GrowthMetricUpsertWithWhereUniqueWithoutRelationshipInput | GrowthMetricUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: GrowthMetricCreateManyRelationshipInputEnvelope
    set?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
    disconnect?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
    delete?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
    connect?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
    update?: GrowthMetricUpdateWithWhereUniqueWithoutRelationshipInput | GrowthMetricUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: GrowthMetricUpdateManyWithWhereWithoutRelationshipInput | GrowthMetricUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: GrowthMetricScalarWhereInput | GrowthMetricScalarWhereInput[]
  }

  export type ConversationMessageUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<ConversationMessageCreateWithoutRelationshipInput, ConversationMessageUncheckedCreateWithoutRelationshipInput> | ConversationMessageCreateWithoutRelationshipInput[] | ConversationMessageUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutRelationshipInput | ConversationMessageCreateOrConnectWithoutRelationshipInput[]
    upsert?: ConversationMessageUpsertWithWhereUniqueWithoutRelationshipInput | ConversationMessageUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: ConversationMessageCreateManyRelationshipInputEnvelope
    set?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    disconnect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    delete?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    update?: ConversationMessageUpdateWithWhereUniqueWithoutRelationshipInput | ConversationMessageUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: ConversationMessageUpdateManyWithWhereWithoutRelationshipInput | ConversationMessageUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
  }

  export type GrowthMetricUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<GrowthMetricCreateWithoutRelationshipInput, GrowthMetricUncheckedCreateWithoutRelationshipInput> | GrowthMetricCreateWithoutRelationshipInput[] | GrowthMetricUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: GrowthMetricCreateOrConnectWithoutRelationshipInput | GrowthMetricCreateOrConnectWithoutRelationshipInput[]
    upsert?: GrowthMetricUpsertWithWhereUniqueWithoutRelationshipInput | GrowthMetricUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: GrowthMetricCreateManyRelationshipInputEnvelope
    set?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
    disconnect?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
    delete?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
    connect?: GrowthMetricWhereUniqueInput | GrowthMetricWhereUniqueInput[]
    update?: GrowthMetricUpdateWithWhereUniqueWithoutRelationshipInput | GrowthMetricUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: GrowthMetricUpdateManyWithWhereWithoutRelationshipInput | GrowthMetricUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: GrowthMetricScalarWhereInput | GrowthMetricScalarWhereInput[]
  }

  export type RelationshipCreateNestedOneWithoutMessagesInput = {
    create?: XOR<RelationshipCreateWithoutMessagesInput, RelationshipUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutMessagesInput
    connect?: RelationshipWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEmotionalToneFieldUpdateOperationsInput = {
    set?: $Enums.EmotionalTone
  }

  export type RelationshipUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<RelationshipCreateWithoutMessagesInput, RelationshipUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutMessagesInput
    upsert?: RelationshipUpsertWithoutMessagesInput
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutMessagesInput, RelationshipUpdateWithoutMessagesInput>, RelationshipUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type RelationshipCreateNestedOneWithoutGrowthMetricsInput = {
    create?: XOR<RelationshipCreateWithoutGrowthMetricsInput, RelationshipUncheckedCreateWithoutGrowthMetricsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutGrowthMetricsInput
    connect?: RelationshipWhereUniqueInput
  }

  export type RelationshipUpdateOneRequiredWithoutGrowthMetricsNestedInput = {
    create?: XOR<RelationshipCreateWithoutGrowthMetricsInput, RelationshipUncheckedCreateWithoutGrowthMetricsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutGrowthMetricsInput
    upsert?: RelationshipUpsertWithoutGrowthMetricsInput
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutGrowthMetricsInput, RelationshipUpdateWithoutGrowthMetricsInput>, RelationshipUncheckedUpdateWithoutGrowthMetricsInput>
  }

  export type UserCreateNestedOneWithoutVoiceProfileInput = {
    create?: XOR<UserCreateWithoutVoiceProfileInput, UserUncheckedCreateWithoutVoiceProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoiceProfileInput
    connect?: UserWhereUniqueInput
  }

  export type VoiceSampleCreateNestedManyWithoutVoiceProfileInput = {
    create?: XOR<VoiceSampleCreateWithoutVoiceProfileInput, VoiceSampleUncheckedCreateWithoutVoiceProfileInput> | VoiceSampleCreateWithoutVoiceProfileInput[] | VoiceSampleUncheckedCreateWithoutVoiceProfileInput[]
    connectOrCreate?: VoiceSampleCreateOrConnectWithoutVoiceProfileInput | VoiceSampleCreateOrConnectWithoutVoiceProfileInput[]
    createMany?: VoiceSampleCreateManyVoiceProfileInputEnvelope
    connect?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
  }

  export type VoiceSampleUncheckedCreateNestedManyWithoutVoiceProfileInput = {
    create?: XOR<VoiceSampleCreateWithoutVoiceProfileInput, VoiceSampleUncheckedCreateWithoutVoiceProfileInput> | VoiceSampleCreateWithoutVoiceProfileInput[] | VoiceSampleUncheckedCreateWithoutVoiceProfileInput[]
    connectOrCreate?: VoiceSampleCreateOrConnectWithoutVoiceProfileInput | VoiceSampleCreateOrConnectWithoutVoiceProfileInput[]
    createMany?: VoiceSampleCreateManyVoiceProfileInputEnvelope
    connect?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutVoiceProfileNestedInput = {
    create?: XOR<UserCreateWithoutVoiceProfileInput, UserUncheckedCreateWithoutVoiceProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoiceProfileInput
    upsert?: UserUpsertWithoutVoiceProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoiceProfileInput, UserUpdateWithoutVoiceProfileInput>, UserUncheckedUpdateWithoutVoiceProfileInput>
  }

  export type VoiceSampleUpdateManyWithoutVoiceProfileNestedInput = {
    create?: XOR<VoiceSampleCreateWithoutVoiceProfileInput, VoiceSampleUncheckedCreateWithoutVoiceProfileInput> | VoiceSampleCreateWithoutVoiceProfileInput[] | VoiceSampleUncheckedCreateWithoutVoiceProfileInput[]
    connectOrCreate?: VoiceSampleCreateOrConnectWithoutVoiceProfileInput | VoiceSampleCreateOrConnectWithoutVoiceProfileInput[]
    upsert?: VoiceSampleUpsertWithWhereUniqueWithoutVoiceProfileInput | VoiceSampleUpsertWithWhereUniqueWithoutVoiceProfileInput[]
    createMany?: VoiceSampleCreateManyVoiceProfileInputEnvelope
    set?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
    disconnect?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
    delete?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
    connect?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
    update?: VoiceSampleUpdateWithWhereUniqueWithoutVoiceProfileInput | VoiceSampleUpdateWithWhereUniqueWithoutVoiceProfileInput[]
    updateMany?: VoiceSampleUpdateManyWithWhereWithoutVoiceProfileInput | VoiceSampleUpdateManyWithWhereWithoutVoiceProfileInput[]
    deleteMany?: VoiceSampleScalarWhereInput | VoiceSampleScalarWhereInput[]
  }

  export type VoiceSampleUncheckedUpdateManyWithoutVoiceProfileNestedInput = {
    create?: XOR<VoiceSampleCreateWithoutVoiceProfileInput, VoiceSampleUncheckedCreateWithoutVoiceProfileInput> | VoiceSampleCreateWithoutVoiceProfileInput[] | VoiceSampleUncheckedCreateWithoutVoiceProfileInput[]
    connectOrCreate?: VoiceSampleCreateOrConnectWithoutVoiceProfileInput | VoiceSampleCreateOrConnectWithoutVoiceProfileInput[]
    upsert?: VoiceSampleUpsertWithWhereUniqueWithoutVoiceProfileInput | VoiceSampleUpsertWithWhereUniqueWithoutVoiceProfileInput[]
    createMany?: VoiceSampleCreateManyVoiceProfileInputEnvelope
    set?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
    disconnect?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
    delete?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
    connect?: VoiceSampleWhereUniqueInput | VoiceSampleWhereUniqueInput[]
    update?: VoiceSampleUpdateWithWhereUniqueWithoutVoiceProfileInput | VoiceSampleUpdateWithWhereUniqueWithoutVoiceProfileInput[]
    updateMany?: VoiceSampleUpdateManyWithWhereWithoutVoiceProfileInput | VoiceSampleUpdateManyWithWhereWithoutVoiceProfileInput[]
    deleteMany?: VoiceSampleScalarWhereInput | VoiceSampleScalarWhereInput[]
  }

  export type VoiceProfileCreateNestedOneWithoutSamplesInput = {
    create?: XOR<VoiceProfileCreateWithoutSamplesInput, VoiceProfileUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: VoiceProfileCreateOrConnectWithoutSamplesInput
    connect?: VoiceProfileWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VoiceProfileUpdateOneRequiredWithoutSamplesNestedInput = {
    create?: XOR<VoiceProfileCreateWithoutSamplesInput, VoiceProfileUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: VoiceProfileCreateOrConnectWithoutSamplesInput
    upsert?: VoiceProfileUpsertWithoutSamplesInput
    connect?: VoiceProfileWhereUniqueInput
    update?: XOR<XOR<VoiceProfileUpdateToOneWithWhereWithoutSamplesInput, VoiceProfileUpdateWithoutSamplesInput>, VoiceProfileUncheckedUpdateWithoutSamplesInput>
  }

  export type UserCreateNestedOneWithoutAvatarProfileInput = {
    create?: XOR<UserCreateWithoutAvatarProfileInput, UserUncheckedCreateWithoutAvatarProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvatarProfileInput
    connect?: UserWhereUniqueInput
  }

  export type AvatarAssetCreateNestedManyWithoutAvatarProfileInput = {
    create?: XOR<AvatarAssetCreateWithoutAvatarProfileInput, AvatarAssetUncheckedCreateWithoutAvatarProfileInput> | AvatarAssetCreateWithoutAvatarProfileInput[] | AvatarAssetUncheckedCreateWithoutAvatarProfileInput[]
    connectOrCreate?: AvatarAssetCreateOrConnectWithoutAvatarProfileInput | AvatarAssetCreateOrConnectWithoutAvatarProfileInput[]
    createMany?: AvatarAssetCreateManyAvatarProfileInputEnvelope
    connect?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
  }

  export type AvatarAssetUncheckedCreateNestedManyWithoutAvatarProfileInput = {
    create?: XOR<AvatarAssetCreateWithoutAvatarProfileInput, AvatarAssetUncheckedCreateWithoutAvatarProfileInput> | AvatarAssetCreateWithoutAvatarProfileInput[] | AvatarAssetUncheckedCreateWithoutAvatarProfileInput[]
    connectOrCreate?: AvatarAssetCreateOrConnectWithoutAvatarProfileInput | AvatarAssetCreateOrConnectWithoutAvatarProfileInput[]
    createMany?: AvatarAssetCreateManyAvatarProfileInputEnvelope
    connect?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAvatarProfileNestedInput = {
    create?: XOR<UserCreateWithoutAvatarProfileInput, UserUncheckedCreateWithoutAvatarProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAvatarProfileInput
    upsert?: UserUpsertWithoutAvatarProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAvatarProfileInput, UserUpdateWithoutAvatarProfileInput>, UserUncheckedUpdateWithoutAvatarProfileInput>
  }

  export type AvatarAssetUpdateManyWithoutAvatarProfileNestedInput = {
    create?: XOR<AvatarAssetCreateWithoutAvatarProfileInput, AvatarAssetUncheckedCreateWithoutAvatarProfileInput> | AvatarAssetCreateWithoutAvatarProfileInput[] | AvatarAssetUncheckedCreateWithoutAvatarProfileInput[]
    connectOrCreate?: AvatarAssetCreateOrConnectWithoutAvatarProfileInput | AvatarAssetCreateOrConnectWithoutAvatarProfileInput[]
    upsert?: AvatarAssetUpsertWithWhereUniqueWithoutAvatarProfileInput | AvatarAssetUpsertWithWhereUniqueWithoutAvatarProfileInput[]
    createMany?: AvatarAssetCreateManyAvatarProfileInputEnvelope
    set?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
    disconnect?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
    delete?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
    connect?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
    update?: AvatarAssetUpdateWithWhereUniqueWithoutAvatarProfileInput | AvatarAssetUpdateWithWhereUniqueWithoutAvatarProfileInput[]
    updateMany?: AvatarAssetUpdateManyWithWhereWithoutAvatarProfileInput | AvatarAssetUpdateManyWithWhereWithoutAvatarProfileInput[]
    deleteMany?: AvatarAssetScalarWhereInput | AvatarAssetScalarWhereInput[]
  }

  export type AvatarAssetUncheckedUpdateManyWithoutAvatarProfileNestedInput = {
    create?: XOR<AvatarAssetCreateWithoutAvatarProfileInput, AvatarAssetUncheckedCreateWithoutAvatarProfileInput> | AvatarAssetCreateWithoutAvatarProfileInput[] | AvatarAssetUncheckedCreateWithoutAvatarProfileInput[]
    connectOrCreate?: AvatarAssetCreateOrConnectWithoutAvatarProfileInput | AvatarAssetCreateOrConnectWithoutAvatarProfileInput[]
    upsert?: AvatarAssetUpsertWithWhereUniqueWithoutAvatarProfileInput | AvatarAssetUpsertWithWhereUniqueWithoutAvatarProfileInput[]
    createMany?: AvatarAssetCreateManyAvatarProfileInputEnvelope
    set?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
    disconnect?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
    delete?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
    connect?: AvatarAssetWhereUniqueInput | AvatarAssetWhereUniqueInput[]
    update?: AvatarAssetUpdateWithWhereUniqueWithoutAvatarProfileInput | AvatarAssetUpdateWithWhereUniqueWithoutAvatarProfileInput[]
    updateMany?: AvatarAssetUpdateManyWithWhereWithoutAvatarProfileInput | AvatarAssetUpdateManyWithWhereWithoutAvatarProfileInput[]
    deleteMany?: AvatarAssetScalarWhereInput | AvatarAssetScalarWhereInput[]
  }

  export type AvatarProfileCreateNestedOneWithoutAssetsInput = {
    create?: XOR<AvatarProfileCreateWithoutAssetsInput, AvatarProfileUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutAssetsInput
    connect?: AvatarProfileWhereUniqueInput
  }

  export type AvatarProfileUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<AvatarProfileCreateWithoutAssetsInput, AvatarProfileUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: AvatarProfileCreateOrConnectWithoutAssetsInput
    upsert?: AvatarProfileUpsertWithoutAssetsInput
    connect?: AvatarProfileWhereUniqueInput
    update?: XOR<XOR<AvatarProfileUpdateToOneWithWhereWithoutAssetsInput, AvatarProfileUpdateWithoutAssetsInput>, AvatarProfileUncheckedUpdateWithoutAssetsInput>
  }

  export type UserCreateNestedOneWithoutUploadsInput = {
    create?: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type UserUpdateOneWithoutUploadsNestedInput = {
    create?: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadsInput
    upsert?: UserUpsertWithoutUploadsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadsInput, UserUpdateWithoutUploadsInput>, UserUncheckedUpdateWithoutUploadsInput>
  }

  export type UserCreateNestedOneWithoutUsageEventsInput = {
    create?: XOR<UserCreateWithoutUsageEventsInput, UserUncheckedCreateWithoutUsageEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageEventsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUsageEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.UsageEventType
  }

  export type UserUpdateOneWithoutUsageEventsNestedInput = {
    create?: XOR<UserCreateWithoutUsageEventsInput, UserUncheckedCreateWithoutUsageEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageEventsInput
    upsert?: UserUpsertWithoutUsageEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageEventsInput, UserUpdateWithoutUsageEventsInput>, UserUncheckedUpdateWithoutUsageEventsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type EnumAuditEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuditEntityType
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type EthicalConfigCreateNestedOneWithoutHistoryInput = {
    create?: XOR<EthicalConfigCreateWithoutHistoryInput, EthicalConfigUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: EthicalConfigCreateOrConnectWithoutHistoryInput
    connect?: EthicalConfigWhereUniqueInput
  }

  export type EthicalConfigUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<EthicalConfigCreateWithoutHistoryInput, EthicalConfigUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: EthicalConfigCreateOrConnectWithoutHistoryInput
    upsert?: EthicalConfigUpsertWithoutHistoryInput
    connect?: EthicalConfigWhereUniqueInput
    update?: XOR<XOR<EthicalConfigUpdateToOneWithWhereWithoutHistoryInput, EthicalConfigUpdateWithoutHistoryInput>, EthicalConfigUncheckedUpdateWithoutHistoryInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRelationshipRoleTemplateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipRoleTemplateType | EnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipRoleTemplateType[] | ListEnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipRoleTemplateType[] | ListEnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipRoleTemplateTypeFilter<$PrismaModel> | $Enums.RelationshipRoleTemplateType
  }

  export type NestedEnumRelationshipRoleTemplateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipRoleTemplateType | EnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipRoleTemplateType[] | ListEnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipRoleTemplateType[] | ListEnumRelationshipRoleTemplateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipRoleTemplateTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipRoleTemplateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipRoleTemplateTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationshipRoleTemplateTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmotionalToneFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalTone | EnumEmotionalToneFieldRefInput<$PrismaModel>
    in?: $Enums.EmotionalTone[] | ListEnumEmotionalToneFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmotionalTone[] | ListEnumEmotionalToneFieldRefInput<$PrismaModel>
    not?: NestedEnumEmotionalToneFilter<$PrismaModel> | $Enums.EmotionalTone
  }

  export type NestedEnumEmotionalToneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalTone | EnumEmotionalToneFieldRefInput<$PrismaModel>
    in?: $Enums.EmotionalTone[] | ListEnumEmotionalToneFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmotionalTone[] | ListEnumEmotionalToneFieldRefInput<$PrismaModel>
    not?: NestedEnumEmotionalToneWithAggregatesFilter<$PrismaModel> | $Enums.EmotionalTone
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmotionalToneFilter<$PrismaModel>
    _max?: NestedEnumEmotionalToneFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumUsageEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageEventType | EnumUsageEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageEventType[] | ListEnumUsageEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageEventType[] | ListEnumUsageEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageEventTypeFilter<$PrismaModel> | $Enums.UsageEventType
  }

  export type NestedEnumUsageEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UsageEventType | EnumUsageEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UsageEventType[] | ListEnumUsageEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UsageEventType[] | ListEnumUsageEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUsageEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.UsageEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUsageEventTypeFilter<$PrismaModel>
    _max?: NestedEnumUsageEventTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeFilter<$PrismaModel> | $Enums.AuditEntityType
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedEnumAuditEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
  }

  export type AdminUserCreateWithoutUserInput = {
    id?: string
    role: $Enums.AdminRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserUncheckedCreateWithoutUserInput = {
    id?: string
    role: $Enums.AdminRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserCreateOrConnectWithoutUserInput = {
    where: AdminUserWhereUniqueInput
    create: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
  }

  export type RelationshipCreateWithoutUserInput = {
    id?: string
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    counterpartUser?: UserCreateNestedOneWithoutCounterpartRelsInput
    roleTemplate?: RoleTemplateCreateNestedOneWithoutRelationshipsInput
    messages?: ConversationMessageCreateNestedManyWithoutRelationshipInput
    growthMetrics?: GrowthMetricCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutUserInput = {
    id?: string
    counterpartUserId?: string | null
    roleTemplateId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutRelationshipInput
    growthMetrics?: GrowthMetricUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutUserInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutUserInput, RelationshipUncheckedCreateWithoutUserInput>
  }

  export type RelationshipCreateManyUserInputEnvelope = {
    data: RelationshipCreateManyUserInput | RelationshipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipCreateWithoutCounterpartUserInput = {
    id?: string
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutRelationshipsInput
    roleTemplate?: RoleTemplateCreateNestedOneWithoutRelationshipsInput
    messages?: ConversationMessageCreateNestedManyWithoutRelationshipInput
    growthMetrics?: GrowthMetricCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutCounterpartUserInput = {
    id?: string
    userId: string
    roleTemplateId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutRelationshipInput
    growthMetrics?: GrowthMetricUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutCounterpartUserInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutCounterpartUserInput, RelationshipUncheckedCreateWithoutCounterpartUserInput>
  }

  export type RelationshipCreateManyCounterpartUserInputEnvelope = {
    data: RelationshipCreateManyCounterpartUserInput | RelationshipCreateManyCounterpartUserInput[]
    skipDuplicates?: boolean
  }

  export type VoiceProfileCreateWithoutUserInput = {
    id?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: VoiceSampleCreateNestedManyWithoutVoiceProfileInput
  }

  export type VoiceProfileUncheckedCreateWithoutUserInput = {
    id?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: VoiceSampleUncheckedCreateNestedManyWithoutVoiceProfileInput
  }

  export type VoiceProfileCreateOrConnectWithoutUserInput = {
    where: VoiceProfileWhereUniqueInput
    create: XOR<VoiceProfileCreateWithoutUserInput, VoiceProfileUncheckedCreateWithoutUserInput>
  }

  export type AvatarProfileCreateWithoutUserInput = {
    id?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AvatarAssetCreateNestedManyWithoutAvatarProfileInput
  }

  export type AvatarProfileUncheckedCreateWithoutUserInput = {
    id?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: AvatarAssetUncheckedCreateNestedManyWithoutAvatarProfileInput
  }

  export type AvatarProfileCreateOrConnectWithoutUserInput = {
    where: AvatarProfileWhereUniqueInput
    create: XOR<AvatarProfileCreateWithoutUserInput, AvatarProfileUncheckedCreateWithoutUserInput>
  }

  export type UploadCreateWithoutUserInput = {
    id?: string
    mediaType: $Enums.MediaType
    url: string
    originalName?: string | null
    sizeBytes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UploadUncheckedCreateWithoutUserInput = {
    id?: string
    mediaType: $Enums.MediaType
    url: string
    originalName?: string | null
    sizeBytes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UploadCreateOrConnectWithoutUserInput = {
    where: UploadWhereUniqueInput
    create: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput>
  }

  export type UploadCreateManyUserInputEnvelope = {
    data: UploadCreateManyUserInput | UploadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageEventCreateWithoutUserInput = {
    id?: string
    type: $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageEventUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageEventCreateOrConnectWithoutUserInput = {
    where: UsageEventWhereUniqueInput
    create: XOR<UsageEventCreateWithoutUserInput, UsageEventUncheckedCreateWithoutUserInput>
  }

  export type UsageEventCreateManyUserInputEnvelope = {
    data: UsageEventCreateManyUserInput | UsageEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutActorInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type ConversationMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutMessagesInput
  }

  export type ConversationMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    relationshipId: string
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageCreateOrConnectWithoutSenderInput = {
    where: ConversationMessageWhereUniqueInput
    create: XOR<ConversationMessageCreateWithoutSenderInput, ConversationMessageUncheckedCreateWithoutSenderInput>
  }

  export type ConversationMessageCreateManySenderInputEnvelope = {
    data: ConversationMessageCreateManySenderInput | ConversationMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type AdminUserUpsertWithoutUserInput = {
    update: XOR<AdminUserUpdateWithoutUserInput, AdminUserUncheckedUpdateWithoutUserInput>
    create: XOR<AdminUserCreateWithoutUserInput, AdminUserUncheckedCreateWithoutUserInput>
    where?: AdminUserWhereInput
  }

  export type AdminUserUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminUserWhereInput
    data: XOR<AdminUserUpdateWithoutUserInput, AdminUserUncheckedUpdateWithoutUserInput>
  }

  export type AdminUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipUpsertWithWhereUniqueWithoutUserInput = {
    where: RelationshipWhereUniqueInput
    update: XOR<RelationshipUpdateWithoutUserInput, RelationshipUncheckedUpdateWithoutUserInput>
    create: XOR<RelationshipCreateWithoutUserInput, RelationshipUncheckedCreateWithoutUserInput>
  }

  export type RelationshipUpdateWithWhereUniqueWithoutUserInput = {
    where: RelationshipWhereUniqueInput
    data: XOR<RelationshipUpdateWithoutUserInput, RelationshipUncheckedUpdateWithoutUserInput>
  }

  export type RelationshipUpdateManyWithWhereWithoutUserInput = {
    where: RelationshipScalarWhereInput
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyWithoutUserInput>
  }

  export type RelationshipScalarWhereInput = {
    AND?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
    OR?: RelationshipScalarWhereInput[]
    NOT?: RelationshipScalarWhereInput | RelationshipScalarWhereInput[]
    id?: StringFilter<"Relationship"> | string
    userId?: StringFilter<"Relationship"> | string
    counterpartUserId?: StringNullableFilter<"Relationship"> | string | null
    roleTemplateId?: StringNullableFilter<"Relationship"> | string | null
    title?: StringNullableFilter<"Relationship"> | string | null
    metadata?: JsonNullableFilter<"Relationship">
    createdAt?: DateTimeFilter<"Relationship"> | Date | string
    updatedAt?: DateTimeFilter<"Relationship"> | Date | string
    isActive?: BoolFilter<"Relationship"> | boolean
  }

  export type RelationshipUpsertWithWhereUniqueWithoutCounterpartUserInput = {
    where: RelationshipWhereUniqueInput
    update: XOR<RelationshipUpdateWithoutCounterpartUserInput, RelationshipUncheckedUpdateWithoutCounterpartUserInput>
    create: XOR<RelationshipCreateWithoutCounterpartUserInput, RelationshipUncheckedCreateWithoutCounterpartUserInput>
  }

  export type RelationshipUpdateWithWhereUniqueWithoutCounterpartUserInput = {
    where: RelationshipWhereUniqueInput
    data: XOR<RelationshipUpdateWithoutCounterpartUserInput, RelationshipUncheckedUpdateWithoutCounterpartUserInput>
  }

  export type RelationshipUpdateManyWithWhereWithoutCounterpartUserInput = {
    where: RelationshipScalarWhereInput
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyWithoutCounterpartUserInput>
  }

  export type VoiceProfileUpsertWithoutUserInput = {
    update: XOR<VoiceProfileUpdateWithoutUserInput, VoiceProfileUncheckedUpdateWithoutUserInput>
    create: XOR<VoiceProfileCreateWithoutUserInput, VoiceProfileUncheckedCreateWithoutUserInput>
    where?: VoiceProfileWhereInput
  }

  export type VoiceProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: VoiceProfileWhereInput
    data: XOR<VoiceProfileUpdateWithoutUserInput, VoiceProfileUncheckedUpdateWithoutUserInput>
  }

  export type VoiceProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: VoiceSampleUpdateManyWithoutVoiceProfileNestedInput
  }

  export type VoiceProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: VoiceSampleUncheckedUpdateManyWithoutVoiceProfileNestedInput
  }

  export type AvatarProfileUpsertWithoutUserInput = {
    update: XOR<AvatarProfileUpdateWithoutUserInput, AvatarProfileUncheckedUpdateWithoutUserInput>
    create: XOR<AvatarProfileCreateWithoutUserInput, AvatarProfileUncheckedCreateWithoutUserInput>
    where?: AvatarProfileWhereInput
  }

  export type AvatarProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: AvatarProfileWhereInput
    data: XOR<AvatarProfileUpdateWithoutUserInput, AvatarProfileUncheckedUpdateWithoutUserInput>
  }

  export type AvatarProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AvatarAssetUpdateManyWithoutAvatarProfileNestedInput
  }

  export type AvatarProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AvatarAssetUncheckedUpdateManyWithoutAvatarProfileNestedInput
  }

  export type UploadUpsertWithWhereUniqueWithoutUserInput = {
    where: UploadWhereUniqueInput
    update: XOR<UploadUpdateWithoutUserInput, UploadUncheckedUpdateWithoutUserInput>
    create: XOR<UploadCreateWithoutUserInput, UploadUncheckedCreateWithoutUserInput>
  }

  export type UploadUpdateWithWhereUniqueWithoutUserInput = {
    where: UploadWhereUniqueInput
    data: XOR<UploadUpdateWithoutUserInput, UploadUncheckedUpdateWithoutUserInput>
  }

  export type UploadUpdateManyWithWhereWithoutUserInput = {
    where: UploadScalarWhereInput
    data: XOR<UploadUpdateManyMutationInput, UploadUncheckedUpdateManyWithoutUserInput>
  }

  export type UploadScalarWhereInput = {
    AND?: UploadScalarWhereInput | UploadScalarWhereInput[]
    OR?: UploadScalarWhereInput[]
    NOT?: UploadScalarWhereInput | UploadScalarWhereInput[]
    id?: StringFilter<"Upload"> | string
    userId?: StringNullableFilter<"Upload"> | string | null
    mediaType?: EnumMediaTypeFilter<"Upload"> | $Enums.MediaType
    url?: StringFilter<"Upload"> | string
    originalName?: StringNullableFilter<"Upload"> | string | null
    sizeBytes?: IntNullableFilter<"Upload"> | number | null
    metadata?: JsonNullableFilter<"Upload">
    createdAt?: DateTimeFilter<"Upload"> | Date | string
  }

  export type UsageEventUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageEventWhereUniqueInput
    update: XOR<UsageEventUpdateWithoutUserInput, UsageEventUncheckedUpdateWithoutUserInput>
    create: XOR<UsageEventCreateWithoutUserInput, UsageEventUncheckedCreateWithoutUserInput>
  }

  export type UsageEventUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageEventWhereUniqueInput
    data: XOR<UsageEventUpdateWithoutUserInput, UsageEventUncheckedUpdateWithoutUserInput>
  }

  export type UsageEventUpdateManyWithWhereWithoutUserInput = {
    where: UsageEventScalarWhereInput
    data: XOR<UsageEventUpdateManyMutationInput, UsageEventUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageEventScalarWhereInput = {
    AND?: UsageEventScalarWhereInput | UsageEventScalarWhereInput[]
    OR?: UsageEventScalarWhereInput[]
    NOT?: UsageEventScalarWhereInput | UsageEventScalarWhereInput[]
    id?: StringFilter<"UsageEvent"> | string
    userId?: StringNullableFilter<"UsageEvent"> | string | null
    type?: EnumUsageEventTypeFilter<"UsageEvent"> | $Enums.UsageEventType
    metadata?: JsonNullableFilter<"UsageEvent">
    createdAt?: DateTimeFilter<"UsageEvent"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ConversationMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ConversationMessageWhereUniqueInput
    update: XOR<ConversationMessageUpdateWithoutSenderInput, ConversationMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ConversationMessageCreateWithoutSenderInput, ConversationMessageUncheckedCreateWithoutSenderInput>
  }

  export type ConversationMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ConversationMessageWhereUniqueInput
    data: XOR<ConversationMessageUpdateWithoutSenderInput, ConversationMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ConversationMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ConversationMessageScalarWhereInput
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ConversationMessageScalarWhereInput = {
    AND?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
    OR?: ConversationMessageScalarWhereInput[]
    NOT?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
    id?: StringFilter<"ConversationMessage"> | string
    relationshipId?: StringFilter<"ConversationMessage"> | string
    senderId?: StringNullableFilter<"ConversationMessage"> | string | null
    content?: StringFilter<"ConversationMessage"> | string
    emotionalTone?: EnumEmotionalToneFilter<"ConversationMessage"> | $Enums.EmotionalTone
    metadata?: JsonNullableFilter<"ConversationMessage">
    createdAt?: DateTimeFilter<"ConversationMessage"> | Date | string
  }

  export type UserCreateWithoutAdminProfileInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    relationships?: RelationshipCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileCreateNestedOneWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAdminProfileInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    relationships?: RelationshipUncheckedCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileUncheckedCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileUncheckedCreateNestedOneWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAdminProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
  }

  export type UserUpsertWithoutAdminProfileInput = {
    update: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type UserUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    relationships?: RelationshipUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUpdateOneWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    relationships?: RelationshipUncheckedUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUncheckedUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUncheckedUpdateOneWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type EthicalConfigVersionCreateWithoutConfigInput = {
    id?: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
  }

  export type EthicalConfigVersionUncheckedCreateWithoutConfigInput = {
    id?: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
  }

  export type EthicalConfigVersionCreateOrConnectWithoutConfigInput = {
    where: EthicalConfigVersionWhereUniqueInput
    create: XOR<EthicalConfigVersionCreateWithoutConfigInput, EthicalConfigVersionUncheckedCreateWithoutConfigInput>
  }

  export type EthicalConfigVersionCreateManyConfigInputEnvelope = {
    data: EthicalConfigVersionCreateManyConfigInput | EthicalConfigVersionCreateManyConfigInput[]
    skipDuplicates?: boolean
  }

  export type ConfigVersionHistoryCreateWithoutConfigInput = {
    id?: string
    fromVersion: number
    toVersion: number
    reason?: string | null
    changedById?: string | null
    changedAt?: Date | string
  }

  export type ConfigVersionHistoryUncheckedCreateWithoutConfigInput = {
    id?: string
    fromVersion: number
    toVersion: number
    reason?: string | null
    changedById?: string | null
    changedAt?: Date | string
  }

  export type ConfigVersionHistoryCreateOrConnectWithoutConfigInput = {
    where: ConfigVersionHistoryWhereUniqueInput
    create: XOR<ConfigVersionHistoryCreateWithoutConfigInput, ConfigVersionHistoryUncheckedCreateWithoutConfigInput>
  }

  export type ConfigVersionHistoryCreateManyConfigInputEnvelope = {
    data: ConfigVersionHistoryCreateManyConfigInput | ConfigVersionHistoryCreateManyConfigInput[]
    skipDuplicates?: boolean
  }

  export type EthicalConfigVersionUpsertWithWhereUniqueWithoutConfigInput = {
    where: EthicalConfigVersionWhereUniqueInput
    update: XOR<EthicalConfigVersionUpdateWithoutConfigInput, EthicalConfigVersionUncheckedUpdateWithoutConfigInput>
    create: XOR<EthicalConfigVersionCreateWithoutConfigInput, EthicalConfigVersionUncheckedCreateWithoutConfigInput>
  }

  export type EthicalConfigVersionUpdateWithWhereUniqueWithoutConfigInput = {
    where: EthicalConfigVersionWhereUniqueInput
    data: XOR<EthicalConfigVersionUpdateWithoutConfigInput, EthicalConfigVersionUncheckedUpdateWithoutConfigInput>
  }

  export type EthicalConfigVersionUpdateManyWithWhereWithoutConfigInput = {
    where: EthicalConfigVersionScalarWhereInput
    data: XOR<EthicalConfigVersionUpdateManyMutationInput, EthicalConfigVersionUncheckedUpdateManyWithoutConfigInput>
  }

  export type EthicalConfigVersionScalarWhereInput = {
    AND?: EthicalConfigVersionScalarWhereInput | EthicalConfigVersionScalarWhereInput[]
    OR?: EthicalConfigVersionScalarWhereInput[]
    NOT?: EthicalConfigVersionScalarWhereInput | EthicalConfigVersionScalarWhereInput[]
    id?: StringFilter<"EthicalConfigVersion"> | string
    configId?: StringFilter<"EthicalConfigVersion"> | string
    version?: IntFilter<"EthicalConfigVersion"> | number
    data?: JsonFilter<"EthicalConfigVersion">
    createdAt?: DateTimeFilter<"EthicalConfigVersion"> | Date | string
    createdById?: StringNullableFilter<"EthicalConfigVersion"> | string | null
  }

  export type ConfigVersionHistoryUpsertWithWhereUniqueWithoutConfigInput = {
    where: ConfigVersionHistoryWhereUniqueInput
    update: XOR<ConfigVersionHistoryUpdateWithoutConfigInput, ConfigVersionHistoryUncheckedUpdateWithoutConfigInput>
    create: XOR<ConfigVersionHistoryCreateWithoutConfigInput, ConfigVersionHistoryUncheckedCreateWithoutConfigInput>
  }

  export type ConfigVersionHistoryUpdateWithWhereUniqueWithoutConfigInput = {
    where: ConfigVersionHistoryWhereUniqueInput
    data: XOR<ConfigVersionHistoryUpdateWithoutConfigInput, ConfigVersionHistoryUncheckedUpdateWithoutConfigInput>
  }

  export type ConfigVersionHistoryUpdateManyWithWhereWithoutConfigInput = {
    where: ConfigVersionHistoryScalarWhereInput
    data: XOR<ConfigVersionHistoryUpdateManyMutationInput, ConfigVersionHistoryUncheckedUpdateManyWithoutConfigInput>
  }

  export type ConfigVersionHistoryScalarWhereInput = {
    AND?: ConfigVersionHistoryScalarWhereInput | ConfigVersionHistoryScalarWhereInput[]
    OR?: ConfigVersionHistoryScalarWhereInput[]
    NOT?: ConfigVersionHistoryScalarWhereInput | ConfigVersionHistoryScalarWhereInput[]
    id?: StringFilter<"ConfigVersionHistory"> | string
    configId?: StringFilter<"ConfigVersionHistory"> | string
    fromVersion?: IntFilter<"ConfigVersionHistory"> | number
    toVersion?: IntFilter<"ConfigVersionHistory"> | number
    reason?: StringNullableFilter<"ConfigVersionHistory"> | string | null
    changedById?: StringNullableFilter<"ConfigVersionHistory"> | string | null
    changedAt?: DateTimeFilter<"ConfigVersionHistory"> | Date | string
  }

  export type EthicalConfigCreateWithoutVersionsInput = {
    id?: string
    name: string
    description?: string | null
    latestVersion?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: ConfigVersionHistoryCreateNestedManyWithoutConfigInput
  }

  export type EthicalConfigUncheckedCreateWithoutVersionsInput = {
    id?: string
    name: string
    description?: string | null
    latestVersion?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: ConfigVersionHistoryUncheckedCreateNestedManyWithoutConfigInput
  }

  export type EthicalConfigCreateOrConnectWithoutVersionsInput = {
    where: EthicalConfigWhereUniqueInput
    create: XOR<EthicalConfigCreateWithoutVersionsInput, EthicalConfigUncheckedCreateWithoutVersionsInput>
  }

  export type EthicalConfigUpsertWithoutVersionsInput = {
    update: XOR<EthicalConfigUpdateWithoutVersionsInput, EthicalConfigUncheckedUpdateWithoutVersionsInput>
    create: XOR<EthicalConfigCreateWithoutVersionsInput, EthicalConfigUncheckedCreateWithoutVersionsInput>
    where?: EthicalConfigWhereInput
  }

  export type EthicalConfigUpdateToOneWithWhereWithoutVersionsInput = {
    where?: EthicalConfigWhereInput
    data: XOR<EthicalConfigUpdateWithoutVersionsInput, EthicalConfigUncheckedUpdateWithoutVersionsInput>
  }

  export type EthicalConfigUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersion?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: ConfigVersionHistoryUpdateManyWithoutConfigNestedInput
  }

  export type EthicalConfigUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersion?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: ConfigVersionHistoryUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type RelationshipCreateWithoutRoleTemplateInput = {
    id?: string
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutRelationshipsInput
    counterpartUser?: UserCreateNestedOneWithoutCounterpartRelsInput
    messages?: ConversationMessageCreateNestedManyWithoutRelationshipInput
    growthMetrics?: GrowthMetricCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutRoleTemplateInput = {
    id?: string
    userId: string
    counterpartUserId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutRelationshipInput
    growthMetrics?: GrowthMetricUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutRoleTemplateInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutRoleTemplateInput, RelationshipUncheckedCreateWithoutRoleTemplateInput>
  }

  export type RelationshipCreateManyRoleTemplateInputEnvelope = {
    data: RelationshipCreateManyRoleTemplateInput | RelationshipCreateManyRoleTemplateInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipUpsertWithWhereUniqueWithoutRoleTemplateInput = {
    where: RelationshipWhereUniqueInput
    update: XOR<RelationshipUpdateWithoutRoleTemplateInput, RelationshipUncheckedUpdateWithoutRoleTemplateInput>
    create: XOR<RelationshipCreateWithoutRoleTemplateInput, RelationshipUncheckedCreateWithoutRoleTemplateInput>
  }

  export type RelationshipUpdateWithWhereUniqueWithoutRoleTemplateInput = {
    where: RelationshipWhereUniqueInput
    data: XOR<RelationshipUpdateWithoutRoleTemplateInput, RelationshipUncheckedUpdateWithoutRoleTemplateInput>
  }

  export type RelationshipUpdateManyWithWhereWithoutRoleTemplateInput = {
    where: RelationshipScalarWhereInput
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyWithoutRoleTemplateInput>
  }

  export type UserCreateWithoutRelationshipsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    counterpartRels?: RelationshipCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileCreateNestedOneWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutRelationshipsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    counterpartRels?: RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileUncheckedCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileUncheckedCreateNestedOneWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutRelationshipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRelationshipsInput, UserUncheckedCreateWithoutRelationshipsInput>
  }

  export type UserCreateWithoutCounterpartRelsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    relationships?: RelationshipCreateNestedManyWithoutUserInput
    voiceProfile?: VoiceProfileCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileCreateNestedOneWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutCounterpartRelsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    relationships?: RelationshipUncheckedCreateNestedManyWithoutUserInput
    voiceProfile?: VoiceProfileUncheckedCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileUncheckedCreateNestedOneWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutCounterpartRelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCounterpartRelsInput, UserUncheckedCreateWithoutCounterpartRelsInput>
  }

  export type RoleTemplateCreateWithoutRelationshipsInput = {
    id?: string
    type: $Enums.RelationshipRoleTemplateType
    key: string
    displayName: string
    description?: string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateUncheckedCreateWithoutRelationshipsInput = {
    id?: string
    type: $Enums.RelationshipRoleTemplateType
    key: string
    displayName: string
    description?: string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateCreateOrConnectWithoutRelationshipsInput = {
    where: RoleTemplateWhereUniqueInput
    create: XOR<RoleTemplateCreateWithoutRelationshipsInput, RoleTemplateUncheckedCreateWithoutRelationshipsInput>
  }

  export type ConversationMessageCreateWithoutRelationshipInput = {
    id?: string
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender?: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type ConversationMessageUncheckedCreateWithoutRelationshipInput = {
    id?: string
    senderId?: string | null
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageCreateOrConnectWithoutRelationshipInput = {
    where: ConversationMessageWhereUniqueInput
    create: XOR<ConversationMessageCreateWithoutRelationshipInput, ConversationMessageUncheckedCreateWithoutRelationshipInput>
  }

  export type ConversationMessageCreateManyRelationshipInputEnvelope = {
    data: ConversationMessageCreateManyRelationshipInput | ConversationMessageCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type GrowthMetricCreateWithoutRelationshipInput = {
    id?: string
    bucketDate: Date | string
    messagesCount?: number
    positiveCount?: number
    neutralCount?: number
    negativeCount?: number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GrowthMetricUncheckedCreateWithoutRelationshipInput = {
    id?: string
    bucketDate: Date | string
    messagesCount?: number
    positiveCount?: number
    neutralCount?: number
    negativeCount?: number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GrowthMetricCreateOrConnectWithoutRelationshipInput = {
    where: GrowthMetricWhereUniqueInput
    create: XOR<GrowthMetricCreateWithoutRelationshipInput, GrowthMetricUncheckedCreateWithoutRelationshipInput>
  }

  export type GrowthMetricCreateManyRelationshipInputEnvelope = {
    data: GrowthMetricCreateManyRelationshipInput | GrowthMetricCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRelationshipsInput = {
    update: XOR<UserUpdateWithoutRelationshipsInput, UserUncheckedUpdateWithoutRelationshipsInput>
    create: XOR<UserCreateWithoutRelationshipsInput, UserUncheckedCreateWithoutRelationshipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRelationshipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRelationshipsInput, UserUncheckedUpdateWithoutRelationshipsInput>
  }

  export type UserUpdateWithoutRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    counterpartRels?: RelationshipUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUpdateOneWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    counterpartRels?: RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUncheckedUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUncheckedUpdateOneWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutCounterpartRelsInput = {
    update: XOR<UserUpdateWithoutCounterpartRelsInput, UserUncheckedUpdateWithoutCounterpartRelsInput>
    create: XOR<UserCreateWithoutCounterpartRelsInput, UserUncheckedCreateWithoutCounterpartRelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCounterpartRelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCounterpartRelsInput, UserUncheckedUpdateWithoutCounterpartRelsInput>
  }

  export type UserUpdateWithoutCounterpartRelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUpdateManyWithoutUserNestedInput
    voiceProfile?: VoiceProfileUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUpdateOneWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutCounterpartRelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUncheckedUpdateManyWithoutUserNestedInput
    voiceProfile?: VoiceProfileUncheckedUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUncheckedUpdateOneWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RoleTemplateUpsertWithoutRelationshipsInput = {
    update: XOR<RoleTemplateUpdateWithoutRelationshipsInput, RoleTemplateUncheckedUpdateWithoutRelationshipsInput>
    create: XOR<RoleTemplateCreateWithoutRelationshipsInput, RoleTemplateUncheckedCreateWithoutRelationshipsInput>
    where?: RoleTemplateWhereInput
  }

  export type RoleTemplateUpdateToOneWithWhereWithoutRelationshipsInput = {
    where?: RoleTemplateWhereInput
    data: XOR<RoleTemplateUpdateWithoutRelationshipsInput, RoleTemplateUncheckedUpdateWithoutRelationshipsInput>
  }

  export type RoleTemplateUpdateWithoutRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationshipRoleTemplateTypeFieldUpdateOperationsInput | $Enums.RelationshipRoleTemplateType
    key?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateUncheckedUpdateWithoutRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRelationshipRoleTemplateTypeFieldUpdateOperationsInput | $Enums.RelationshipRoleTemplateType
    key?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSettings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: ConversationMessageWhereUniqueInput
    update: XOR<ConversationMessageUpdateWithoutRelationshipInput, ConversationMessageUncheckedUpdateWithoutRelationshipInput>
    create: XOR<ConversationMessageCreateWithoutRelationshipInput, ConversationMessageUncheckedCreateWithoutRelationshipInput>
  }

  export type ConversationMessageUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: ConversationMessageWhereUniqueInput
    data: XOR<ConversationMessageUpdateWithoutRelationshipInput, ConversationMessageUncheckedUpdateWithoutRelationshipInput>
  }

  export type ConversationMessageUpdateManyWithWhereWithoutRelationshipInput = {
    where: ConversationMessageScalarWhereInput
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type GrowthMetricUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: GrowthMetricWhereUniqueInput
    update: XOR<GrowthMetricUpdateWithoutRelationshipInput, GrowthMetricUncheckedUpdateWithoutRelationshipInput>
    create: XOR<GrowthMetricCreateWithoutRelationshipInput, GrowthMetricUncheckedCreateWithoutRelationshipInput>
  }

  export type GrowthMetricUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: GrowthMetricWhereUniqueInput
    data: XOR<GrowthMetricUpdateWithoutRelationshipInput, GrowthMetricUncheckedUpdateWithoutRelationshipInput>
  }

  export type GrowthMetricUpdateManyWithWhereWithoutRelationshipInput = {
    where: GrowthMetricScalarWhereInput
    data: XOR<GrowthMetricUpdateManyMutationInput, GrowthMetricUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type GrowthMetricScalarWhereInput = {
    AND?: GrowthMetricScalarWhereInput | GrowthMetricScalarWhereInput[]
    OR?: GrowthMetricScalarWhereInput[]
    NOT?: GrowthMetricScalarWhereInput | GrowthMetricScalarWhereInput[]
    id?: StringFilter<"GrowthMetric"> | string
    relationshipId?: StringFilter<"GrowthMetric"> | string
    bucketDate?: DateTimeFilter<"GrowthMetric"> | Date | string
    messagesCount?: IntFilter<"GrowthMetric"> | number
    positiveCount?: IntFilter<"GrowthMetric"> | number
    neutralCount?: IntFilter<"GrowthMetric"> | number
    negativeCount?: IntFilter<"GrowthMetric"> | number
    metrics?: JsonNullableFilter<"GrowthMetric">
  }

  export type RelationshipCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutRelationshipsInput
    counterpartUser?: UserCreateNestedOneWithoutCounterpartRelsInput
    roleTemplate?: RoleTemplateCreateNestedOneWithoutRelationshipsInput
    growthMetrics?: GrowthMetricCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    counterpartUserId?: string | null
    roleTemplateId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    growthMetrics?: GrowthMetricUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutMessagesInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutMessagesInput, RelationshipUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    relationships?: RelationshipCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileCreateNestedOneWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    relationships?: RelationshipUncheckedCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileUncheckedCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileUncheckedCreateNestedOneWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type RelationshipUpsertWithoutMessagesInput = {
    update: XOR<RelationshipUpdateWithoutMessagesInput, RelationshipUncheckedUpdateWithoutMessagesInput>
    create: XOR<RelationshipCreateWithoutMessagesInput, RelationshipUncheckedCreateWithoutMessagesInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutMessagesInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutMessagesInput, RelationshipUncheckedUpdateWithoutMessagesInput>
  }

  export type RelationshipUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutRelationshipsNestedInput
    counterpartUser?: UserUpdateOneWithoutCounterpartRelsNestedInput
    roleTemplate?: RoleTemplateUpdateOneWithoutRelationshipsNestedInput
    growthMetrics?: GrowthMetricUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    counterpartUserId?: NullableStringFieldUpdateOperationsInput | string | null
    roleTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    growthMetrics?: GrowthMetricUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUpdateOneWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUncheckedUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUncheckedUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUncheckedUpdateOneWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type RelationshipCreateWithoutGrowthMetricsInput = {
    id?: string
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutRelationshipsInput
    counterpartUser?: UserCreateNestedOneWithoutCounterpartRelsInput
    roleTemplate?: RoleTemplateCreateNestedOneWithoutRelationshipsInput
    messages?: ConversationMessageCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutGrowthMetricsInput = {
    id?: string
    userId: string
    counterpartUserId?: string | null
    roleTemplateId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutGrowthMetricsInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutGrowthMetricsInput, RelationshipUncheckedCreateWithoutGrowthMetricsInput>
  }

  export type RelationshipUpsertWithoutGrowthMetricsInput = {
    update: XOR<RelationshipUpdateWithoutGrowthMetricsInput, RelationshipUncheckedUpdateWithoutGrowthMetricsInput>
    create: XOR<RelationshipCreateWithoutGrowthMetricsInput, RelationshipUncheckedCreateWithoutGrowthMetricsInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutGrowthMetricsInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutGrowthMetricsInput, RelationshipUncheckedUpdateWithoutGrowthMetricsInput>
  }

  export type RelationshipUpdateWithoutGrowthMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutRelationshipsNestedInput
    counterpartUser?: UserUpdateOneWithoutCounterpartRelsNestedInput
    roleTemplate?: RoleTemplateUpdateOneWithoutRelationshipsNestedInput
    messages?: ConversationMessageUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutGrowthMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    counterpartUserId?: NullableStringFieldUpdateOperationsInput | string | null
    roleTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ConversationMessageUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type UserCreateWithoutVoiceProfileInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    relationships?: RelationshipCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipCreateNestedManyWithoutCounterpartUserInput
    avatarProfile?: AvatarProfileCreateNestedOneWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutVoiceProfileInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    relationships?: RelationshipUncheckedCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput
    avatarProfile?: AvatarProfileUncheckedCreateNestedOneWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutVoiceProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoiceProfileInput, UserUncheckedCreateWithoutVoiceProfileInput>
  }

  export type VoiceSampleCreateWithoutVoiceProfileInput = {
    id?: string
    url: string
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VoiceSampleUncheckedCreateWithoutVoiceProfileInput = {
    id?: string
    url: string
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VoiceSampleCreateOrConnectWithoutVoiceProfileInput = {
    where: VoiceSampleWhereUniqueInput
    create: XOR<VoiceSampleCreateWithoutVoiceProfileInput, VoiceSampleUncheckedCreateWithoutVoiceProfileInput>
  }

  export type VoiceSampleCreateManyVoiceProfileInputEnvelope = {
    data: VoiceSampleCreateManyVoiceProfileInput | VoiceSampleCreateManyVoiceProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVoiceProfileInput = {
    update: XOR<UserUpdateWithoutVoiceProfileInput, UserUncheckedUpdateWithoutVoiceProfileInput>
    create: XOR<UserCreateWithoutVoiceProfileInput, UserUncheckedCreateWithoutVoiceProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoiceProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoiceProfileInput, UserUncheckedUpdateWithoutVoiceProfileInput>
  }

  export type UserUpdateWithoutVoiceProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUpdateManyWithoutCounterpartUserNestedInput
    avatarProfile?: AvatarProfileUpdateOneWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutVoiceProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUncheckedUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput
    avatarProfile?: AvatarProfileUncheckedUpdateOneWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type VoiceSampleUpsertWithWhereUniqueWithoutVoiceProfileInput = {
    where: VoiceSampleWhereUniqueInput
    update: XOR<VoiceSampleUpdateWithoutVoiceProfileInput, VoiceSampleUncheckedUpdateWithoutVoiceProfileInput>
    create: XOR<VoiceSampleCreateWithoutVoiceProfileInput, VoiceSampleUncheckedCreateWithoutVoiceProfileInput>
  }

  export type VoiceSampleUpdateWithWhereUniqueWithoutVoiceProfileInput = {
    where: VoiceSampleWhereUniqueInput
    data: XOR<VoiceSampleUpdateWithoutVoiceProfileInput, VoiceSampleUncheckedUpdateWithoutVoiceProfileInput>
  }

  export type VoiceSampleUpdateManyWithWhereWithoutVoiceProfileInput = {
    where: VoiceSampleScalarWhereInput
    data: XOR<VoiceSampleUpdateManyMutationInput, VoiceSampleUncheckedUpdateManyWithoutVoiceProfileInput>
  }

  export type VoiceSampleScalarWhereInput = {
    AND?: VoiceSampleScalarWhereInput | VoiceSampleScalarWhereInput[]
    OR?: VoiceSampleScalarWhereInput[]
    NOT?: VoiceSampleScalarWhereInput | VoiceSampleScalarWhereInput[]
    id?: StringFilter<"VoiceSample"> | string
    voiceProfileId?: StringFilter<"VoiceSample"> | string
    url?: StringFilter<"VoiceSample"> | string
    durationMs?: IntNullableFilter<"VoiceSample"> | number | null
    metadata?: JsonNullableFilter<"VoiceSample">
    createdAt?: DateTimeFilter<"VoiceSample"> | Date | string
  }

  export type VoiceProfileCreateWithoutSamplesInput = {
    id?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVoiceProfileInput
  }

  export type VoiceProfileUncheckedCreateWithoutSamplesInput = {
    id?: string
    userId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoiceProfileCreateOrConnectWithoutSamplesInput = {
    where: VoiceProfileWhereUniqueInput
    create: XOR<VoiceProfileCreateWithoutSamplesInput, VoiceProfileUncheckedCreateWithoutSamplesInput>
  }

  export type VoiceProfileUpsertWithoutSamplesInput = {
    update: XOR<VoiceProfileUpdateWithoutSamplesInput, VoiceProfileUncheckedUpdateWithoutSamplesInput>
    create: XOR<VoiceProfileCreateWithoutSamplesInput, VoiceProfileUncheckedCreateWithoutSamplesInput>
    where?: VoiceProfileWhereInput
  }

  export type VoiceProfileUpdateToOneWithWhereWithoutSamplesInput = {
    where?: VoiceProfileWhereInput
    data: XOR<VoiceProfileUpdateWithoutSamplesInput, VoiceProfileUncheckedUpdateWithoutSamplesInput>
  }

  export type VoiceProfileUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVoiceProfileNestedInput
  }

  export type VoiceProfileUncheckedUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    sampleUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAvatarProfileInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    relationships?: RelationshipCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileCreateNestedOneWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAvatarProfileInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    relationships?: RelationshipUncheckedCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileUncheckedCreateNestedOneWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAvatarProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAvatarProfileInput, UserUncheckedCreateWithoutAvatarProfileInput>
  }

  export type AvatarAssetCreateWithoutAvatarProfileInput = {
    id?: string
    url: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AvatarAssetUncheckedCreateWithoutAvatarProfileInput = {
    id?: string
    url: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AvatarAssetCreateOrConnectWithoutAvatarProfileInput = {
    where: AvatarAssetWhereUniqueInput
    create: XOR<AvatarAssetCreateWithoutAvatarProfileInput, AvatarAssetUncheckedCreateWithoutAvatarProfileInput>
  }

  export type AvatarAssetCreateManyAvatarProfileInputEnvelope = {
    data: AvatarAssetCreateManyAvatarProfileInput | AvatarAssetCreateManyAvatarProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAvatarProfileInput = {
    update: XOR<UserUpdateWithoutAvatarProfileInput, UserUncheckedUpdateWithoutAvatarProfileInput>
    create: XOR<UserCreateWithoutAvatarProfileInput, UserUncheckedCreateWithoutAvatarProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAvatarProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAvatarProfileInput, UserUncheckedUpdateWithoutAvatarProfileInput>
  }

  export type UserUpdateWithoutAvatarProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUpdateOneWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAvatarProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUncheckedUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUncheckedUpdateOneWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type AvatarAssetUpsertWithWhereUniqueWithoutAvatarProfileInput = {
    where: AvatarAssetWhereUniqueInput
    update: XOR<AvatarAssetUpdateWithoutAvatarProfileInput, AvatarAssetUncheckedUpdateWithoutAvatarProfileInput>
    create: XOR<AvatarAssetCreateWithoutAvatarProfileInput, AvatarAssetUncheckedCreateWithoutAvatarProfileInput>
  }

  export type AvatarAssetUpdateWithWhereUniqueWithoutAvatarProfileInput = {
    where: AvatarAssetWhereUniqueInput
    data: XOR<AvatarAssetUpdateWithoutAvatarProfileInput, AvatarAssetUncheckedUpdateWithoutAvatarProfileInput>
  }

  export type AvatarAssetUpdateManyWithWhereWithoutAvatarProfileInput = {
    where: AvatarAssetScalarWhereInput
    data: XOR<AvatarAssetUpdateManyMutationInput, AvatarAssetUncheckedUpdateManyWithoutAvatarProfileInput>
  }

  export type AvatarAssetScalarWhereInput = {
    AND?: AvatarAssetScalarWhereInput | AvatarAssetScalarWhereInput[]
    OR?: AvatarAssetScalarWhereInput[]
    NOT?: AvatarAssetScalarWhereInput | AvatarAssetScalarWhereInput[]
    id?: StringFilter<"AvatarAsset"> | string
    avatarProfileId?: StringFilter<"AvatarAsset"> | string
    url?: StringFilter<"AvatarAsset"> | string
    description?: StringNullableFilter<"AvatarAsset"> | string | null
    metadata?: JsonNullableFilter<"AvatarAsset">
    createdAt?: DateTimeFilter<"AvatarAsset"> | Date | string
  }

  export type AvatarProfileCreateWithoutAssetsInput = {
    id?: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAvatarProfileInput
  }

  export type AvatarProfileUncheckedCreateWithoutAssetsInput = {
    id?: string
    userId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvatarProfileCreateOrConnectWithoutAssetsInput = {
    where: AvatarProfileWhereUniqueInput
    create: XOR<AvatarProfileCreateWithoutAssetsInput, AvatarProfileUncheckedCreateWithoutAssetsInput>
  }

  export type AvatarProfileUpsertWithoutAssetsInput = {
    update: XOR<AvatarProfileUpdateWithoutAssetsInput, AvatarProfileUncheckedUpdateWithoutAssetsInput>
    create: XOR<AvatarProfileCreateWithoutAssetsInput, AvatarProfileUncheckedCreateWithoutAssetsInput>
    where?: AvatarProfileWhereInput
  }

  export type AvatarProfileUpdateToOneWithWhereWithoutAssetsInput = {
    where?: AvatarProfileWhereInput
    data: XOR<AvatarProfileUpdateWithoutAssetsInput, AvatarProfileUncheckedUpdateWithoutAssetsInput>
  }

  export type AvatarProfileUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAvatarProfileNestedInput
  }

  export type AvatarProfileUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUploadsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    relationships?: RelationshipCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileCreateNestedOneWithoutUserInput
    usageEvents?: UsageEventCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutUploadsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    relationships?: RelationshipUncheckedCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileUncheckedCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileUncheckedCreateNestedOneWithoutUserInput
    usageEvents?: UsageEventUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutUploadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
  }

  export type UserUpsertWithoutUploadsInput = {
    update: XOR<UserUpdateWithoutUploadsInput, UserUncheckedUpdateWithoutUploadsInput>
    create: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadsInput, UserUncheckedUpdateWithoutUploadsInput>
  }

  export type UserUpdateWithoutUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUpdateOneWithoutUserNestedInput
    usageEvents?: UsageEventUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUncheckedUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUncheckedUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUncheckedUpdateOneWithoutUserNestedInput
    usageEvents?: UsageEventUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutUsageEventsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    relationships?: RelationshipCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileCreateNestedOneWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutUsageEventsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    relationships?: RelationshipUncheckedCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileUncheckedCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileUncheckedCreateNestedOneWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentMessages?: ConversationMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutUsageEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageEventsInput, UserUncheckedCreateWithoutUsageEventsInput>
  }

  export type UserUpsertWithoutUsageEventsInput = {
    update: XOR<UserUpdateWithoutUsageEventsInput, UserUncheckedUpdateWithoutUsageEventsInput>
    create: XOR<UserCreateWithoutUsageEventsInput, UserUncheckedCreateWithoutUsageEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageEventsInput, UserUncheckedUpdateWithoutUsageEventsInput>
  }

  export type UserUpdateWithoutUsageEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUpdateOneWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUncheckedUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUncheckedUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUncheckedUpdateOneWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentMessages?: ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserCreateNestedOneWithoutUserInput
    relationships?: RelationshipCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileCreateNestedOneWithoutUserInput
    uploads?: UploadCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventCreateNestedManyWithoutUserInput
    sentMessages?: ConversationMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authProvider?: $Enums.AuthProvider
    externalId?: string | null
    passwordHash?: string | null
    displayName?: string | null
    locale?: string | null
    timezone?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedCreateNestedOneWithoutUserInput
    relationships?: RelationshipUncheckedCreateNestedManyWithoutUserInput
    counterpartRels?: RelationshipUncheckedCreateNestedManyWithoutCounterpartUserInput
    voiceProfile?: VoiceProfileUncheckedCreateNestedOneWithoutUserInput
    avatarProfile?: AvatarProfileUncheckedCreateNestedOneWithoutUserInput
    uploads?: UploadUncheckedCreateNestedManyWithoutUserInput
    usageEvents?: UsageEventUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: ConversationMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUpdateOneWithoutUserNestedInput
    uploads?: UploadUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUpdateManyWithoutUserNestedInput
    sentMessages?: ConversationMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    adminProfile?: AdminUserUncheckedUpdateOneWithoutUserNestedInput
    relationships?: RelationshipUncheckedUpdateManyWithoutUserNestedInput
    counterpartRels?: RelationshipUncheckedUpdateManyWithoutCounterpartUserNestedInput
    voiceProfile?: VoiceProfileUncheckedUpdateOneWithoutUserNestedInput
    avatarProfile?: AvatarProfileUncheckedUpdateOneWithoutUserNestedInput
    uploads?: UploadUncheckedUpdateManyWithoutUserNestedInput
    usageEvents?: UsageEventUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: ConversationMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type EthicalConfigCreateWithoutHistoryInput = {
    id?: string
    name: string
    description?: string | null
    latestVersion?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: EthicalConfigVersionCreateNestedManyWithoutConfigInput
  }

  export type EthicalConfigUncheckedCreateWithoutHistoryInput = {
    id?: string
    name: string
    description?: string | null
    latestVersion?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: EthicalConfigVersionUncheckedCreateNestedManyWithoutConfigInput
  }

  export type EthicalConfigCreateOrConnectWithoutHistoryInput = {
    where: EthicalConfigWhereUniqueInput
    create: XOR<EthicalConfigCreateWithoutHistoryInput, EthicalConfigUncheckedCreateWithoutHistoryInput>
  }

  export type EthicalConfigUpsertWithoutHistoryInput = {
    update: XOR<EthicalConfigUpdateWithoutHistoryInput, EthicalConfigUncheckedUpdateWithoutHistoryInput>
    create: XOR<EthicalConfigCreateWithoutHistoryInput, EthicalConfigUncheckedCreateWithoutHistoryInput>
    where?: EthicalConfigWhereInput
  }

  export type EthicalConfigUpdateToOneWithWhereWithoutHistoryInput = {
    where?: EthicalConfigWhereInput
    data: XOR<EthicalConfigUpdateWithoutHistoryInput, EthicalConfigUncheckedUpdateWithoutHistoryInput>
  }

  export type EthicalConfigUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersion?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: EthicalConfigVersionUpdateManyWithoutConfigNestedInput
  }

  export type EthicalConfigUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latestVersion?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: EthicalConfigVersionUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type RelationshipCreateManyUserInput = {
    id?: string
    counterpartUserId?: string | null
    roleTemplateId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type RelationshipCreateManyCounterpartUserInput = {
    id?: string
    userId: string
    roleTemplateId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type UploadCreateManyUserInput = {
    id?: string
    mediaType: $Enums.MediaType
    url: string
    originalName?: string | null
    sizeBytes?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageEventCreateManyUserInput = {
    id?: string
    type: $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: string
    action: $Enums.AuditAction
    entityType: $Enums.AuditEntityType
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageCreateManySenderInput = {
    id?: string
    relationshipId: string
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RelationshipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    counterpartUser?: UserUpdateOneWithoutCounterpartRelsNestedInput
    roleTemplate?: RoleTemplateUpdateOneWithoutRelationshipsNestedInput
    messages?: ConversationMessageUpdateManyWithoutRelationshipNestedInput
    growthMetrics?: GrowthMetricUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    counterpartUserId?: NullableStringFieldUpdateOperationsInput | string | null
    roleTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ConversationMessageUncheckedUpdateManyWithoutRelationshipNestedInput
    growthMetrics?: GrowthMetricUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    counterpartUserId?: NullableStringFieldUpdateOperationsInput | string | null
    roleTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RelationshipUpdateWithoutCounterpartUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutRelationshipsNestedInput
    roleTemplate?: RoleTemplateUpdateOneWithoutRelationshipsNestedInput
    messages?: ConversationMessageUpdateManyWithoutRelationshipNestedInput
    growthMetrics?: GrowthMetricUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutCounterpartUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ConversationMessageUncheckedUpdateManyWithoutRelationshipNestedInput
    growthMetrics?: GrowthMetricUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateManyWithoutCounterpartUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UploadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUsageEventTypeFieldUpdateOperationsInput | $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUsageEventTypeFieldUpdateOperationsInput | $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUsageEventTypeFieldUpdateOperationsInput | $Enums.UsageEventType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ConversationMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EthicalConfigVersionCreateManyConfigInput = {
    id?: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdById?: string | null
  }

  export type ConfigVersionHistoryCreateManyConfigInput = {
    id?: string
    fromVersion: number
    toVersion: number
    reason?: string | null
    changedById?: string | null
    changedAt?: Date | string
  }

  export type EthicalConfigVersionUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EthicalConfigVersionUncheckedUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EthicalConfigVersionUncheckedUpdateManyWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigVersionHistoryUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: IntFieldUpdateOperationsInput | number
    toVersion?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigVersionHistoryUncheckedUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: IntFieldUpdateOperationsInput | number
    toVersion?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigVersionHistoryUncheckedUpdateManyWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: IntFieldUpdateOperationsInput | number
    toVersion?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipCreateManyRoleTemplateInput = {
    id?: string
    userId: string
    counterpartUserId?: string | null
    title?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type RelationshipUpdateWithoutRoleTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutRelationshipsNestedInput
    counterpartUser?: UserUpdateOneWithoutCounterpartRelsNestedInput
    messages?: ConversationMessageUpdateManyWithoutRelationshipNestedInput
    growthMetrics?: GrowthMetricUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutRoleTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    counterpartUserId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ConversationMessageUncheckedUpdateManyWithoutRelationshipNestedInput
    growthMetrics?: GrowthMetricUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateManyWithoutRoleTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    counterpartUserId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConversationMessageCreateManyRelationshipInput = {
    id?: string
    senderId?: string | null
    content: string
    emotionalTone: $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GrowthMetricCreateManyRelationshipInput = {
    id?: string
    bucketDate: Date | string
    messagesCount?: number
    positiveCount?: number
    neutralCount?: number
    negativeCount?: number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ConversationMessageUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneWithoutSentMessagesNestedInput
  }

  export type ConversationMessageUncheckedUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateManyWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    emotionalTone?: EnumEmotionalToneFieldUpdateOperationsInput | $Enums.EmotionalTone
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GrowthMetricUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesCount?: IntFieldUpdateOperationsInput | number
    positiveCount?: IntFieldUpdateOperationsInput | number
    neutralCount?: IntFieldUpdateOperationsInput | number
    negativeCount?: IntFieldUpdateOperationsInput | number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GrowthMetricUncheckedUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesCount?: IntFieldUpdateOperationsInput | number
    positiveCount?: IntFieldUpdateOperationsInput | number
    neutralCount?: IntFieldUpdateOperationsInput | number
    negativeCount?: IntFieldUpdateOperationsInput | number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type GrowthMetricUncheckedUpdateManyWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messagesCount?: IntFieldUpdateOperationsInput | number
    positiveCount?: IntFieldUpdateOperationsInput | number
    neutralCount?: IntFieldUpdateOperationsInput | number
    negativeCount?: IntFieldUpdateOperationsInput | number
    metrics?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VoiceSampleCreateManyVoiceProfileInput = {
    id?: string
    url: string
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VoiceSampleUpdateWithoutVoiceProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSampleUncheckedUpdateWithoutVoiceProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoiceSampleUncheckedUpdateManyWithoutVoiceProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarAssetCreateManyAvatarProfileInput = {
    id?: string
    url: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AvatarAssetUpdateWithoutAvatarProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarAssetUncheckedUpdateWithoutAvatarProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarAssetUncheckedUpdateManyWithoutAvatarProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}